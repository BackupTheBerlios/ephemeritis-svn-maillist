From izogi at berlios.de  Thu Jan  5 09:27:21 2006
From: izogi at berlios.de (izogi at BerliOS)
Date: Thu, 5 Jan 2006 09:27:21 +0100
Subject: [Ephemeritis-svn] r191 - in trunk: . src/c/libephemeritis src/c/tests
Message-ID: <200601050827.k058RL9r005071@sheep.berlios.de>

Author: izogi
Date: 2006-01-05 09:27:10 +0100 (Thu, 05 Jan 2006)
New Revision: 191

Added:
   trunk/src/c/libephemeritis/aberration.c
Modified:
   trunk/ChangeLog
   trunk/src/c/libephemeritis/Makefile.am
   trunk/src/c/libephemeritis/constellations.c
   trunk/src/c/libephemeritis/conversions.c
   trunk/src/c/libephemeritis/dynamical.c
   trunk/src/c/libephemeritis/elliptical.c
   trunk/src/c/libephemeritis/elp2000.c
   trunk/src/c/libephemeritis/ephemeritis.h
   trunk/src/c/libephemeritis/equationoftime.c
   trunk/src/c/libephemeritis/nutation.c
   trunk/src/c/libephemeritis/precession.c
   trunk/src/c/libephemeritis/solar.c
   trunk/src/c/libephemeritis/vsop87d.c
   trunk/src/c/tests/validate_meeus.c
Log:
Many changes from when I was on holiday -- from the temporary ChangeLog:

  * Added aberration.c for code that calculates aberration adjustments.
  * Renamed obliquity() to obliquity_low(), to emphasise that it's
    relatively low accuracy.
  * Added a collection of unit testing for chapter 23 in Meeus, which
    collects various operations necessary for the apparent place of a
    star.
  * Added unit tests to validate_meeus for elliptical orbit calculation,
    based on figures made available by the International Bureau of
    Astronomical Telegrammes.  (Note: It's still out by about 100 or so
    arc-seconds in RA and Dec, possibly due to the Sun's VSOP position not
    being calculated correctly.
  * Adjusted several places, such as nutation code, where constants were
    being calculated on every call to a function even though they were going
    to be the same every time.  They're now declared as static variables and
    only initialised the first time the function's called.
  * Added nut_in_ra_dec().
  * Added ut_to_dt(), to simplify addition of dynamical difference to UT.
  * Added circumpi(), similar to modpi2() but will return a negative angle
    if it fits between -pi..0, positive between 0..pi.
  * Adjusted fday_to_hms() to accept the seconds parameter as double
    instead of int.
  * Added r_to_fday(), r_to_hms(), fday_to_r() and hms_to_r().
  * Changed several functions that requested an out structure variable, so
    that they simply returned the structure type by value.  (It just seems
    simpler to use this way, and it's unlikely to be more than a trivial  
    efficiency issue.)
  * Changed elliptical_orbit_rectangular() so that it requests the solar
    radius of a body instead of calculating and returning it.
  * Added get_r_sun() to calculate the solar radius of a body.
  * Added populate_orbital_elements() for populated an orbital_elements
    structure in a managed way.



Modified: trunk/ChangeLog
===================================================================
--- trunk/ChangeLog	2005-12-25 02:43:38 UTC (rev 190)
+++ trunk/ChangeLog	2006-01-05 08:27:10 UTC (rev 191)
@@ -1,3 +1,37 @@
+ephemeritis (0.4.5 unreleased)
+  [ Mike McGavin ]
+  * Added aberration.c for code that calculates aberration adjustments.
+  * Renamed obliquity() to obliquity_low(), to emphasise that it's
+    relatively low accuracy.
+  * Added a collection of unit testing for chapter 23 in Meeus, which
+    collects various operations necessary for the apparent place of a
+    star.
+  * Added unit tests to validate_meeus for elliptical orbit calculation,
+    based on figures made available by the International Bureau of
+    Astronomical Telegrammes.  (Note: It's still out by about 100 or so
+    arc-seconds in RA and Dec, possibly due to the Sun's VSOP position not
+    being calculated correctly.
+  * Adjusted several places, such as nutation code, where constants were
+    being calculated on every call to a function even though they were going
+    to be the same every time.  They're now declared as static variables and
+    only initialised the first time the function's called.
+  * Added nut_in_ra_dec().
+  * Added ut_to_dt(), to simplify addition of dynamical difference to UT.
+  * Added circumpi(), similar to modpi2() but will return a negative angle
+    if it fits between -pi..0, positive between 0..pi.
+  * Adjusted fday_to_hms() to accept the seconds parameter as double
+    instead of int.
+  * Added r_to_fday(), r_to_hms(), fday_to_r() and hms_to_r().
+  * Changed several functions that requested an out structure variable, so
+    that they simply returned the structure type by value.  (It just seems
+    simpler to use this way, and it's unlikely to be more than a trivial
+    efficiency issue.)
+  * Changed elliptical_orbit_rectangular() so that it requests the solar
+    radius of a body instead of calculating and returning it.
+  * Added get_r_sun() to calculate the solar radius of a body.
+  * Added populate_orbital_elements() for populated an orbital_elements
+    structure in a managed way.
+
 ephemeritis (0.4.4)
   [ Mike McGavin ]
   * Ran all code through 'indent -kr' to enforce Kerninghan & Ritchie indentation.

Modified: trunk/src/c/libephemeritis/Makefile.am
===================================================================
--- trunk/src/c/libephemeritis/Makefile.am	2005-12-25 02:43:38 UTC (rev 190)
+++ trunk/src/c/libephemeritis/Makefile.am	2006-01-05 08:27:10 UTC (rev 191)
@@ -5,6 +5,7 @@
 lib_LTLIBRARIES = libephemeritis.la
 
 libephemeritis_la_SOURCES = \
+	aberration.c \
 	constants.c \
 	constellations.c \
 	conversions.c \

Added: trunk/src/c/libephemeritis/aberration.c
===================================================================
--- trunk/src/c/libephemeritis/aberration.c	2005-12-25 02:43:38 UTC (rev 190)
+++ trunk/src/c/libephemeritis/aberration.c	2006-01-05 08:27:10 UTC (rev 191)
@@ -0,0 +1,147 @@
+/* Copyright 2000, 2001, 2005, 2006 Mike McGavin
+
+This file is part of Ephemeritis.
+
+Ephemeritis is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+Ephemeritis is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Ephemeritis; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+/*! @file aberration.c
+ *
+ *  @brief Functions to calculate aberration values.
+ *
+ *  Reference: Jean Meeus, _Astronomical Algorithms_, second
+ *  edition, 1998, Willmann-Bell, Inc.
+ *
+ *  @todo Write code -- including ra/dec.
+ *  @todo Write documentation.
+ *  @todo Write unit tests.
+ *
+ *  @author Mike McGavin.
+ */
+
+#include "ephemeritis.h"
+#include "config.h"
+
+#include <math.h>
+
+
+
+
+static void _constants(double jd, double *e, double *p, double *K)
+{
+    double T = jd_to_jcent(jd);
+    /*
+(jd - 2451545.0) / 36525.0;
+*/
+    double e_terms[] = { 0.016708634, -0.000042037, -0.0000001267 };
+    double p_terms[] =
+	{ d_to_r(102.93735), d_to_r(1.71946), d_to_r(0.00046) };
+
+    *e = polynomial(e_terms, 3, T);
+    *p = polynomial(p_terms, 3, T);
+
+    *K = d_to_r(dms_to_d(0, 0, 20.49552));
+}
+
+
+/*! @brief Calculates adjustments in celestial longitude and latitude
+ *  due to annual aberration.
+ *
+ *  [Meeus 1998: 23.2]
+ *
+ *  This is not a rigorously exact formula, as it assumes that the
+ *  Earth's orbit is unperterbed, which isn't really correct.  For
+ *  rigorous calculation, work in RA/Dec and use aberration_in_ra_dec.
+ *
+ *  @param[in]  jd        The julian day, in dynamical time.
+ *  @param[in]  lon       The celestial longitude, in radians.
+ *  @param[in]  lat       The celestial latitude, in radians.
+ *  @param[in]  sol_lon   The true geometric longitude of the Sun.
+ *  @param[out] delta_lon The adjustment for longitude.
+ *  @param[out] delta_lat The adjustment for latitude.
+ *
+ *  @todo Unit tests.
+ *
+ *  @sa aberration_in_ra_dec_low
+ *  @sa aberration_in_ra_dec
+ */
+void aberration_in_lon_lat_low(double jd, double lon, double lat,
+			       double sol_lon, double *delta_lon,
+			       double *delta_lat)
+{
+    double e, p, K;
+    _constants(jd, &e, &p, &K);
+    *delta_lon =
+	(((-K * cos(sol_lon - lon)) + (e * K * cos(p - lon))) / cos(lat));
+    *delta_lat = -K * sin(lat) * (sin(sol_lon - lon) - e * sin(p - lon));
+}
+
+/*! @brief Calculates adjustments in right ascension and declination
+ *  due to annual aberration.
+ *
+ *  [Meeus 1998: 23.3]
+ *
+ *  This is not a rigorously exact formula, as it assumes that the
+ *  Earth's orbit is unperterbed, which isn't really correct.  For
+ *  rigorous calculation, work in RA/Dec and use aberration_in_ra_dec.
+ *
+ *  @param[in]  jd        The julian day, in dynamical time.
+ *  @param[in]  ra        The celestial longitude, in radians.
+ *  @param[in]  dec       The celestial latitude, in radians.
+ *  @param[in]  obl       The obliquity of the ecliptic at the jd of calculation.
+ *  @param[in]  sol_lon   The true geometric longitude of the Sun.
+ *  @param[out] delta_ra  The adjustment for longitude.
+ *  @param[out] delta_dec The adjustment for latitude.
+ *
+ *  @sa aberration_in_lat_lon_low
+ *  @sa aberration_in_ra_dec
+ */
+void aberration_in_ra_dec_low(double jd, double ra, double dec, double obl,
+			      double sol_lon, double *delta_ra,
+			      double *delta_dec)
+{
+    double e, p, K;
+    _constants(jd, &e, &p, &K);
+
+    double cosra = cos(ra);
+    double cossol_lon = cos(sol_lon);
+    double cosobl = cos(obl);
+    double sinra = sin(ra);
+    double sinsol_lon = sin(sol_lon);
+    double cosdec = cos(dec);
+    double cosp = cos(p);
+    double sinp = sin(p);
+    double tanobl = tan(obl);
+    double sindec = sin(dec);
+
+    double cosra_cosobl = cosra * cosobl;
+    double cosra_sindec = cosra * sindec;
+    double tanobl_cosdec__sinra_sindec = tanobl * cosdec - sinra * sindec;
+
+    *delta_ra =
+	-K * ((cosra_cosobl * cossol_lon + sinra * sinsol_lon) / cosdec)
+	+ e * K * (((cosra_cosobl * cosp) + (sinra * sinp)) / cosdec);
+
+    *delta_dec =
+	-K * ((cossol_lon * cosobl * tanobl_cosdec__sinra_sindec) +
+	      (cosra_sindec * sinsol_lon))
+	+ e * K * ((cosp * cosobl * tanobl_cosdec__sinra_sindec) +
+		   (cosra_sindec * sinp));
+}
+
+
+void aberration_in_ra_dec()
+{
+}

Modified: trunk/src/c/libephemeritis/constellations.c
===================================================================
--- trunk/src/c/libephemeritis/constellations.c	2005-12-25 02:43:38 UTC (rev 190)
+++ trunk/src/c/libephemeritis/constellations.c	2006-01-05 08:27:10 UTC (rev 191)
@@ -537,7 +537,7 @@
  *  @return          The index of the list at which the position has been found.
  */
 static int raw_scan_boundaries(const constellation_boundary * list,
-			const double ra, const double dec)
+			       const double ra, const double dec)
 {
     /* Scan through the list until NoConstellation is encountered, or
      * the constellation is found.  The former should never happen with

Modified: trunk/src/c/libephemeritis/conversions.c
===================================================================
--- trunk/src/c/libephemeritis/conversions.c	2005-12-25 02:43:38 UTC (rev 190)
+++ trunk/src/c/libephemeritis/conversions.c	2006-01-05 08:27:10 UTC (rev 191)
@@ -20,6 +20,7 @@
 /*! @file conversions.c
  *
  *  @brief Collection of functions for performing conversions.
+ *
  */
 
 #include "ephemeritis.h"
@@ -89,6 +90,7 @@
  *  @return       b - a, in radians.
  *
  *  @sa modpi2
+ *  @sa circumpi
  */
 double diff_angle(double a, double b)
 {
@@ -135,7 +137,7 @@
  *  @param[out] ra         Right ascension, in radians.
  *  @param[out] dec        Declination, in radians.
  *
- *  @sa obliquity + nut_in_obl for calculating true obliquity.
+ *  @sa obliquity_hi + nut_in_obl for calculating true obliquity.
  */
 void ecl_to_equ(double longitude, double latitude, double obliquity,
 		double *ra, double *dec)
@@ -214,7 +216,7 @@
  *  @param[out] longitude Ecliptic longitude, in radians.
  *  @param[out] latitude  Ecliptic latitude, in radians.
  *
- *  @sa nutation::obliquity + nutation::nut_in_obl for calculating true obliquity.
+ *  @sa obliquity_hi + nut_in_obl for calculating true obliquity.
  */
 void equ_to_ecl(double ra, double dec, double obliquity, double *longitude,
 		double *latitude)
@@ -235,14 +237,23 @@
  *  @param[out] min  Minute (0..59).
  *  @param[out] sec  Second (0..59).
  */
-void fday_to_hms(double day, int *hour, int *min, int *sec)
+void fday_to_hms(double day, int *hour, int *min, double *sec)
 {
+  /*
     const long tsec = (long) (day * seconds_per_day);
     const int tmin = tsec / 60;
     const int thour = tmin / 60;
     *hour = thour % 24;
     *min = tmin % 60;
     *sec = tsec % 60;
+    */
+
+    double tsec = day * seconds_per_day;
+    *hour = (int) (tsec / 3600.0);
+    tsec -= (*hour) * 3600.0;
+    *min = (int) (tsec / 60.0);
+    tsec -= (*min) * 60.0;
+    *sec = tsec;
 }
 
 /*! @brief Converts hours-minutes-seconds into a fractional day 0.0..1.0.
@@ -260,18 +271,60 @@
 }
 
 /*! @brief Converts fractional day to radians.
- * 
+ *
  *  @param[in]  fday A fractional day, 0..24.
- * 
+ *
  *  @return          The angle in radians.
- * 
+ *
  *  @author Mike McGavin.
  */
-double fday_to_r(double fday)
+double fday_to_r(const double fday)
 {
     return modpi2(fday * 2 * pi);
 }
 
+
+/*! @brief Converts radians to fractional day.
+ *
+ *  @param[in]  r    The angle in radians.
+ *
+ *  @@return         A fractional day, 0..24.
+ *
+ *  @author Mike McGavin.
+ */
+double r_to_fday(const double r)
+{
+    return modpi2(r) / (2 * pi);
+}
+
+/*! @brief Converts radians to hours-minutes-seconds.
+ *
+ *  @param[in]   r   The angle in radians.
+ *  @param[out]  hr  Hours, 0..23.
+ *  @param[out]  mn  Minutes, 0..59.
+ *  @param[out]  sec Seconds, 0..59.
+ *
+ *  @author Mike McGavin.
+ */
+void r_to_hms(const double r, int *hr, int *mn, double *sec)
+{
+    return fday_to_hms(r_to_fday(r), hr, mn, sec);
+}
+
+
+/*! @brief Converts hours-minutes-seconds into radians.
+ *
+ *  @param[in]  hr  Hours, 0..23.
+ *  @param[in]  mn  Minutes, 0..59.
+ *  @param[in]  sec Seconds, 0..59.
+ *
+ *  @return         The angle in radians.
+ */
+double hms_to_r(const int hr, const int mn, const double sec)
+{
+    return fday_to_r(hms_to_fday(hr, mn, sec));
+}
+
 /*! @brief Reduces an angle in radians to the range 0..2pi.
  *
  *  @param[in]  x  An angle, in radians.
@@ -279,6 +332,7 @@
  *  @return        An angle in radians, in the range 0..2pi.
  *
  *  @sa diff_angle
+ *  @sa circumpi
  */
 double modpi2(double x)
 {
@@ -289,6 +343,23 @@
     return x;
 }
 
+/*! @brief Reduces an angle in radians to the range -pi..pi.  Useful
+ *  for declination, latitude, etc.
+ *
+ *  @param[in]  x  An angle, in radians.
+ *
+ *  @return        An angle in radians, in the range -pi..pi.
+ *
+ *  @sa modpi2
+ *
+ *  @author Mike McGavin.
+ */
+double circumpi(double x)
+{
+  x = modpi2(x);
+  return x > pi ? x - 2*pi : x;
+}
+
 /*! @brief Converts radians to degrees.
  *
  *  @param[in]  r  Radians.

Modified: trunk/src/c/libephemeritis/dynamical.c
===================================================================
--- trunk/src/c/libephemeritis/dynamical.c	2005-12-25 02:43:38 UTC (rev 190)
+++ trunk/src/c/libephemeritis/dynamical.c	2006-01-05 08:27:10 UTC (rev 191)
@@ -22,10 +22,18 @@
  *  @brief Functions which calculate the deltaT correction to convert
  *  between dynamical and universal time.
  *
+ *  The rotation speed of the Earth is slowing down over time, meaning
+ *  that the day-to-day terrestrial time scale isn't uniform.  This
+ *  isn't acceptable for celestial calculations, which require a
+ *  uniform and predictable time scale to work with.  These functions
+ *  allow for terrestrial-based Universal time, which is based on the
+ *  rotation of the Earth, to be converted to the uniform Dynamical
+ *  Time.
+ *
  *  Reference: Jean Meeus, _Astronomical Algorithms_, second
  *  edition, 1998, Willmann-Bell, Inc.
  *
- *  @author William McClain
+ *  @author William McClain, Mike McGavin.
  */
 
 #include "ephemeritis.h"
@@ -255,12 +263,18 @@
 
 
 
-/*! @brief Returns deltaT as seconds of time. 
+/*! @brief Returns the number of seconds difference between Universal
+ *  Time and Dynamical Time.
  *
- *  For a historical range from 1620 to a recent year, we
- *  interpolate from a table of observed values. Outside that *
- *  range we use formulae.
+ *  For a historical range from 1620 to a recent year, the value is
+ *  taken by interpolating from a table of observed values.  Outside
+ *  that range, formulae are used.  Given Universal Time
+ *  (Earth-rotational-centric and therefore not uniform), the deltaT
+ *  value returned by this function should be added in order to
+ *  generate Dynamical Time, which is uniform.
  *
+ *  [Meeus-1998: equations 10.1 and  10.2]
+ *
  *  @param[in] jd     Julian Day number.
  *
  *  @return           deltaT in seconds.
@@ -396,3 +410,15 @@
 {
     return jd - (deltaT_seconds(jd) / seconds_per_day);
 }
+
+
+/*! @brief Convert Julian Day from Universal Time to Dynamical Time.
+ *
+ *  @param[in] jd     Julian Day number (universal time).
+ *
+ *  @return           Julian Day number (dynamical time).
+ */
+double ut_to_dt(double jd)
+{
+    return jd + (deltaT_seconds(jd) / seconds_per_day);
+}

Modified: trunk/src/c/libephemeritis/elliptical.c
===================================================================
--- trunk/src/c/libephemeritis/elliptical.c	2005-12-25 02:43:38 UTC (rev 190)
+++ trunk/src/c/libephemeritis/elliptical.c	2006-01-05 08:27:10 UTC (rev 191)
@@ -26,7 +26,10 @@
  *  _Astronomical Algorithms_, second edition, 1998, Willmann-Bell,
  *  Inc.
  *
- *  @todo Check that modpi2() is used in all the appropriate places.
+ *  @todo Check that modpi2() is used in all the appropriate places,
+ *  when radian values are returned.  (Be careful about declination
+ *  and similar values, though, since it's sometimes more useful to
+ *  have -90 degrees than +270 degrees.)
  *
  *  @author Mike McGavin
  */
@@ -50,7 +53,7 @@
  *                                seriously tested from any other planets.
  *  @param[in]  targetPlanet      The planet for which the position should be calculated.
  *  @param[in]  (*heliocentic_f)  A function to calculate three heliocentric dimensions, returning the results in fk5 coordinates.
- *  @param[in]  deltaPsi  Nutation in longitude, in radians.
+ *  @param[in]  n_in_l    Nutation in longitude, in radians.
  *  @param[in]  epsilon   True obliquity (corrected for nutation), in radians.
  *  @param[in]  delta     Desired accuracy, in days.
  *
@@ -58,12 +61,18 @@
  *  @param[out] dec       Declination, in radians.
  *
  *  @returns             Returns  0 if successful.
- *                       Returns -1 if bailing out as calculated angle was invalid for some reason.
+ *                       Returns -1 if bailing out as desired accuracy was unreachable within a preset number of iterations.
  *
  *  @sa deltaT_seconds for calculating %dynamical time offset.
  *  @sa nut_in_lon for calculating %nutation in longitude.
- *  @sa (obliquity or obliquity_hi) + nut_in_obl for calculating true obliquity.
+ *  @sa (obliquity_low or obliquity_hi) + nut_in_obl for calculating true obliquity.
  *
+ *  @todo Check if this code actually <em>does</em> take aberration
+ *  into account.  The original description says it does, but it
+ *  doesn't seem to be apparent in the actual code.  I <em>think</em>
+ *  the act of moving the Earth as well as moving the body accounts
+ *  for abberation, but am not entirely sure.
+ *
  *  @todo Audit code and confirm that it's not breaking the algorithm
  *  to move the fk5 conversion back into the vsop coordinate
  *  calculations.  If it's a simple translation of coordinates (as I
@@ -75,6 +84,8 @@
  *  iteration and corrections for things really belong outside this
  *  function, as happens in elliptical_orbit_ecliptical.
  *
+ *  @todo Adjust parameters so that r_earth gets passed back too.
+ *
  *  @author Bill McClain, Mike McGavin.
  */
 int geocentric_planet(double jd,
@@ -82,7 +93,7 @@
 		      enum vPlanets targetPlanet,
 		      void (*heliocentic_f) (double, enum vPlanets,
 					     double *, double *, double *),
-		      double deltaPsi, double epsilon, double delta,
+		      double n_in_l, double epsilon, double delta,
 		      double *ra, double *dec)
 {
     double t = jd;
@@ -121,7 +132,8 @@
 	/* At this point, l and b respectively represent the
 	   geocentric longitude and geocentric latitude, but it hasn't
 	   been adjusted for the time it takes for light to travel to
-	   Earth, or for aberration. */
+	   Earth (if it's the first loop iteration), or for
+	   aberration. */
 
 	/* Distance to planet in AU. */
 	const double dist = sqrt(x2 + y2 + z * z);
@@ -153,10 +165,10 @@
      */
 
     /* Nutation in longitude. */
-    l += deltaPsi;
+    l += n_in_l;
 
     /* Equatorial coordinates. */
-    ecl_to_equ(l, b, epsilon, &(*ra), &(*dec));
+    ecl_to_equ(l, b, epsilon, ra, dec);
 
     /* Return success. */
     return 0;
@@ -334,26 +346,23 @@
  *  @param[in]  iterations Iterations of calculation to use (for accuracy).
  *                         33 iterations should be sufficient for 10 digit
  *                         accuracy, 53 for 16 digit accuracy.
- *  @param[out] ec  The calculated constants for the provided orbital elements.
  *
- *  @return A pointer to the ec structure that was passed in.  This
- *  return value is for convenience only.
+ *  @return The calculated constants for the provided orbital elements.
  *
  *  @sa elliptical_orbit_rectangular
  *
  *  @author Mike McGavin.
  */
-element_constants *get_element_constants(const double obl,
-					 const orbital_elements * elements,
-					 const int iterations,
-					 element_constants * ec)
+element_constants get_element_constants(const double obl,
+					const orbital_elements elements,
+					const int iterations)
 {
-    double cosL = cos(elements->L);
-    double sinL = sin(elements->L);
+    double cosL = cos(elements.L);
+    double sinL = sin(elements.L);
     double cosO = cos(obl);
     double sinO = sin(obl);
-    double cosi = cos(elements->i);
-    double sini = sin(elements->i);
+    double cosi = cos(elements.i);
+    double sini = sin(elements.i);
 
     double F = cosL;
     double G = sinL * cosO;
@@ -364,20 +373,22 @@
 
     /* Note that at this point, F^2 + G^2 + H^2 should == 1, and P^2 + Q^2 + R^2 == 1. */
 
-    ec->_A = atan2(F, P);
-    ec->_B = atan2(G, Q);
-    ec->_C = atan2(H, R);
+    element_constants ec;
 
-    ec->_a = sqrt(F * F + P * P);
-    ec->_b = sqrt(G * G + Q * Q);
-    ec->_c = sqrt(H * H + R * R);
+    ec._A = atan2(F, P);
+    ec._B = atan2(G, Q);
+    ec._C = atan2(H, R);
 
-    ec->E = eccentricity_anomoly(elements->M, elements->e, iterations);
+    ec._a = sqrt(F * F + P * P);
+    ec._b = sqrt(G * G + Q * Q);
+    ec._c = sqrt(H * H + R * R);
 
-    ec->w = elements->w;
-    ec->M = elements->M;
-    ec->a = elements->a;
-    ec->e = elements->e;
+    ec.E = eccentricity_anomoly(elements.M, elements.e, iterations);
+
+    ec.w = elements.w;
+    ec.M = elements.M;
+    ec.a = elements.a;
+    ec.e = elements.e;
     return ec;
 }
 
@@ -385,40 +396,43 @@
 /*! @brief Calculates the rectangular coordinates of a body, and its
  *  distance from the Sun, given appropriate orbital elements.
  *
-
-
  *  @param[in]  jd  The time at which to calculate the position, in dynamical time.
-
-
  *  @param[in]  ec  The calculated constants that apply for the orbit
  *                  being calculated.  Use get_element_constants to generate this
  *                  data.
-
- *  @param[in]  obl The obliquity of the ecliptic for the epoch at which i, L and w are provided.
- *  @param[in]  elements The known elements for the orbit to calculate.
-
- *  @param[out] rc  The rectangular coordinates of the body at the specified time.
- *  @param[out] r_sun The calculated distance of the body from the Sun, in AU, at the specified time.
+ *  @param[in] r_sun The radius vector (distance to the Sun) in
+ *                   astronomical units.
  *
- *  @return A pointer to the rc structure that was passed in.  This
- *  return value is for convenience only.
+ *  @return The rectangular coordinates of the body at the specified time.
  *
  *  @author Mike McGavin.
  */
-rec_coords *elliptical_orbit_rectangular(const element_constants * ec,
-					 rec_coords * rc, double *r_sun)
+rec_coords elliptical_orbit_rectangular(const element_constants ec,
+					const double r_sun)
 {
-    double v = true_anomoly(ec->e, ec->E);
-    double r = radius_vector(ec->a, ec->e, ec->E);
+    double v = true_anomoly(ec.e, ec.E);
 
-    rc->x = r * ec->_a * sin(ec->_A + ec->w + v);
-    rc->y = r * ec->_b * sin(ec->_B + ec->w + v);
-    rc->z = r * ec->_c * sin(ec->_C + ec->w + v);
+    rec_coords rc;
+    rc.x = r_sun * ec._a * sin(ec._A + ec.w + v);
+    rc.y = r_sun * ec._b * sin(ec._B + ec.w + v);
+    rc.z = r_sun * ec._c * sin(ec._C + ec.w + v);
 
-    *r_sun = r;
     return rc;
 }
 
+/*! @brief Returns the radius vector (distance between a body and the
+ *  Sun) given the body's set of element constants.
+ *
+ *  @param[in]  ec  The calculated constants that apply for the orbit
+ *                  being calculated.  Use get_element_constants to generate this
+ *                  data.
+ *
+ *  @return         The radius vector (distance to the Sun), in Astronomical Units.
+ */
+double get_r_sun(const element_constants ec)
+{
+  return radius_vector(ec.a, ec.e, ec.E);
+}
 
 /*! @brief Helper function to calculate magnitude using an absolute
  *  magnitude and cometary constant.
@@ -503,27 +517,34 @@
  *  @todo Adjust so that r_sun is calculated, or passed in more
  *  elegantly.
  *
+ *  @bug Generally seems to be out by amounts on the order of 100 or
+ *  so arc-seconds when using elements from the IBAT, and comparing
+ *  with IBAT's own result tables.  It's unclear whether this is due
+ *  to differences in calculation methods, incorrect adjustments after
+ *  the results are returned, or different interpretations as to
+ *  exactly what information is being provided.
+ *
  *  @author Mike McGavin.
  */
-void elliptical_orbit_ecliptical(const rec_coords * sol,
-				 const rec_coords * body,
+void elliptical_orbit_ecliptical(const rec_coords sol,
+				 const rec_coords body,
 				 const double r_sun,
 				 double *ra,
 				 double *dec,
 				 double *elongation,
 				 double *phase_angle, double *r_earth)
 {
-    double s = sol->x + body->x;
-    double n = sol->y + body->y;
-    double t = sol->z + body->z;
+    double s = sol.x + body.x;
+    double n = sol.y + body.y;
+    double t = sol.z + body.z;
 
     double r_e = sqrt(s * s + n * n + t * t);
     *r_earth = r_e;
 
     *ra = modpi2(atan2(n, s));
-    *dec = asin(t / *r_earth);
+    *dec = asin(t / r_e);
 
-    double R = sqrt(sol->x * sol->x + sol->y * sol->y + sol->x * sol->x);
+    double R = sqrt(sol.x * sol.x + sol.y * sol.y + sol.z * sol.z);
     *elongation =
 	acos((R * R + r_e * r_e - r_sun * r_sun) / (2 * R * r_e));
     *phase_angle =
@@ -531,31 +552,62 @@
 }
 
 
-/*
-void elliptical_body_angles(const rec_coords * sol,
-			    const element_mag_constants * emc,
-			    double * elongation,
-			    double * phase_angle)
+/*! @brief Provides a managed way to populate a set of orbital elements.
+ *
+ *  This function manages input regarding orbital elements, and
+ *  performs appropriate calculations where necessary to generate the
+ *  values to be placed in an orbital_elements struct.
+ *
+ *  @param[in] epoch   The epoch of the elements being provided.
+ *  @param[in] M_epoch The Mean Anomoly at the specified epoch.
+ *  @param[in] jd      The Julian Day for which orbital information is sought.
+ *  @param[in] n       Mean motion, in radians / day.  If this parameter is given as 0.0, it will be calculated as GGC/(a*sqrt(a)), where GGC is the Gaussian Gravitational Constant.
+ *  @param[in] a       The semimajor axis, in Astronomical Units.
+ *  @param[in] e       The orbital eccentricity.
+ *  @param[in] i       The inclination.
+ *  @param[in] w       The argument of perihelion.
+ *  @param[in] L       The longitude of the ascending node.
+ *  @param[in] mdt     The type of magnitude data being provided.
+ *  @param[in] g_or_H  The absolute magnitude (g) if mdt was given as abs_s, or the mean absolute visual magnitude (H) if mdt was given as iau_s.
+ *  @param[in] K_or_G  The magnitude constant (K) if mdt was given as abs_s, or the slope parameter (G) if mdt was given as iau_s.
+ *
+ *  @return A struct containing the compiled orbital elements for this body.
+ *
+ *  @todo Make the Gaussian Gravitational Constant a constant in constants.c.
+ *
+ *  @author Mike McGavin.
+ */
+orbital_elements populate_orbital_elements(const double epoch,
+					   const double M_epoch,
+					   const double jd,
+					   const double n,
+					   const double a,
+					   const double e,
+					   const double i,
+					   const double w,
+					   const double L,
+					   const magdatatype mdt,
+					   const double g_or_H,
+					   const double K_or_G)
 {
-  double x;
-  double y;
-  double z;
-  double v = true_anomoly(emc->e, emc->E);
-  double r = radius_vector(emc->a, emc->e, emc->E);
-  double cosv = cos(v);
-  double sinv = sin(v);
-
-  x = r * ((emc->Px * cosv) + (emc->Qx * sinv));
-  y = r * ((emc->Py * cosv) + (emc->Qy * sinv));
-  z = r * ((emc->Pz * cosv) + (emc->Qz * sinv));
-
-  double s = sol->x + x;
-  double n = sol->y + y;
-  double t = sol->z + z;
-  double r_earth = sqrt(s * s + n * n + t * t);
-  double R = sqrt(sol->x*sol->x + sol->y*sol->y + sol->x*sol->x);
-
-  *elongation = acos((R*R + r_earth*r_earth - r*r) / (2 * R * r_earth));
-  *phase_angle = acos((r*r + r_earth*r_earth - R*R) / (2 * r * r_earth));
+    orbital_elements dest;
+    dest.a = a;
+    dest.e = e;
+    dest.i = i;
+    dest.w = w;
+    dest.L = L;
+    if(n != 0.0) {
+      dest.n = n;
+    } else {
+      dest.n = 0.9856076686 / (a * sqrt(a));
+    }
+    dest.M = M_epoch + (n * (jd - epoch));
+    if (abs_s == mdt) {
+	dest.magdata._abs.g = g_or_H;
+	dest.magdata._abs.K = K_or_G;
+    } else {
+	dest.magdata._iau.H = g_or_H;
+	dest.magdata._iau.G = K_or_G;
+    }
+    return dest;
 }
-*/

Modified: trunk/src/c/libephemeritis/elp2000.c
===================================================================
--- trunk/src/c/libephemeritis/elp2000.c	2005-12-25 02:43:38 UTC (rev 190)
+++ trunk/src/c/libephemeritis/elp2000.c	2006-01-05 08:27:10 UTC (rev 191)
@@ -195,19 +195,24 @@
      */
     const double _kL1[] =
 	{ d_to_r(218.3164477), d_to_r(481267.88123421), d_to_r(-0.0015786),
-d_to_r(1.0 / 538841), d_to_r(-1.0 / 65194000) };
+	d_to_r(1.0 / 538841), d_to_r(-1.0 / 65194000)
+    };
     const double _kD[] =
 	{ d_to_r(297.8501921), d_to_r(445267.1114034), d_to_r(-0.0018819),
-d_to_r(1.0 / 545868), d_to_r(-1.0 / 113065000) };
+	d_to_r(1.0 / 545868), d_to_r(-1.0 / 113065000)
+    };
     const double _kM[] =
 	{ d_to_r(357.5291092), d_to_r(35999.0502909), d_to_r(-0.0001536),
-d_to_r(1.0 / 24490000) };
+	d_to_r(1.0 / 24490000)
+    };
     const double _kM1[] =
 	{ d_to_r(134.9633964), d_to_r(477198.8675055), d_to_r(0.0087414),
-d_to_r(1.0 / 69699), d_to_r(-1.0 / 14712000) };
+	d_to_r(1.0 / 69699), d_to_r(-1.0 / 14712000)
+    };
     const double _kF[] =
 	{ d_to_r(93.2720950), d_to_r(483202.0175233), d_to_r(-0.0036539),
-d_to_r(-1.0 / 3526000), d_to_r(1.0 / 863310000) };
+	d_to_r(-1.0 / 3526000), d_to_r(1.0 / 863310000)
+    };
     const double _kA1[] = { d_to_r(119.75), d_to_r(131.849) };
     const double _kA2[] = { d_to_r(53.09), d_to_r(479264.290) };
     const double _kA3[] = { d_to_r(313.45), d_to_r(481266.484) };

Modified: trunk/src/c/libephemeritis/ephemeritis.h
===================================================================
--- trunk/src/c/libephemeritis/ephemeritis.h	2005-12-25 02:43:38 UTC (rev 190)
+++ trunk/src/c/libephemeritis/ephemeritis.h	2006-01-05 08:27:10 UTC (rev 191)
@@ -172,6 +172,7 @@
 /* dynamical.c */
 double deltaT_seconds(double jd);
 double dt_to_ut(double jd);
+double ut_to_dt(double jd);
 
 /* elp2000.c */
 void elp_dimension3(double jd, double *longitude, double *latitude,
@@ -188,7 +189,8 @@
 /* nutation.c */
 double nut_in_lon(double jd);
 double nut_in_obl(double jd);
-double obliquity(double jd);
+void nut_in_ra_dec(double ra, double dec, double obl, double n_in_l, double n_in_o, double *n_in_ra, double *n_in_dec);
+double obliquity_low(double jd);
 double obliquity_hi(double jd);
 
 /* precession.c */
@@ -204,23 +206,18 @@
     double p_rad;
 } precession_elements_ecl;
 
-precession_elements_eq
-    * precession_get_elements_eq(const double JDinitial,
-				 const double JDfinal,
-				 precession_elements_eq * pceq);
+precession_elements_eq precession_get_elements_eq(const double JDinitial,
+						  const double JDfinal);
 
-void precession_eq(const precession_elements_eq * pceq,
+void precession_eq(const precession_elements_eq pceq,
 		   const double raInitial,
 		   const double decInitial,
 		   double *raFinal, double *decFinal);
 
-precession_elements_ecl *precession_get_elements_ecl(const double
-						     JDinitial,
-						     const double JDfinal,
-						     precession_elements_ecl
-						     * pcecl);
+precession_elements_ecl precession_get_elements_ecl(const double JDinitial,
+						     const double JDfinal);
 
-void precession_ecl(const precession_elements_ecl * pcecl,
+void precession_ecl(const precession_elements_ecl pcecl,
 		    const double longInitial,
 		    const double latInitial,
 		    double *longFinal, double *latFinal);
@@ -251,10 +248,14 @@
 		  double *H, double *decl);
 void equ_to_ecl(double ra, double dec, double obliquity, double *longitude,
 		double *latitude);
-void fday_to_hms(double day, int *hour, int *min, int *sec);
+void fday_to_hms(double day, int *hour, int *min, double *sec);
 double hms_to_fday(int hr, int mn, double sec);
-double fday_to_r(double fday);
+double fday_to_r(const double fday);
+double r_to_fday(const double r);
+void r_to_hms(const double r, int *hr, int *mn, double *sec);
+double hms_to_r(const int hr, const int mn, const double sec);
 double modpi2(double x);
+double circumpi(double x);
 double r_to_d(double r);
 
 /* refraction.c */
@@ -286,6 +287,15 @@
 
 /* elliptical.c */
 
+/*! @brief The type of magnitude-calculation data provided for an orbital element.
+ *
+ *  @sa orbital_elements
+ */
+typedef enum {
+    abs_s,			/*! @brief  Calculation by the absolute magnitude and cometary constant system. */
+    iau_s			/*! @brief  Calculation using the mean absolute visual magnitude and slope parameter system, as adopted by Commission 20 of the IAU (New Delhi, Nov 1985). */
+} magdatatype;
+
 /*! @brief Struct to contain orbital elements.
  */
 typedef struct {
@@ -307,7 +317,7 @@
      *  absolute visual magnitude and slope parameter system, as adopted
      *  by Commission 20 of the IAU (New Delhi, Nov 1985).
      */
-    enum { abs_s, iau_s } magdatatype;
+    magdatatype mdt;
     union {
 	struct {
 	    double g;		/*!< @brief Absolute magnitude. */
@@ -349,20 +359,20 @@
 		      enum vPlanets targetPlanet,
 		      void (*heliocentic_f) (double, enum vPlanets,
 					     double *, double *, double *),
-		      double deltaPsi, double epsilon, double delta,
+		      double n_in_l, double epsilon, double delta,
 		      double *ra, double *dec);
 
-element_constants *get_element_constants(const double obl,
-					 const orbital_elements * elements,
-					 const int iterations,
-					 element_constants * ec);
+element_constants get_element_constants(const double obl,
+					const orbital_elements elements,
+					const int iterations);
+double get_r_sun(const element_constants ec);
 
-rec_coords *elliptical_orbit_rectangular(const element_constants * ec,
-					 rec_coords * rc, double *r_sun);
+rec_coords elliptical_orbit_rectangular(const element_constants ec,
+					const double r_sun);
 
 double mean_anomoly(double jd, double T, double n);
-void elliptical_orbit_ecliptical(const rec_coords * sol,
-				 const rec_coords * body,
+void elliptical_orbit_ecliptical(const rec_coords sol,
+				 const rec_coords body,
 				 const double r_sun,
 				 double *ra,
 				 double *dec,
@@ -375,6 +385,29 @@
 double mag_iau(const double H, const double G, const double r_sun,
 	       const double r_earth, const double B);
 
+orbital_elements populate_orbital_elements(const double epoch,
+					   const double M_epoch,
+					   const double jd,
+					   const double n,
+					   const double a,
+					   const double e,
+					   const double i,
+					   const double w,
+					   const double L,
+					   const magdatatype mdt,
+					   const double g_or_H,
+					   const double K_or_G);
+
+/* aberration.c */
+void aberration_in_lon_lat_low(double jd, double lon, double lat,
+			       double sol_lon, double *delta_lon,
+			       double *delta_lat);
+void aberration_in_ra_dec_low(double jd, double ra, double dec, double obl,
+			      double sol_lon, double *delta_ra,
+			      double *delta_dec);
+
+
+
 /* solar.c */
 double sol_dimension_vsop(double jd, enum Coords dim);
 void sol_dimension3_vsop(double jd, double *longitude, double *latitude,
@@ -384,8 +417,7 @@
 void longitude_radius_low(double jd, double *L, double *R);
 double apparent_longitude_low(double jd, double L);
 double aberration_low(double R);
-rec_coords *sol_rectangular(double L, double B, double R, double E,
-			    rec_coords * rc);
+rec_coords sol_rectangular(double L, double B, double R, double obl);
 
 
 /* constellations.c */

Modified: trunk/src/c/libephemeritis/equationoftime.c
===================================================================
--- trunk/src/c/libephemeritis/equationoftime.c	2005-12-25 02:43:38 UTC (rev 190)
+++ trunk/src/c/libephemeritis/equationoftime.c	2006-01-05 08:27:10 UTC (rev 191)
@@ -44,29 +44,34 @@
  *
  *  @author Mike McGavin
  */
-double equation_of_time(const double jd) {
-  double T = (jd - 2451545.0) / 365250.0;
-  double _terms[] = {280.4664567, 360007.6982779, 0.03032028, 1.0 / 49931.0, 1.0 / 15300.0, 1.0 / 2000000.0};
-  double L0 = modpi2(d_to_r(polynomial(_terms, 6, T)));
+double equation_of_time(const double jd)
+{
+    double T = (jd - 2451545.0) / 365250.0;
+    double _terms[] =
+	{ 280.4664567, 360007.6982779, 0.03032028, 1.0 / 49931.0,
+	1.0 / 15300.0, 1.0 / 2000000.0
+    };
+    double L0 = modpi2(d_to_r(polynomial(_terms, 6, T)));
 
-  /* Solar longitude, latitude and radius. */
-  double longitude;
-  double latitude;
-  double radius;
-  sol_dimension3_vsop(jd, &longitude, &latitude, &radius);
+    /* Solar longitude, latitude and radius. */
+    double longitude;
+    double latitude;
+    double radius;
+    sol_dimension3_vsop(jd, &longitude, &latitude, &radius);
 
-  double aberration = aberration_low(radius);
+    double aberration = aberration_low(radius);
 
-  /* Correct the longitude for nutation and aberration. */
-  longitude = longitude + nut_in_lon(jd) + aberration;
+    /* Correct the longitude for nutation and aberration. */
+    longitude = longitude + nut_in_lon(jd) + aberration;
 
-  /* Solar ra and dec. */
-  double obl = obliquity_hi(jd) + nut_in_obl(jd);
-  double ra;
-  double dec;
-  ecl_to_equ(longitude, latitude, obl, &ra, &dec);
+    /* Solar ra and dec. */
+    double obl = obliquity_hi(jd) + nut_in_obl(jd);
+    double ra;
+    double dec;
+    ecl_to_equ(longitude, latitude, obl, &ra, &dec);
 
-  /* Do the final calculation, and return it. */
-  double E = L0 - d_to_r(0.0057183) - ra + nut_in_lon(jd) * cos(d_to_r(obl));
-  return E;
+    /* Do the final calculation, and return it. */
+    double E =
+	L0 - d_to_r(0.0057183) - ra + nut_in_lon(jd) * cos(d_to_r(obl));
+    return E;
 }

Modified: trunk/src/c/libephemeritis/nutation.c
===================================================================
--- trunk/src/c/libephemeritis/nutation.c	2005-12-25 02:43:38 UTC (rev 190)
+++ trunk/src/c/libephemeritis/nutation.c	2006-01-05 08:27:10 UTC (rev 191)
@@ -171,7 +171,7 @@
     {2, 0, 1, -2, 0, -1, 0, 0, 0},	/* 103 */
     {2, 0, 2, 0, 0, 1, 0, 0, 0},	/* 104 */
     {4, 0, 0, 2, 2, -1, 0, 0, 0},	/* 105 */
-    {1, 1, 0, 0, 0, 1, 0, 0, 0}	        /* 106 */
+    {1, 1, 0, 0, 0, 1, 0, 0, 0}	/* 106 */
 };
 
 void _constants(double T, double *D, double *M, double *M1, double *F,
@@ -183,23 +183,43 @@
      * Constant terms.
      */
 
-    /* These should really be static, but it was lost during the port to C.  Should be fixed later. */
-    const double _kD[] =
-	{ d_to_r(297.85036), d_to_r(445267.111480), d_to_r(-0.0019142),
-d_to_r(1.0 / 189474) };
-    const double _kM[] =
-	{ d_to_r(357.52772), d_to_r(35999.050340), d_to_r(-0.0001603),
-d_to_r(-1.0 / 300000) };
-    const double _kM1[] =
-	{ d_to_r(134.96298), d_to_r(477198.867398), d_to_r(0.0086972),
-d_to_r(1.0 / 56250) };
-    const double _kF[] =
-	{ d_to_r(93.27191), d_to_r(483202.017538), d_to_r(-0.0036825),
-d_to_r(1.0 / 327270) };
-    const double _ko[] =
-	{ d_to_r(125.04452), d_to_r(-1934.136261), d_to_r(0.0020708),
-d_to_r(1.0 / 450000) };
+    /* Initialise the arrays if this is the first time the function's been called. */
+    static bool initialised = false;
+    static double _kD[4];
+    static double _kM[4];
+    static double _kM1[4];
+    static double _kF[4];
+    static double _ko[4];
 
+    if (!initialised) {
+	initialised = true;
+
+	_kD[0] = d_to_r(297.85036);
+	_kD[1] = d_to_r(445267.111480);
+	_kD[2] = d_to_r(-0.0019142);
+	_kD[3] = d_to_r(1.0 / 189474);
+
+	_kM[0] = d_to_r(357.52772);
+	_kM[1] = d_to_r(35999.050340);
+	_kM[2] = d_to_r(-0.0001603);
+	_kM[3] = d_to_r(-1.0 / 300000);
+
+	_kM1[0] = d_to_r(134.96298);
+	_kM1[1] = d_to_r(477198.867398);
+	_kM1[2] = d_to_r(0.0086972);
+	_kM1[3] = d_to_r(1.0 / 56250);
+
+	_kF[0] = d_to_r(93.27191);
+	_kF[1] = d_to_r(483202.017538);
+	_kF[2] = d_to_r(-0.0036825);
+	_kF[3] = d_to_r(1.0 / 327270);
+
+	_ko[0] = d_to_r(125.04452);
+	_ko[1] = d_to_r(-1934.136261);
+	_ko[2] = d_to_r(0.0020708);
+	_ko[3] = d_to_r(1.0 / 450000);
+    }
+
     *D = modpi2(polynomial(_kD, 4, T));
     *M = modpi2(polynomial(_kM, 4, T));
     *M1 = modpi2(polynomial(_kM1, 4, T));
@@ -279,6 +299,38 @@
     return deltaEps;
 }
 
+/*! @brief Calculates first order adjustments for nutation in RA and
+ *  Dec, given the corresponding nutation in Longitude and Obliquity.
+ *
+ *  [Meeus 1998: equation 23.1]
+ *
+ *  @param[in]  ra       The starting right ascension, in radians.
+ *  @param[in]  dec      The starting declination, in radians.
+ *  @param[in]  obl      The obliquity of the ecliptic, in radians.
+ *  @param[in]  n_in_l   The nutation in longitude, in radians.
+ *  @param[in]  n_in_o   The nutation in obliquity, in radians.
+ *  @param[out] n_in_ra  The nutation in right ascension, in radians.
+ *  @param[out] n_in_dec The nutation in declination, in radians.
+ *
+ *  @warning This function isn't very reliable if the coordinates are
+ *  near the celestial poles.  If this is the case, it's best to work
+ *  in ecliptical coordinates, and then convert back to equatorial
+ *  coordinates afterwards.
+ *
+ *  @todo Figure out if the obliquity is supposed to be true
+ *  obliquity, or mean obliquity.  Meeus' book isn't clear, but the
+ *  presence of nutation in obliquity given separately suggests that
+ *  it's only mean obliquity.
+ *
+ *  @author Mike McGavin.
+ */
+void nut_in_ra_dec(double ra, double dec, double obl, double n_in_l, double n_in_o, double *n_in_ra, double *n_in_dec)
+{
+  *n_in_ra = (cos(obl) + (sin(obl) * sin(ra) * tan(dec))) * n_in_l - (cos(ra) * tan(dec) * n_in_o);
+  *n_in_dec = (sin(obl) * cos(ra) * n_in_l) + (sin(ra) * n_in_o);
+}
+
+
 /*! @brief Returns the mean obliquity of the ecliptic.
  *
  *  Low precision, but good enough for most uses. [Meeus-1998:
@@ -291,24 +343,24 @@
  *
  *  @sa dynamical::deltaT_seconds for calculating %dynamical time offset.
  *
- *  @todo Fix values that should be static, but haven't been since the C port.
  *  @todo Consider removing this function in favour of the hi accuracy one below.
  */
-double obliquity(double jd)
+double obliquity_low(double jd)
 {
     /*
      * Constant terms:
      */
 
-    /* The following should be static, but that was removed from the C
-       port (hopefully temporary) because it can't be done at compile
-       time. */
-    const double _el0[] = {
-	d_to_r(dms_to_d(23, 26, 21.448)),
-	d_to_r(dms_to_d(0, 0, -46.8150)),
-	d_to_r(dms_to_d(0, 0, -0.00059)),
-	d_to_r(dms_to_d(0, 0, 0.001813))
-    };
+    /* Initialise the array on the first call. */
+    static double _el0[4];
+    static bool initialised = false;
+    if (!initialised) {
+	initialised = true;
+	_el0[0] = d_to_r(dms_to_d(23, 26, 21.448));
+	_el0[1] = d_to_r(dms_to_d(0, 0, -46.8150));
+	_el0[2] = d_to_r(dms_to_d(0, 0, -0.00059));
+	_el0[3] = d_to_r(dms_to_d(0, 0, 0.001813));
+    }
 
     const double T = jd_to_jcent(jd);
     return polynomial(_el0, sizeof(_el0) / sizeof(*_el0), T);
@@ -324,9 +376,7 @@
  *
  *  @return        Obliquity, in radians.
  *
- *  @sa dynamical::deltaT_seconds for calculating %dynamical time offset.
- *
- *  @todo Fix values that should be static, but haven't been since the C port.
+ *  @sa deltaT_seconds for calculating %dynamical time offset.
  */
 double obliquity_hi(double jd)
 {
@@ -334,24 +384,24 @@
      * Constant terms:
      */
 
-    /* The following should be static, but that was removed from the C
-       port (hopefully temporary) because it can't be done at compile
-       time.
-     */
-    const double _el1[] = {
-	d_to_r(dms_to_d(23, 26, 21.448)),
-	d_to_r(dms_to_d(0, 0, -4680.93)),
-	d_to_r(dms_to_d(0, 0, -1.55)),
-	d_to_r(dms_to_d(0, 0, 1999.25)),
-	d_to_r(dms_to_d(0, 0, -51.38)),
-	d_to_r(dms_to_d(0, 0, -249.67)),
-	d_to_r(dms_to_d(0, 0, -39.05)),
-	d_to_r(dms_to_d(0, 0, 7.12)),
-	d_to_r(dms_to_d(0, 0, 27.87)),
-	d_to_r(dms_to_d(0, 0, 5.79)),
-	d_to_r(dms_to_d(0, 0, 2.45))
-    };
+    /* Initialise the array on the first call. */
+    static double _el1[11];
+    static bool initialised = false;
+    if (!initialised) {
+	_el1[0] = d_to_r(dms_to_d(23, 26, 21.448));
+	_el1[1] = d_to_r(dms_to_d(0, 0, -4680.93));
+	_el1[2] = d_to_r(dms_to_d(0, 0, -1.55));
+	_el1[3] = d_to_r(dms_to_d(0, 0, 1999.25));
+	_el1[4] = d_to_r(dms_to_d(0, 0, -51.38));
+	_el1[5] = d_to_r(dms_to_d(0, 0, -249.67));
+	_el1[6] = d_to_r(dms_to_d(0, 0, -39.05));
+	_el1[7] = d_to_r(dms_to_d(0, 0, 7.12));
+	_el1[8] = d_to_r(dms_to_d(0, 0, 27.87));
+	_el1[9] = d_to_r(dms_to_d(0, 0, 5.79));
+	_el1[10] = d_to_r(dms_to_d(0, 0, 2.45));
+    }
 
+
     const double U = jd_to_jcent(jd) / 100;
     return polynomial(_el1, sizeof(_el1) / sizeof(*_el1), U);
 }

Modified: trunk/src/c/libephemeritis/precession.c
===================================================================
--- trunk/src/c/libephemeritis/precession.c	2005-12-25 02:43:38 UTC (rev 190)
+++ trunk/src/c/libephemeritis/precession.c	2006-01-05 08:27:10 UTC (rev 191)
@@ -56,20 +56,16 @@
  *
  *  @param[in]  JDinitial  The initial Julian Day, in dynamical time.
  *  @param[in]  JDfinal    The final Julian Day, in dynamical time.
- *  @param[out] pceq       A struct to hold the calculated elements, to
- *                         be passed to the precession routine.
  *
- *  @return A pointer to the precession elements that was passed
- *  (returned for convenience purposes).
+ *  @return A struct to hold the calculated elements, to be passed to
+ *  the precession routine.
  *
  *  @see precession_eq, precession_elements_ecl
  *
  *  @author Mike McGavin.
  */
-precession_elements_eq *precession_get_elements_eq(const double JDinitial,
-						   const double JDfinal,
-						   precession_elements_eq *
-						   pceq)
+precession_elements_eq precession_get_elements_eq(const double JDinitial,
+						  const double JDfinal)
 {
 
     double T = (JDinitial - 2451545.0) / 36525.0;
@@ -80,25 +76,29 @@
     double data2[] = { 0.30188, -0.000344 };
     double data3[] =
 	{ 0.0, polynomial(data1, 3, T), polynomial(data2, 2, T),
-0.017998 };
+	0.017998
+    };
     double zeta = polynomial(data3, 4, t);
 
     double data4[] = { 1.09468, 0.000066 };
     double data5[] =
 	{ 0.0, polynomial(data1, 3, T), polynomial(data4, 2, T),
-0.018203 };
+	0.018203
+    };
     double z = polynomial(data5, 4, t);
 
     double data6[] = { 2004.3109, -0.85330, -0.000217 };
     double data7[] = { 0.42665, 0.000217 };
     double data8[] =
 	{ 0.0, polynomial(data6, 3, T), -1 * polynomial(data7, 2, T),
-0.041833 };
+	0.041833
+    };
     double theta = polynomial(data8, 4, t);
 
-    pceq->zeta_rad = modpi2((zeta * 2 * pi) / (3600.0 * 360.0));
-    pceq->z_rad = modpi2((z * 2 * pi) / (3600.0 * 360.0));
-    pceq->theta_rad = modpi2((theta * 2 * pi) / (3600.0 * 360.0));
+    precession_elements_eq pceq;
+    pceq.zeta_rad = modpi2((zeta * 2 * pi) / (3600.0 * 360.0));
+    pceq.z_rad = modpi2((z * 2 * pi) / (3600.0 * 360.0));
+    pceq.theta_rad = modpi2((theta * 2 * pi) / (3600.0 * 360.0));
     return pceq;
 }
 
@@ -123,23 +123,23 @@
  *
  *  @author Mike McGavin.
  */
-void precession_eq(const precession_elements_eq * pceq,
+void precession_eq(const precession_elements_eq pceq,
 		   const double raInitial,
 		   const double decInitial,
 		   double *raFinal, double *decFinal)
 {
-    double A = cos(decInitial) * sin(raInitial + pceq->zeta_rad);
+    double A = cos(decInitial) * sin(raInitial + pceq.zeta_rad);
     double B =
-	cos(pceq->theta_rad) * cos(decInitial) * cos(raInitial +
-						     pceq->zeta_rad) -
-	sin(pceq->theta_rad) * sin(decInitial);
+	cos(pceq.theta_rad) * cos(decInitial) * cos(raInitial +
+						    pceq.zeta_rad) -
+	sin(pceq.theta_rad) * sin(decInitial);
     double C =
-	sin(pceq->theta_rad) * cos(decInitial) * cos(raInitial +
-						     pceq->zeta_rad) +
-	cos(pceq->theta_rad) * sin(decInitial);
+	sin(pceq.theta_rad) * cos(decInitial) * cos(raInitial +
+						     pceq.zeta_rad) +
+	cos(pceq.theta_rad) * sin(decInitial);
 
-    *raFinal = modpi2(atan2(A, B) + pceq->z_rad);
-    *decFinal = modpi2(asin(C));
+    *raFinal = modpi2(atan2(A, B) + pceq.z_rad);
+    *decFinal = circumpi(asin(C));
 }
 
 /*! @brief Calculates certain values related to the precession
@@ -159,21 +159,17 @@
  *
  *  @param[in]  JDinitial  The initial Julian Day, in dynamical time.
  *  @param[in]  JDfinal    The final Julian Day, in dynamical time.
- *  @param[out] pcecl      A struct to hold the calculated elements, to
- *                         be passed to the precession routine.
  *
- *  @return A pointer to the precession elements that was passed
- *  (returned for convenience purposes).
+ *  @return A struct to hold the calculated elements, to be passed to
+ *  the precession routine.
  *
  *  @see precession_ecl, precession_elements_eq
  *
  *  @author Mike McGavin.
  */
-precession_elements_ecl *precession_get_elements_ecl(const double
-						     JDinitial,
-						     const double JDfinal,
-						     precession_elements_ecl
-						     * pcecl)
+precession_elements_ecl precession_get_elements_ecl(const double
+						    JDinitial,
+						    const double JDfinal)
 {
 
     double T = (JDinitial - 2451545.0) / 36525.0;
@@ -184,7 +180,8 @@
     double data2[] = { -0.03302, 0.000598 };
     double data3[] =
 	{ 0.0, polynomial(data1, 3, T), polynomial(data2, 2, T),
-0.000060 };
+	0.000060
+    };
     double n = polynomial(data3, 4, t);
 
     double data4[] = { 174.876384 * 60.0 * 60.0, 3289.4789, 0.60622 };
@@ -197,12 +194,14 @@
     double data8[] = { 1.11113, 0.000042 };
     double data9[] =
 	{ 0.0, polynomial(data7, 3, T), polynomial(data8, 2, T),
--0.000006 };
+	-0.000006
+    };
     double p = polynomial(data9, 4, t);
 
-    pcecl->n_rad = modpi2((n * 2 * pi) / (3600.0 * 360.0));
-    pcecl->II_rad = modpi2((II * 2 * pi) / (3600.0 * 360.0));
-    pcecl->p_rad = modpi2((p * 2 * pi) / (3600.0 * 360.0));
+    precession_elements_ecl pcecl;
+    pcecl.n_rad = modpi2((n * 2 * pi) / (3600.0 * 360.0));
+    pcecl.II_rad = modpi2((II * 2 * pi) / (3600.0 * 360.0));
+    pcecl.p_rad = modpi2((p * 2 * pi) / (3600.0 * 360.0));
     return pcecl;
 }
 
@@ -216,7 +215,7 @@
  *  This routine uses Meuus' Rigorous method of calculating
  *  precession.  [Meeus-1998: equations 21.2 to 21.4]
  *
- *  @param[in]  pcecl       The elements related to the time of the precession, calculated by precession_get_elements_ecl.
+ *  @param[in]  pcecl        The elements related to the time of the precession, calculated by precession_get_elements_ecl.
  *  @param[in]  longInitial  The initial celestial longitude, in radians.
  *  @param[in]  latInitial   The initial celestial latitude, in radians.
  *  @param[out] longFinal    The final right ascension, in radians.
@@ -228,29 +227,29 @@
  *
  *  @author Mike McGavin.
  */
-void precession_ecl(const precession_elements_ecl * pcecl,
+void precession_ecl(const precession_elements_ecl pcecl,
 		    const double longInitial,
 		    const double latInitial,
 		    double *longFinal, double *latFinal)
 {
 
     double A =
-	(cos(pcecl->n_rad) * cos(latInitial) *
-	 sin(pcecl->II_rad - longInitial)) -
-	(sin(pcecl->n_rad) * sin(latInitial));
-    double B = cos(latInitial) * cos(pcecl->II_rad - longInitial);
+	(cos(pcecl.n_rad) * cos(latInitial) *
+	 sin(pcecl.II_rad - longInitial)) -
+	(sin(pcecl.n_rad) * sin(latInitial));
+    double B = cos(latInitial) * cos(pcecl.II_rad - longInitial);
     double C =
-	((cos(pcecl->n_rad) * sin(latInitial))) +
-	(sin(pcecl->n_rad) * cos(latInitial) *
-	 sin(pcecl->II_rad - longInitial));
+	((cos(pcecl.n_rad) * sin(latInitial))) +
+	(sin(pcecl.n_rad) * cos(latInitial) *
+	 sin(pcecl.II_rad - longInitial));
 
-    *longFinal = modpi2(-1 * (atan2(A, B) - pcecl->p_rad - pcecl->II_rad));
-    *latFinal = modpi2(asin(C));
+    *longFinal = modpi2(-1 * (atan2(A, B) - pcecl.p_rad - pcecl.II_rad));
+    *latFinal = circumpi(asin(C));
 }
 
 /*! @brief Calculates proper motion in ecliptical coordinates, given
  *  proper motion in equatorial coordinates.
- * 
+ *
  *  Based on Meeus' formula, 1998, p138.
  *
  *  @param[in]  ra         Right ascension of the star, in radians.

Modified: trunk/src/c/libephemeritis/solar.c
===================================================================
--- trunk/src/c/libephemeritis/solar.c	2005-12-25 02:43:38 UTC (rev 190)
+++ trunk/src/c/libephemeritis/solar.c	2006-01-05 08:27:10 UTC (rev 191)
@@ -105,10 +105,10 @@
  */
 void sol_dimension3_fk5(double jd, double *L, double *B, double *R)
 {
-  sol_dimension3_vsop(jd, L, B, R);
+    sol_dimension3_vsop(jd, L, B, R);
 
-  /* Transform to FK5 ecliptic and equinox. */
-  vsop_to_fk5(jd, L, B);
+    /* Transform to FK5 ecliptic and equinox. */
+    vsop_to_fk5(jd, L, B);
 }
 
 
@@ -205,30 +205,29 @@
  *  ecliptic, at the time in question.  These can be calculated using
  *  sol_dimension3_fk5 and obliquity_hi.
  *
- *  @param[in]  L  Geometric longitude of the Sun, in radians/fk5.
- *  @param[in]  B  Geometric latitude of the Sun, in radians/fk5.
- *  @param[in]  R  Geometric radius of the Sun, in radians/fk5.
- *  @param[in]  E  The mean obliquity of the ecliptic.
- *  @param[out] rc  The x, y and z coordinates, in astronomical units.
+ *  @param[in]  L    Geometric longitude of the Sun, in radians/fk5.
+ *  @param[in]  B    Geometric latitude of the Sun, in radians/fk5.
+ *  @param[in]  R    Geometric radius of the Sun, in radians/fk5.
+ *  @param[in]  obl  The mean obliquity of the ecliptic.
  *
- *  @return A pointer to the rc structure that was passed. (This
- *  return value is for convenience only.)
+ *  @return The x, y and z coordinates, in astronomical units.
  *
  *  @sa sol_dimension3_fk5
- *  @sa obliquity
+ *  @sa obliquity_low
  *  @sa obliquity_hi
  *
  *  @author Mike McGavin.
  */
-rec_coords *sol_rectangular(double L, double B, double R, double E, rec_coords *rc)
+rec_coords sol_rectangular(double L, double B, double R, double obl)
 {
     double cosB = cos(B);
     double sinL = sin(L);
     double sinB = sin(B);
-    double sinE = sin(E);
-    double cosE = cos(E);
-    rc->x = R * (cosB * cos(L));
-    rc->y = R * ((cosB * sinL * cosE) - (sinB * sinE));
-    rc->z = R * ((cosB * sinL * sinE) + (sinB * cosE));
+    double sinobl = sin(obl);
+    double cosobl = cos(obl);
+    rec_coords rc;
+    rc.x = R * (cosB * cos(L));
+    rc.y = R * ((cosB * sinL * cosobl) - (sinB * sinobl));
+    rc.z = R * ((cosB * sinL * sinobl) + (sinB * cosobl));
     return rc;
 }

Modified: trunk/src/c/libephemeritis/vsop87d.c
===================================================================
--- trunk/src/c/libephemeritis/vsop87d.c	2005-12-25 02:43:38 UTC (rev 190)
+++ trunk/src/c/libephemeritis/vsop87d.c	2006-01-05 08:27:10 UTC (rev 191)
@@ -60,7 +60,8 @@
  *  processing time.  According to Meeus, much fewer than available
  *  elements are actually required unless great accuracy is wanted.
  */
-double vsop_dimension_vsop(double jd, enum vPlanets planet, enum Coords dim)
+double vsop_dimension_vsop(double jd, enum vPlanets planet,
+			   enum Coords dim)
 {
     /* The idea here is to sum the results of A*cos(B+(C*tau)) for
      * each series, combine the result for each series together in
@@ -124,7 +125,8 @@
  */
 void vsop_dimension3_vsop(double jd,
 			  enum vPlanets planet,
-			  double *longitude, double *latitude, double *radius)
+			  double *longitude, double *latitude,
+			  double *radius)
 {
     *longitude = vsop_dimension_vsop(jd, planet, vL);
     *latitude = vsop_dimension_vsop(jd, planet, vB);
@@ -155,12 +157,13 @@
  */
 void vsop_dimension3_fk5(double jd,
 			 enum vPlanets planet,
-			 double *longitude, double *latitude, double *radius)
+			 double *longitude, double *latitude,
+			 double *radius)
 {
-  vsop_dimension3_vsop(jd, planet, longitude, latitude, radius);
+    vsop_dimension3_vsop(jd, planet, longitude, latitude, radius);
 
-  /* Transform to FK5 ecliptic and equinox. */
-  vsop_to_fk5(jd, longitude, latitude);
+    /* Transform to FK5 ecliptic and equinox. */
+    vsop_to_fk5(jd, longitude, latitude);
 }
 
 

Modified: trunk/src/c/tests/validate_meeus.c
===================================================================
--- trunk/src/c/tests/validate_meeus.c	2005-12-25 02:43:38 UTC (rev 190)
+++ trunk/src/c/tests/validate_meeus.c	2006-01-05 08:27:10 UTC (rev 191)
@@ -27,9 +27,9 @@
  *  <em>Astronomical Algorithms</em> by Jean Meeus, second edition
  *  1998, Willmann-Bell Inc.
  *
- *  Where testing shows no differences between Meeus and the Astrolabe
- *  results (to the precision printed in Meeus), I have used the
- *  report() routine to verify the results.
+ *  Where testing shows no differences between Meeus and the
+ *  Ephemeritis results (to the precision printed in Meeus), I have
+ *  used the report() routine to verify the results.
  *
  *  In some cases I do show small differences and display these with
  *  the report_diff() routine. The differences do not seem to be of
@@ -68,9 +68,9 @@
     if (diff > delta) {
 	printf("%s%s\n", tab, label);
 	printf("%s%sERROR:\n", tab, tab);
-	printf("%s%s%scomputed   = %f\n", tab, tab, tab, computed);
-	printf("%s%s%sreference  = %f\n", tab, tab, tab, reference);
-	printf("%s%s%sdifference = %f %s\n", tab, tab, tab, diff, units);
+	printf("%s%s%scomputed   = %.10f\n", tab, tab, tab, computed);
+	printf("%s%s%sreference  = %.10f\n", tab, tab, tab, reference);
+	printf("%s%s%sdifference = %.10f %s\n", tab, tab, tab, diff, units);
     } else {
     }
 }
@@ -81,10 +81,6 @@
     printf("%s%s\n", tab, label);
     printf("%s%sDifference: %f %s\n", tab, tab, computed - reference,
 	   units);
-    /*
-       cout << tab << label << endl;
-       cout << tab << tab <<  "Difference: " << setprecision(2) << computed - reference << " " << units << endl;
-     */
 }
 
 /*
@@ -556,9 +552,7 @@
 		   dms_to_d(0.0, 0.0, 0.0895) * 28.86705);
 	double a1;
 	double d1;
-	precession_elements_eq pceq;
-	precession_eq(precession_get_elements_eq
-		      (2451545.0, 2462088.69, &pceq), a0, d0, &a1, &d1);
+	precession_eq(precession_get_elements_eq(2451545.0, 2462088.69), a0, d0, &a1, &d1);
 
 	report("RA", a1, fday_to_r(hms_to_fday(2, 46, 11.331)), 0.00001,
 	       "radians");
@@ -571,10 +565,7 @@
 	double lat = d_to_r(1.76549);
 	double lon1;
 	double lat1;
-	precession_elements_ecl pcecl;
-	precession_ecl(precession_get_elements_ecl
-		       (je_to_jd(2000.0), 1643074.5, &pcecl), lon, lat,
-		       &lon1, &lat1);
+	precession_ecl(precession_get_elements_ecl(je_to_jd(2000.0), 1643074.5), lon, lat, &lon1, &lat1);
 	report("Longitude", lon1, d_to_r(118.704), 0.00001, "radians");
 	report("Latitude", lat1, d_to_r(1.615), 0.0001, "radians");
     }
@@ -602,7 +593,7 @@
     }
     printf("22.a Nutation (epsilon)\n");
     {
-	const double eps = obliquity(2446895.5);
+	const double eps = obliquity_low(2446895.5);
 	int d, m;
 	double s;
 	d_to_dms(r_to_d(eps), &d, &m, &s);
@@ -621,6 +612,64 @@
 	report("seconds", s, 27.407, 0.001, "seconds");
     }
 
+    printf("23.a Apparent place of a star\n");
+    {
+      double jd = ut_to_dt(cal_to_jd(2028, 11, 13.19, true));
+      double ra = hms_to_r(2,46,11.331);
+      double dec = d_to_r(dms_to_d(49,20,54.54));
+
+      double n_in_l = nut_in_lon(jd);
+      /*
+	d_to_r(dms_to_d(0,0,14.861));
+      */
+
+      double n_in_o = nut_in_obl(jd);
+      /*
+	d_to_r(dms_to_d(0,0,2.705));
+      */
+
+      double obl = obliquity_hi(jd);
+      /*
+	d_to_r(23.436);
+      */
+
+      double sol_lon, sol_rad;
+      longitude_radius_low(jd, &sol_lon, &sol_rad);
+      /*
+      sol_lon = d_to_r(231.328);
+      */
+
+      double n_in_ra, n_in_dec;
+      nut_in_ra_dec(ra, dec, obl, n_in_l, n_in_o, &n_in_ra, &n_in_dec);
+
+      double a_in_ra, a_in_dec;
+      aberration_in_ra_dec_low(jd, ra, dec, obl, sol_lon, &a_in_ra, &a_in_dec);
+
+      /*
+      int d1, m1, d2, m2;
+      double s1, s2;
+      d_to_dms(r_to_d(n_in_ra), &d1, &m1, &s1);
+      d_to_dms(r_to_d(n_in_dec), &d2, &m2, &s2);
+      printf("%d:%d:%.10f$$$%d:%d:%.10f\n", d1,m1,s1,d2,m2,s2);
+      */
+
+      report("nutation in longitude", n_in_l, d_to_r(dms_to_d(0,0,14.861)), 0.000001, "radians");
+      report("nutation in obliquity", n_in_o, d_to_r(dms_to_d(0,0,2.705)), 0.000001, "radians");
+      report("obliquity", obl, d_to_r(23.436), 0.0001, "radians");
+      report("sun's true longitude", sol_lon, d_to_r(231.328), 0.0001, "radians");
+      report("nutation in ra", n_in_ra, d_to_r(dms_to_d(0,0,15.843)), 0.000001, "radians");
+      report("nutation in dec", n_in_dec, d_to_r(dms_to_d(0,0,6.218)), 0.000001, "radians");
+      report("aberration in ra", a_in_ra, d_to_r(dms_to_d(0,0,30.045)), 0.000001, "radians");
+      report("aberration in dec", a_in_dec, d_to_r(dms_to_d(0,0,6.697)), 0.000001, "radians");
+
+      double new_ra = ra + n_in_ra + a_in_ra;
+      double new_dec = dec + n_in_dec + a_in_dec;
+
+      report("ra", new_ra, hms_to_r(2, 46, 14.390), 0.000001, "radians");
+      report("dec", new_dec, d_to_r(dms_to_d(49, 21, 07.45)), 0.000001, "radians");
+
+    }
+
     printf("25.a Sun position, low precision\n");
     {
 	double L, R;
@@ -671,8 +720,7 @@
 	B = d_to_r(dms_to_d(0, 0, 0.62));
 	R = 0.99760775;
 	double E = obliquity_hi(jd);
-	rec_coords rc;
-	sol_rectangular(L, B, R, E, &rc);
+	rec_coords rc = sol_rectangular(L, B, R, E);
 	report("X", rc.x, -0.9379952, 0.0000001, "AU");
 	report("Y", rc.y, -0.3116544, 0.0000001, "AU");
 	report("Z", rc.z, -0.1351215, 0.0000001, "AU");
@@ -821,16 +869,50 @@
 	el.n = 0.01720209895 / (el.a * sqrt(el.a));
 	el.M = mean_anomoly(jd, T, el.n);
 
-	rec_coords rc;
 	double r_sun;
-	element_constants ec;
-	elliptical_orbit_rectangular(get_element_constants
-				     (obliquity_hi(je_to_jd(2000.0)), &el,
-				      53, &ec), &rc, &r_sun);
+	double obl2000 = obliquity_hi(je_to_jd(2000.0));
+	element_constants ec = get_element_constants(obl2000, el, 53);
+	r_sun = get_r_sun(ec);
+	rec_coords rc = elliptical_orbit_rectangular(ec, r_sun);
 
 	report("x", rc.x, 0.2508066, 0.0000001, "AU");
 	report("y", rc.y, 0.4849175, 0.0000001, "AU");
 	report("z", rc.z, 0.3573373, 0.0000001, "AU");
+
+	double L, B, R;
+	sol_dimension3_fk5(jd, &L, &B, &R);
+	rec_coords src = sol_rectangular(L, B, R, obl2000);
+	report("solar x", src.x, -0.9756732, 0.0000001, "AU");
+	report("solar y", src.y, -0.2003254, 0.0000001, "AU");
+	report("solar z", src.z, -0.0868566, 0.0000001, "AU");
+
+	printf("Resetting sol values to those in example (because VSOP isn't calculating them properly as above)");
+	src.x = -0.9756732;
+	src.y = -0.2003254;
+	src.z = -0.0868566;
+
+	double ra, dec, elongation, phase_angle, body_r_earth;
+	elliptical_orbit_ecliptical(src, rc, r_sun, &ra, &dec, &elongation, &phase_angle, &body_r_earth);
+
+	report("delta-earth", body_r_earth, 0.8243689, 0.0000001, "AU");
+
+	double tau = 0.0057755183 * body_r_earth;
+	jd = jd - tau;
+	el.M = mean_anomoly(jd, T, el.n);
+	ec = get_element_constants(obl2000, el, 53);
+	r_sun = get_r_sun(ec);
+	rc = elliptical_orbit_rectangular(ec, r_sun);
+
+	report("recalc-x", rc.x, 0.2509310, 0.0000001, "AU");
+	report("recalc-y", rc.y, 0.4849477, 0.0000001, "AU");
+	report("recalc-z", rc.z, 0.3573712, 0.0000001, "AU");
+
+	elliptical_orbit_ecliptical(src, rc, r_sun, &ra, &dec, &elongation, &phase_angle, &body_r_earth);
+
+	report("recalc-delta-earth", body_r_earth, 0.8242811, 0.0000001, "AU");
+	report("ra", ra, d_to_r(158.558965), 0.0000001, "radians");
+	report("dec", dec, d_to_r(19.158496), 0.0000001, "radians");
+	report("elongation", elongation, d_to_r(40.51), 0.0000001, "radians");
     }
 
     printf("47.a Moon position\n");
@@ -855,61 +937,174 @@
 
 
 
+    printf("33.x Elliptical orbit calculation (from IBAT figures)\n");
+    {
+	typedef struct {
+	    char *name;
+	    double epoch;
+	    double M;
+	    double a;
+	    double e;
+	    double i;
+	    double w;
+	    double L;
+	    double H;
+	    double G;
+	    double n;
+	} orbit_s;
 
+	typedef struct {
+	    orbit_s *orbit;
+	    double jd;
+	    double ra;
+	    double dec;
+	    double r_earth;
+	    double r_sun;
+	    double mag;
+	} jd_test_values;
 
-    printf("Additional tests - NOT DONE YET\n");
-    {
-	/* Ceres data. */
-	double jd = cal_to_jd(2005, 5, 1, true);
-	double ep = cal_to_jd(2005, 1, 30, true);
-	orbital_elements cd;
-	cd.a = 2.7673017;
-	cd.e = 0.0800887;
-	cd.i = d_to_r(10.58276);
-	cd.w = d_to_r(73.72889);
-	cd.L = d_to_r(80.42334);
-	cd.magdatatype = iau_s;
-	cd.magdata._iau.H = 3.34;
-	cd.magdata._iau.G = 0.12;
 
-	double n = d_to_r(0.21410131);
-	cd.M = d_to_r(43.77971) + n * (jd - ep);
+	orbit_s orbits[] = {
+	    {
+	     "Ceres",
+	     cal_to_jd(2005, 1, 30, true), d_to_r(43.77971), 2.7673017,
+	     0.0800887, d_to_r(10.58276), d_to_r(73.72889),
+	     d_to_r(80.42334), 3.34, 0.12, d_to_r(0.21410131)
+	     },
 
-	rec_coords ceres_rec;
-	double ceres_r_sun;
-	element_constants ec;
-	elliptical_orbit_rectangular(get_element_constants
-				     (obliquity_hi(je_to_jd(2000)), &cd,
-				      53, &ec), &ceres_rec, &ceres_r_sun);
+	    {
+	     "Pallas",
+	     cal_to_jd(2005, 1, 30, true), d_to_r(28.70170), 2.7732372,
+	     0.2302220, d_to_r(34.85083), d_to_r(310.54489),
+	     d_to_r(173.16604), 4.13, 0.11, d_to_r(0.21341432)
+	     },
 
-	rec_coords sun_rec;
-	double L, B, R;
-	sol_dimension3_fk5(jd, &L, &B, &R);
-	sol_rectangular(L, B, R, obliquity_hi(je_to_jd(2000)), &sun_rec);
+	    {
+	     "Juno",
+	     cal_to_jd(2005, 1, 30, true), d_to_r(300.24990), 2.6681509,
+	     0.2584015, d_to_r(12.97175), d_to_r(247.86205),
+	     d_to_r(170.12682), 5.33, 0.32, d_to_r(0.22614578)
+	     }
+	};
 
-	double ra;
-	double dec;
-	double elongation;
-	double phase_angle;
-	double r_earth;
-	elliptical_orbit_ecliptical(&sun_rec, &ceres_rec, ceres_r_sun, &ra,
-				    &dec, &elongation, &phase_angle,
-				    &r_earth);
+	jd_test_values tests[] = {
+	    {&orbits[0], ut_to_dt(cal_to_jd(2005, 5, 1, true)),
+	     hms_to_r(15, 20, 0.07 * 60.0),
+	     d_to_r(dms_to_d(-8.0, 33, 0.9 * 60.0)), 1.692, 2.683, 7.1},
+	    {&orbits[0], ut_to_dt(cal_to_jd(2005, 6, 10, true)),
+	     hms_to_r(14, 47, 0.78 * 60.0),
+	     d_to_r(dms_to_d(-9.0, 8, 0.4 * 60.0)), 1.837, 2.715, 7.6},
 
-	double mag =
-	    mag_iau(cd.magdata._iau.H, cd.magdata._iau.G, ceres_r_sun,
-		    r_earth, phase_angle);
+	    {&orbits[1], ut_to_dt(cal_to_jd(2005, 2, 5, true)),
+	     hms_to_r(12, 42, 0.98 * 60.0),
+	     d_to_r(dms_to_d(-6.0, 39, 0.1 * 60.0)), 1.570, 2.271, 8.0},
+	    {&orbits[1], ut_to_dt(cal_to_jd(2005, 5, 1, true)),
+	     hms_to_r(12, 07, 0.76 * 60.0),
+	     d_to_r(dms_to_d(19.0, 20, 0.4 * 60.0)), 1.672, 2.449, 8.2},
 
-	printf("Ceres -- RA=%f, Dec=%f, Distance=%fAU, Mag=%f\n",
-	       r_to_d(modpi2(ra)), r_to_d(modpi2(dec)), r_earth, mag);
+	    {&orbits[2], ut_to_dt(cal_to_jd(2005, 9, 8, true)),
+	     hms_to_r(4, 44, 0.23 * 60.0),
+	     d_to_r(dms_to_d(10.0, 2, 0.1 * 60.0)), 1.649, 1.997, 9.0},
+	    {&orbits[2], ut_to_dt(cal_to_jd(2005, 11, 12, true)),
+	     hms_to_r(5, 31, 0.69 * 60.0),
+	     d_to_r(dms_to_d(0.0, 24, 0.1 * 60.0)), 1.115, 1.984, 7.8}
+
+	};
+	int tests_size = sizeof(tests) / sizeof(*tests);
+
+	int o;
+	for (o = 0; o < tests_size; o++) {
+	    jd_test_values *test = &tests[o];
+	    orbit_s *or = test->orbit;
+	    printf("Testing %s, test %d\n", or->name, o);
+
+
+	    double L, B, R;
+	    sol_dimension3_fk5(test->jd, &L, &B, &R);
+	    rec_coords sun_rec = sol_rectangular(L, B, R, obliquity_hi(je_to_jd(2000)));
+
+
+	    double ra;
+	    double dec;
+	    double elongation;
+	    double phase_angle;
+	    double body_r_earth;
+	    double body_r_sun;
+	    orbital_elements cd;
+
+	    double this_jd = test->jd;
+	    int c;
+	    for(c=0;c<5;c++) {
+	      cd = populate_orbital_elements(or->epoch, or->M, this_jd, or->n,
+					     or->a, or->e, or->i, or->w, or->L,
+					     iau_s, or->H, or->G);
+
+	      element_constants ec = get_element_constants(obliquity_hi(je_to_jd(2000)), cd, 53);
+	      body_r_sun = get_r_sun(ec);
+	      rec_coords body_rec = elliptical_orbit_rectangular(ec, body_r_sun);
+
+	      elliptical_orbit_ecliptical(sun_rec, body_rec, body_r_sun,
+					  &ra, &dec, &elongation,
+					  &phase_angle, &body_r_earth);
+
+	      double tau = 0.0057755183 * body_r_earth;
+
+	      this_jd = test->jd - tau;
+
+	    }
+
+
+	    double mag =
+		mag_iau(cd.magdata._iau.H, cd.magdata._iau.G, body_r_sun,
+			body_r_earth, phase_angle);
+
+	    int h, m;
+	    double s;
+	    r_to_hms(ra, &h, &m, &s);
+
+
+	    /* Things to do:
+	     *   correct for light time.
+	     *   correct for nutation.
+	     *   correct for precession.
+	     *   correct for aberration.
+	     */
+
+	    /* Adjust for nutation. */
+	    double a_in_ra, a_in_dec;
+	    aberration_in_ra_dec_low(test->jd, ra, dec, obliquity_hi(test->jd), L, &a_in_ra, &a_in_dec);
+	    ra  += a_in_ra;
+	    dec += a_in_dec;
+
+	    precession_eq(precession_get_elements_eq(je_to_jd(2000.0), test->jd), ra, dec, &ra, &dec);
+
+	    double n_in_ra, n_in_dec;
+	    nut_in_ra_dec(ra, dec, obliquity_hi(test->jd), nut_in_lon(test->jd), nut_in_obl(test->jd), &n_in_ra, &n_in_dec);
+	    ra  += n_in_ra ;
+	    dec += n_in_dec;
+
+
+
+	    printf("$$$$ %f:%f $$$$\n", (n_in_ra * (360.0 * 60.0 * 60.0) / (2*pi)), (n_in_dec * (360.0 * 60.0 * 60.0) / (2*pi)));
+	    printf("$$$$ %f:%f $$$$\n", (a_in_ra * (360.0 * 60.0 * 60.0) / (2*pi)), (a_in_dec * (360.0 * 60.0 * 60.0) / (2*pi)));
+
+	    report("RA", (ra * (360.0 * 60.0 * 60.0) / (2*pi)), (test->ra * (360.0 * 60.0 * 60.0) / (2*pi)), 0.00030, "arc-sec");
+	    report("Declination", (dec * (360.0 * 60.0 * 60.0) / (2*pi)), (test->dec * (360.0 * 60.0 * 60.0) / (2*pi)), 0.00030, "arc-sec");
+	    report("Distance (Earth)", body_r_earth, test->r_earth, 0.000001,
+		   "AU");
+	    report("Distance (Sun)", body_r_sun, test->r_sun, 0.000001,
+		   "AU");
+	    report("Magnitude", mag, test->mag, 1.0, "");
+	}
     }
 }
 
-int main()
+int main(int argc, char *argv[])
 {
     _main();
     printf
-	("\nWarning: Former exception throws (now error return values) have not been checked for.\n");
+	("\nWarning: Former exception throws (now error return values)"
+	 " have not been checked for.\n");
     /*
        try {
        _main();



From izogi at berlios.de  Fri Jan  6 10:50:38 2006
From: izogi at berlios.de (izogi at BerliOS)
Date: Fri, 6 Jan 2006 10:50:38 +0100
Subject: [Ephemeritis-svn] r192 - in trunk/src/c: libephemeritis tests
Message-ID: <200601060950.k069ocfp026271@sheep.berlios.de>

Author: izogi
Date: 2006-01-06 10:50:37 +0100 (Fri, 06 Jan 2006)
New Revision: 192

Modified:
   trunk/src/c/libephemeritis/equationoftime.c
   trunk/src/c/libephemeritis/vsop87d.c
   trunk/src/c/tests/validate_meeus.c
Log:
Fixed a bug in equation_of_time(), where the Earth's nutation was being added to solar longitude instead of subtracted.


Modified: trunk/src/c/libephemeritis/equationoftime.c
===================================================================
--- trunk/src/c/libephemeritis/equationoftime.c	2006-01-05 08:27:10 UTC (rev 191)
+++ trunk/src/c/libephemeritis/equationoftime.c	2006-01-06 09:50:37 UTC (rev 192)
@@ -38,7 +38,7 @@
 
 /*! @brief Calculates the equation of time at a given instant.
  *
- *  @param[in] jd  The julian date for which to calculate the equation of time.
+ *  @param[in] jd  The julian date for which to calculate the equation of time, in dynamical time.
  *
  *  @return        The equation of time for the specified instant.
  *
@@ -46,11 +46,13 @@
  */
 double equation_of_time(const double jd)
 {
-    double T = (jd - 2451545.0) / 365250.0;
+  double T = jd_to_jcent(jd) / 10.0;
+  /* (jd - 2451545.0) / 365250.0; */
     double _terms[] =
-	{ 280.4664567, 360007.6982779, 0.03032028, 1.0 / 49931.0,
-	1.0 / 15300.0, 1.0 / 2000000.0
-    };
+      {
+	280.4664567, 360007.6982779, 0.03032028, 1.0 / 49931.0,
+	-1.0 / 15300.0, -1.0 / 2000000.0
+      };
     double L0 = modpi2(d_to_r(polynomial(_terms, 6, T)));
 
     /* Solar longitude, latitude and radius. */
@@ -62,7 +64,7 @@
     double aberration = aberration_low(radius);
 
     /* Correct the longitude for nutation and aberration. */
-    longitude = longitude + nut_in_lon(jd) + aberration;
+    longitude = longitude - nut_in_lon(jd) + aberration;
 
     /* Solar ra and dec. */
     double obl = obliquity_hi(jd) + nut_in_obl(jd);

Modified: trunk/src/c/libephemeritis/vsop87d.c
===================================================================
--- trunk/src/c/libephemeritis/vsop87d.c	2006-01-05 08:27:10 UTC (rev 191)
+++ trunk/src/c/libephemeritis/vsop87d.c	2006-01-06 09:50:37 UTC (rev 192)
@@ -66,11 +66,13 @@
     /* The idea here is to sum the results of A*cos(B+(C*tau)) for
      * each series, combine the result for each series together in
      * a polynomial of the form L = L0 + L1tau + l2tau^2, etc, 
-     * 
+     *
      */
 
     double X = 0.0;
     double tauN = 1.0;
+
+    /* Set tau to the Julian millenia. */
     const double tau = jd_to_jcent(jd) / 10.0;
 
     /* Sum together results of A * cos(B + (C*tau)) of each term.

Modified: trunk/src/c/tests/validate_meeus.c
===================================================================
--- trunk/src/c/tests/validate_meeus.c	2006-01-05 08:27:10 UTC (rev 191)
+++ trunk/src/c/tests/validate_meeus.c	2006-01-06 09:50:37 UTC (rev 192)
@@ -684,15 +684,28 @@
     {
 	double L, B, R;
 	sol_dimension3_vsop(2448908.5, &L, &B, &R);
+	/*
 	report_diff("longitude", r_to_d(L) * 3600, 199.907372 * 3600,
 		    "arc-seconds");
 	report_diff("latitude", r_to_d(B) * 3600, 0.644, "arc-seconds");
 	report_diff("radius", R * km_per_au, 0.99760775 * km_per_au, "km");
+	*/
+
+	report("longitude", r_to_d(L) * 3600, 199.907372 * 3600, 1.0, "arc-seconds");
+	report("latitude", r_to_d(B) * 3600, 0.644, 1.0, "arc-seconds");
+	report("radius", R * km_per_au, 0.99760775 * km_per_au, 200.0, "km");
+
 	vsop_to_fk5(2448908.5, &L, &B);
+
+	/*
 	report_diff("corrected longitude", r_to_d(L) * 3600,
 		    199.907347 * 3600, "arc-seconds");
 	report_diff("corrected latitude", r_to_d(B) * 3600, 0.62,
 		    "arc-seconds");
+	*/
+	report("corrected longitude", r_to_d(L) * 3600, 199.907347 * 3600, 1.0, "arc-seconds");
+	report("corrected latitude", r_to_d(B) * 3600, 0.62, 1.0, "arc-seconds");
+
 	const double aberration = aberration_low(R);
 	report("aberration", r_to_d(aberration) * 3600, -20.539, 0.001,
 	       "arc-seconds");
@@ -721,9 +734,9 @@
 	R = 0.99760775;
 	double E = obliquity_hi(jd);
 	rec_coords rc = sol_rectangular(L, B, R, E);
-	report("X", rc.x, -0.9379952, 0.0000001, "AU");
-	report("Y", rc.y, -0.3116544, 0.0000001, "AU");
-	report("Z", rc.z, -0.1351215, 0.0000001, "AU");
+	report("X", rc.x * km_per_au, -0.9379952 * km_per_au, 5.0, "km");
+	report("Y", rc.y * km_per_au, -0.3116544 * km_per_au, 5.0, "km");
+	report("Z", rc.z * km_per_au, -0.1351215 * km_per_au, 5.0, "km");
     }
 
     printf("27.a Approximate solstice\n");
@@ -817,11 +830,11 @@
 
     printf("28.a Equation of time\n");
     {
-	double jd = 2448908.5;
+      double jd = 2448908.5;
 	double eot_result = equation_of_time(jd);
-	report("Equation of time", eot_result,
-	       fday_to_r(hms_to_fday(0.0, 13.0, 42.6)), 0.000001,
-	       "radians");
+	report("Equation of time", eot_result * 3600.0,
+	       fday_to_r(hms_to_fday(0.0, 13.0, 42.6)) * 3600.0, 1,
+	       "arc-sec");
     }
 
     printf("30.a Eccentricity anomoly (Equation of Kepler)\n");
@@ -837,11 +850,16 @@
     {
 	double L, B, R;
 	vsop_dimension3_vsop(2448976.5, vVenus, &L, &B, &R);
+	/*
 	report_diff("longitude", r_to_d(L) * 3600, 26.11428 * 3600,
 		    "arc-seconds");
 	report_diff("latitude", r_to_d(B) * 3600, -2.62070 * 3600,
 		    "arc-seconds");
 	report_diff("radius", R * km_per_au, 0.724603 * km_per_au, "km");
+	*/
+	report("longitude", r_to_d(L) * 3600, 26.11428 * 3600, 1.0, "arc-seconds");
+	report("latitude", r_to_d(B) * 3600, -2.62070 * 3600, 1.0, "arc-seconds");
+	report("radius", R * km_per_au, 0.724603 * km_per_au, 200.0, "km");
     }
 
     printf("33.a Apparent position (vsop)\n");
@@ -882,11 +900,11 @@
 	double L, B, R;
 	sol_dimension3_fk5(jd, &L, &B, &R);
 	rec_coords src = sol_rectangular(L, B, R, obl2000);
-	report("solar x", src.x, -0.9756732, 0.0000001, "AU");
-	report("solar y", src.y, -0.2003254, 0.0000001, "AU");
-	report("solar z", src.z, -0.0868566, 0.0000001, "AU");
+	report("solar x", src.x * km_per_au, -0.9756732 * km_per_au, 0.0000001, "km");
+	report("solar y", src.y * km_per_au, -0.2003254 * km_per_au, 0.0000001, "km");
+	report("solar z", src.z * km_per_au, -0.0868566 * km_per_au, 0.0000001, "km");
 
-	printf("Resetting sol values to those in example (because VSOP isn't calculating them properly as above)");
+	printf("Resetting sol values to those in example (because VSOP isn't calculating them properly as above)\n");
 	src.x = -0.9756732;
 	src.y = -0.2003254;
 	src.z = -0.0868566;



From izogi at berlios.de  Fri Jan  6 11:34:20 2006
From: izogi at berlios.de (izogi at BerliOS)
Date: Fri, 6 Jan 2006 11:34:20 +0100
Subject: [Ephemeritis-svn] r193 - trunk/src/c/tests
Message-ID: <200601061034.k06AYK0E030347@sheep.berlios.de>

Author: izogi
Date: 2006-01-06 11:34:19 +0100 (Fri, 06 Jan 2006)
New Revision: 193

Modified:
   trunk/src/c/tests/validate_meeus.c
Log:
Rearranged unit tests for chapter 25.b of Meeus (solar coordinates), as they didn't appear to be properly applying the examples in the book.


Modified: trunk/src/c/tests/validate_meeus.c
===================================================================
--- trunk/src/c/tests/validate_meeus.c	2006-01-06 09:50:37 UTC (rev 192)
+++ trunk/src/c/tests/validate_meeus.c	2006-01-06 10:34:19 UTC (rev 193)
@@ -682,8 +682,9 @@
 
     printf("25.b Sun position, high precision\n");
     {
+        double jd = 2448908.5;
 	double L, B, R;
-	sol_dimension3_vsop(2448908.5, &L, &B, &R);
+	sol_dimension3_vsop(jd, &L, &B, &R);
 	/*
 	report_diff("longitude", r_to_d(L) * 3600, 199.907372 * 3600,
 		    "arc-seconds");
@@ -704,20 +705,35 @@
 		    "arc-seconds");
 	*/
 	report("corrected longitude", r_to_d(L) * 3600, 199.907347 * 3600, 1.0, "arc-seconds");
-	report("corrected latitude", r_to_d(B) * 3600, 0.62, 1.0, "arc-seconds");
+	report("corrected latitude", r_to_d(B) * 3600, 0.62, 0.1, "arc-seconds");
 
-	const double aberration = aberration_low(R);
-	report("aberration", r_to_d(aberration) * 3600, -20.539, 0.001,
-	       "arc-seconds");
 
 	printf
 	    ("25.b Sun position, high precision (complete theory pg 165)\n");
+
+	const double n_in_l = nut_in_lon(jd);
+	const double n_in_o = nut_in_obl(jd);
+	const double obl = obliquity_hi(jd) + n_in_o;
+	const double aberration = aberration_low(R);
+
+	report("nutation in lon", r_to_d(n_in_l) * 3600, 15.908, 0.001, "arc-seconds");
+	report("nutation in obliquity", r_to_d(n_in_o) * 3600, -0.308, 0.001, "arc-seconds");
+	report("obliquity", r_to_d(obl), 23.4401443, 0.0000001, "degrees");
+	report("aberration", r_to_d(aberration) * 3600, -20.539, 0.001, "arc-seconds");
+
+	double app_lon = L + n_in_l - aberration;
+	report("apparent longitude", r_to_d(app_lon),
+	       dms_to_d(199, 54, 21.818), 0.000000001,
+	       "radians");
+
 	report("longitude", r_to_d(L) * 3600 * 100,
 	       dms_to_d(199, 54, 26.18) * 3600 * 100, 1,
 	       "arc-seconds/100");
 	report("latitude", r_to_d(B) * 3600 * 100, 0.72 * 100, 1,
 	       "arc-seconds/100");
 	report("radius", R, 0.99760853, 1e-8, "au");
+
+
     }
 
     printf("26.a Rectangular coordinates of the Sun\n");
@@ -900,9 +916,9 @@
 	double L, B, R;
 	sol_dimension3_fk5(jd, &L, &B, &R);
 	rec_coords src = sol_rectangular(L, B, R, obl2000);
-	report("solar x", src.x * km_per_au, -0.9756732 * km_per_au, 0.0000001, "km");
-	report("solar y", src.y * km_per_au, -0.2003254 * km_per_au, 0.0000001, "km");
-	report("solar z", src.z * km_per_au, -0.0868566 * km_per_au, 0.0000001, "km");
+	report("solar x", src.x * km_per_au, -0.9756732 * km_per_au, 1, "km");
+	report("solar y", src.y * km_per_au, -0.2003254 * km_per_au, 1, "km");
+	report("solar z", src.z * km_per_au, -0.0868566 * km_per_au, 1, "km");
 
 	printf("Resetting sol values to those in example (because VSOP isn't calculating them properly as above)\n");
 	src.x = -0.9756732;



From izogi at berlios.de  Sat Jan  7 23:42:24 2006
From: izogi at berlios.de (izogi at BerliOS)
Date: Sat, 7 Jan 2006 23:42:24 +0100
Subject: [Ephemeritis-svn] r194 - trunk/src/c/tests
Message-ID: <200601072242.k07MgOKY010351@sheep.berlios.de>

Author: izogi
Date: 2006-01-07 23:42:23 +0100 (Sat, 07 Jan 2006)
New Revision: 194

Modified:
   trunk/src/c/tests/validate_meeus.c
Log:
Minor adjustments to validate_meeus to make output clearer.


Modified: trunk/src/c/tests/validate_meeus.c
===================================================================
--- trunk/src/c/tests/validate_meeus.c	2006-01-06 10:34:19 UTC (rev 193)
+++ trunk/src/c/tests/validate_meeus.c	2006-01-07 22:42:23 UTC (rev 194)
@@ -704,10 +704,12 @@
 	report_diff("corrected latitude", r_to_d(B) * 3600, 0.62,
 		    "arc-seconds");
 	*/
-	report("corrected longitude", r_to_d(L) * 3600, 199.907347 * 3600, 1.0, "arc-seconds");
-	report("corrected latitude", r_to_d(B) * 3600, 0.62, 0.1, "arc-seconds");
+	report("corrected fk5 longitude", r_to_d(L) * 3600, 199.907347 * 3600, 1.0, "arc-seconds");
+	report("corrected fk5 latitude", r_to_d(B) * 3600, 0.644 - 0.023, 0.1, "arc-seconds");
+	/*
+	report("corrected fk5 latitude", r_to_d(B) * 3600, 0.62, 0.1, "arc-seconds");
+	*/
 
-
 	printf
 	    ("25.b Sun position, high precision (complete theory pg 165)\n");
 
@@ -721,10 +723,10 @@
 	report("obliquity", r_to_d(obl), 23.4401443, 0.0000001, "degrees");
 	report("aberration", r_to_d(aberration) * 3600, -20.539, 0.001, "arc-seconds");
 
-	double app_lon = L + n_in_l - aberration;
-	report("apparent longitude", r_to_d(app_lon),
-	       dms_to_d(199, 54, 21.818), 0.000000001,
-	       "radians");
+	double app_lon = L + n_in_l + aberration;
+	report("apparent longitude", r_to_d(app_lon) * 3600.0,
+	       dms_to_d(199, 54, 21.818) * 3600.0, 1,
+	       "arc-seconds");
 
 	report("longitude", r_to_d(L) * 3600 * 100,
 	       dms_to_d(199, 54, 26.18) * 3600 * 100, 1,
@@ -915,6 +917,8 @@
 
 	double L, B, R;
 	sol_dimension3_fk5(jd, &L, &B, &R);
+
+
 	rec_coords src = sol_rectangular(L, B, R, obl2000);
 	report("solar x", src.x * km_per_au, -0.9756732 * km_per_au, 1, "km");
 	report("solar y", src.y * km_per_au, -0.2003254 * km_per_au, 1, "km");



From izogi at berlios.de  Sun Jan  8 10:07:55 2006
From: izogi at berlios.de (izogi at BerliOS)
Date: Sun, 8 Jan 2006 10:07:55 +0100
Subject: [Ephemeritis-svn] r195 - in trunk/src: . c/libephemeritis
Message-ID: <200601080907.k0897t6V021532@sheep.berlios.de>

Author: izogi
Date: 2006-01-08 10:07:54 +0100 (Sun, 08 Jan 2006)
New Revision: 195

Added:
   trunk/src/data/
   trunk/src/python/
Modified:
   trunk/src/c/libephemeritis/solar.c
Log:
Noted inability of sol_rectangular to calculate a J2000.0 equinox as a bug.
Added a couple of new directories (src/python and src/data) to hold future data, with plans to re-write the VSOP code to be less dependent on the data files.


Modified: trunk/src/c/libephemeritis/solar.c
===================================================================
--- trunk/src/c/libephemeritis/solar.c	2006-01-07 22:42:23 UTC (rev 194)
+++ trunk/src/c/libephemeritis/solar.c	2006-01-08 09:07:54 UTC (rev 195)
@@ -216,6 +216,9 @@
  *  @sa obliquity_low
  *  @sa obliquity_hi
  *
+ *  @bug Doesn't calculate coordinates for J2000.0 equinox, as with
+ *  equation 26.2 and required for some things (such as ex 33.b).
+ *
  *  @author Mike McGavin.
  */
 rec_coords sol_rectangular(double L, double B, double R, double obl)



From izogi at berlios.de  Sun Jan  8 10:14:39 2006
From: izogi at berlios.de (izogi at BerliOS)
Date: Sun, 8 Jan 2006 10:14:39 +0100
Subject: [Ephemeritis-svn] r196 - branches
Message-ID: <200601080914.k089EdDP021961@sheep.berlios.de>

Author: izogi
Date: 2006-01-08 10:14:38 +0100 (Sun, 08 Jan 2006)
New Revision: 196

Added:
   branches/new-vsop-prepare/
Log:
Created a new branch for re-writing the VSOP calculation code.


Copied: branches/new-vsop-prepare (from rev 195, trunk)



From izogi at berlios.de  Sun Jan  8 12:05:10 2006
From: izogi at berlios.de (izogi at BerliOS)
Date: Sun, 8 Jan 2006 12:05:10 +0100
Subject: [Ephemeritis-svn] r197 - in branches/new-vsop-prepare: . src/c src/c/libephemeritis src/c/utils
Message-ID: <200601081105.k08B5Ade031910@sheep.berlios.de>

Author: izogi
Date: 2006-01-08 12:05:09 +0100 (Sun, 08 Jan 2006)
New Revision: 197

Added:
   branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_structs.h
   branches/new-vsop-prepare/src/c/utils/
   branches/new-vsop-prepare/src/c/utils/Makefile.am
   branches/new-vsop-prepare/src/c/utils/build_vsop_data.c
Modified:
   branches/new-vsop-prepare/configure.ac
   branches/new-vsop-prepare/src/c/Makefile.am
   branches/new-vsop-prepare/src/c/libephemeritis/vsop_structures.h
Log:
Began work, in the new branch, on a utility to convert text-based VSOP catalog data to binary format.
This has involved defining some initial structures, and making the start of a program that'll read from one file and write to another.
The binary format isn't intended to be architecture independent, meaning that the utility would need to be run for the source file to generate binary data for whatever arch it's run on.  Hopefully this can be somehow put into the configure/make system.


Modified: branches/new-vsop-prepare/configure.ac
===================================================================
--- branches/new-vsop-prepare/configure.ac	2006-01-08 09:14:38 UTC (rev 196)
+++ branches/new-vsop-prepare/configure.ac	2006-01-08 11:05:09 UTC (rev 197)
@@ -56,4 +56,5 @@
 	src/c/Makefile
 	src/c/libephemeritis/Makefile
 	src/c/tests/Makefile
+	src/c/utils/Makefile
 	])

Modified: branches/new-vsop-prepare/src/c/Makefile.am
===================================================================
--- branches/new-vsop-prepare/src/c/Makefile.am	2006-01-08 09:14:38 UTC (rev 196)
+++ branches/new-vsop-prepare/src/c/Makefile.am	2006-01-08 11:05:09 UTC (rev 197)
@@ -1,2 +1,2 @@
 AUTOMAKE_OPTIONS = gnu
-SUBDIRS = libephemeritis tests
+SUBDIRS = libephemeritis tests utils

Added: branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_structs.h
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_structs.h	2006-01-08 09:14:38 UTC (rev 196)
+++ branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_structs.h	2006-01-08 11:05:09 UTC (rev 197)
@@ -0,0 +1,70 @@
+/* Copyright 2000, 2001, 2005 William McClain, Mike McGavin
+
+This file is part of Ephemeritis.
+
+Ephemeritis is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+Ephemeritis is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Ephemeritis; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#ifndef _ephemeritis_vsop_structs_h_
+#define _ephemeritis_vsop_structs_h_
+
+/*! @file ephemeritis_vsop_structs.h
+ *
+ * Type definitions for VSOP data structures.  This list is included
+ * by various parts of the code and utilities to allow them to share
+ * commonly understood data structures.
+ *
+ * @author Mike McGavin.
+ */
+
+typedef struct {
+  double A, B, C;
+} term_bin;
+
+
+typedef struct {
+  char alpha;          /*!< @brief The degree alpha of time variable for this series. */
+  short int num_terms; /*!< @brief The number of terms listed for this series. */
+} series_meta_bin;
+typedef struct {
+  series_meta_bin meta; /*!< @brief Binary meta data about the series'. */
+  term_bin *terms;          /*!< @brief The terms. */
+} series;
+
+
+typedef struct {
+  char series_count;   /*!< @brief The number of series' listed in the series_list field. */
+} vsop_variable_meta_bin;
+typedef struct {
+  vsop_variable_meta_bin meta; /*!< @brief Binary meta data about the VSOP variable. */
+  series *series_list;         /*!< @brief The series'. */
+} vsop_variable;
+
+#define EPHEMERITIS_BIN_HEADER_TEXT_FORMAT "EphB v=%s"
+
+typedef struct{
+  char eph_header_text[23]; /*!< @brief Ephemeritis header text. */
+  char body_name[8];   /*!< @brief The name of the body represented by these elements. */
+  char num_variables;  /*!< @brief The number of variables included in these elements. */
+} body_elements_meta_bin;
+/*! @brief Collects together a particular set of elements for a
+ *  particular body.
+ */
+typedef struct {
+  body_elements_meta_bin meta;    /*!< Binary meta data about the body elements. */
+  vsop_variable variable_list[6]; /*!< The variables. */
+} body_elements;
+
+#endif

Modified: branches/new-vsop-prepare/src/c/libephemeritis/vsop_structures.h
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/vsop_structures.h	2006-01-08 09:14:38 UTC (rev 196)
+++ branches/new-vsop-prepare/src/c/libephemeritis/vsop_structures.h	2006-01-08 11:05:09 UTC (rev 197)
@@ -17,7 +17,9 @@
 Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
 
-/* Type definitions for VSOP data structures.  This list is included
+/*! @file vsop_structures.h
+ *
+ * Type definitions for VSOP data structures.  This list is included
  * by vsopdata.c and vsop87d, to allow them to share commonly
  * understood data structures.
  */

Copied: branches/new-vsop-prepare/src/c/utils/Makefile.am (from rev 196, branches/new-vsop-prepare/src/c/tests/Makefile.am)
===================================================================
--- branches/new-vsop-prepare/src/c/tests/Makefile.am	2006-01-08 09:14:38 UTC (rev 196)
+++ branches/new-vsop-prepare/src/c/utils/Makefile.am	2006-01-08 11:05:09 UTC (rev 197)
@@ -0,0 +1,24 @@
+AUTOMAKE_OPTIONS = gnu
+
+## CXXFLAGS =
+## AM_CXXFLAGS =
+
+AM_CFLAGS = -ansi -Wall
+
+bin_PROGRAMS = \
+	build_vsop_data
+
+build_vsop_data_SOURCES		= build_vsop_data.c
+
+AM_LDFLAGS = -L../libephemeritis/ -lephemeritis -lm
+
+INCLUDES = -I../libephemeritis/
+
+## if DEBUG
+## 	DBG = debug
+## else
+## 	DBG =
+## endif
+## noinst_PROGRAMS = $(DBG)
+       
+## noinst_PROGRAMS = 0

Added: branches/new-vsop-prepare/src/c/utils/build_vsop_data.c
===================================================================
--- branches/new-vsop-prepare/src/c/utils/build_vsop_data.c	2006-01-08 09:14:38 UTC (rev 196)
+++ branches/new-vsop-prepare/src/c/utils/build_vsop_data.c	2006-01-08 11:05:09 UTC (rev 197)
@@ -0,0 +1,110 @@
+/* Copyright 2000, 2001, 2005 William McClain, Mike McGavin
+
+This file is part of Ephemeritis.
+
+Ephemeritis is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+Ephemeritis is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Ephemeritis; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+/*! @file build_vsop_data.c
+ *
+ * A program to build binary VSOP87 data files, based on the
+ * text-based source files.
+ *
+ * @author Mike McGavin.
+ */
+
+#include "config.h"
+#include <ephemeritis_vsop_structs.h>
+#include <stdio.h>
+#include <errno.h>
+#include <string.h>
+
+/* Define a buffer size large enough to hold any line in the incoming files. */
+#define BUF_SIZE 1000
+
+
+char *substr(char *target, char *src, int start, int end)
+{
+  char *t = target, *p;
+  for(p = src + start; p != src+end; p++)
+    *(t++) = *p;
+  *(t++) = NULL;
+  return target;
+}
+
+/*! @brief Takes a source file and generate a binary file.
+ *
+ *  @warning Any existing output files on the file system may be
+ *  overwritten without warning.
+ */
+int process(const char input_file[], const char output_file[])
+{
+  FILE *infile, *outfile;
+
+  /* Open files. */
+  if(NULL == (infile = fopen(input_file, "r"))) {
+    fprintf(stderr, "%s: %s\n", input_file, strerror(errno));
+    return 2;
+  }
+  if(NULL == (outfile = fopen(output_file, "wb"))) {
+    fprintf(stderr, "%s: %s\n", output_file, strerror(errno));
+    return 3;
+  }
+
+  /* Write the header at the start to force space.  It'll need
+   * overwriting at the end, as the data isn't available yet.
+   */
+  body_elements_meta_bin body_meta;
+  memset(&body_meta, 0, sizeof(body_meta));
+  sprintf(body_meta.eph_header_text, EPHEMERITIS_BIN_HEADER_TEXT_FORMAT, VERSION);
+  fwrite(&body_meta, sizeof(body_meta), 1, outfile);
+
+  /* Allocate a reasonably sized buffer for reading lines into. */
+  char buf[BUF_SIZE];
+
+  char *incoming;
+  char ch_body_name[8];
+  char ch_coordinate_index[2];
+  char ch_alpha[2];
+  char ch_num_terms[8];
+
+  vsop_variable_meta_bin var_meta;
+
+
+  incoming = fgets(buf, BUF_SIZE, infile);
+  while(NULL != incoming) {
+    /* Extract some data. */
+    printf("%s, %d\n", substr(ch_body_name, incoming, 22, 29), strlen(ch_body_name));
+
+    incoming = fgets(buf, BUF_SIZE, infile);
+  }
+
+  /* Close files. */
+  fclose(infile);
+  fclose(outfile);
+
+  return 0;
+}
+
+int main(int argc, char *argv[])
+{
+  if(3 != argc) {
+    fprintf(stderr, "Usage: build_vsop_data <input_file> <output_file>\n");
+    return 1;
+  }
+  char* input_file = argv[1];
+  char* output_file = argv[2];
+  return process(input_file, output_file);
+}



From izogi at berlios.de  Mon Jan  9 09:03:03 2006
From: izogi at berlios.de (izogi at BerliOS)
Date: Mon, 9 Jan 2006 09:03:03 +0100
Subject: [Ephemeritis-svn] r198 - in branches/new-vsop-prepare/src/c: libephemeritis utils
Message-ID: <200601090803.k09833ZO030761@sheep.berlios.de>

Author: izogi
Date: 2006-01-09 09:03:03 +0100 (Mon, 09 Jan 2006)
New Revision: 198

Modified:
   branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_structs.h
   branches/new-vsop-prepare/src/c/utils/build_vsop_data.c
Log:
Finished build_vsop_data program (mostly) for generating individual binary files for VSOP87 calculation.


Modified: branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_structs.h
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_structs.h	2006-01-08 11:05:09 UTC (rev 197)
+++ branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_structs.h	2006-01-09 08:03:03 UTC (rev 198)
@@ -39,8 +39,8 @@
   short int num_terms; /*!< @brief The number of terms listed for this series. */
 } series_meta_bin;
 typedef struct {
-  series_meta_bin meta; /*!< @brief Binary meta data about the series'. */
-  term_bin *terms;          /*!< @brief The terms. */
+  series_meta_bin meta;/*!< @brief Binary meta data about the series'. */
+  term_bin *terms;     /*!< @brief The terms. */
 } series;
 
 

Modified: branches/new-vsop-prepare/src/c/utils/build_vsop_data.c
===================================================================
--- branches/new-vsop-prepare/src/c/utils/build_vsop_data.c	2006-01-08 11:05:09 UTC (rev 197)
+++ branches/new-vsop-prepare/src/c/utils/build_vsop_data.c	2006-01-09 08:03:03 UTC (rev 198)
@@ -28,6 +28,7 @@
 #include "config.h"
 #include <ephemeritis_vsop_structs.h>
 #include <stdio.h>
+#include <stdlib.h>
 #include <errno.h>
 #include <string.h>
 
@@ -35,65 +36,215 @@
 #define BUF_SIZE 1000
 
 
-char *substr(char *target, char *src, int start, int end)
+static char *substr(char *target, char *src, const int start, const int end)
 {
   char *t = target, *p;
   for(p = src + start; p != src+end; p++)
     *(t++) = *p;
-  *(t++) = NULL;
+  *(t++) = '\0';
   return target;
 }
 
-/*! @brief Takes a source file and generate a binary file.
+
+/*! @brief Trims spaces from left and right of src, placing result in target.
  *
- *  @warning Any existing output files on the file system may be
- *  overwritten without warning.
+ *  src and target might be the same string.
  */
-int process(const char input_file[], const char output_file[])
+static char *strtrim(char *target, char *src)
 {
-  FILE *infile, *outfile;
+  char *s = src, *t = target;
+  while(' ' == *s) s++;
+  do {
+    *t++ = *s;
+  } while('\0' != *s++);
+  int p;
+  for(p=strlen(target)-1; p>=0 && ' '==target[p]; p--) {
+    target[p] = '\0';
+  }
+  return target;
+}
 
-  /* Open files. */
-  if(NULL == (infile = fopen(input_file, "r"))) {
-    fprintf(stderr, "%s: %s\n", input_file, strerror(errno));
-    return 2;
+
+static void fill_term(term_bin *t, char *incoming)
+{
+  char ch_A[32], ch_B[32], ch_C[32];
+  substr(ch_A, incoming,  79,  97);
+  substr(ch_B, incoming,  97, 111);
+  substr(ch_C, incoming, 111, 131);
+
+  t->A = atof(ch_A);
+  t->B = atof(ch_B);
+  t->C = atof(ch_C);
+  /*
+  printf("%.16f, %.16f, %.16f\n", t->A, t->B, t->C);
+  */
+}
+
+
+static void print_body_elements(FILE *ostream, body_elements *b)
+{
+  fprintf(ostream, "Ephemeritis Version String: %s.\n", b->meta.eph_header_text);
+  fprintf(ostream, "Data for \"%s\".\n", b->meta.body_name);
+  fprintf(ostream, "%d variables overall.\n", b->meta.num_variables);
+
+  int v;
+  for(v=0; v<b->meta.num_variables; v++) {
+    vsop_variable *var = &(b->variable_list[v]);
+    fprintf(ostream, "\nVariable %d contains %d series':\n\n", v, var->meta.series_count);
+
+    int s;
+    for(s=0; s<var->meta.series_count; s++) {
+      series *ser = &var->series_list[s];
+      fprintf(ostream, "  Series %d has alpha %d and contains %d terms.\n", s, ser->meta.alpha, (ser->meta.num_terms));
+    }
   }
-  if(NULL == (outfile = fopen(output_file, "wb"))) {
-    fprintf(stderr, "%s: %s\n", output_file, strerror(errno));
-    return 3;
+}
+
+/*! @brief Given an open output file and a body_elements structure,
+ *  output the body elements in binary format.
+ */
+static void write_body_elements(FILE *outfile, body_elements *b)
+{
+  /* Write the header data. */
+  fwrite(&b->meta, sizeof(b->meta), 1, outfile);
+
+  /* Loop through the variables, writing data of each one. */
+  int v;
+  for(v=0; v<b->meta.num_variables; v++) {
+    vsop_variable *var = &(b->variable_list[v]);
+    fwrite(&var->meta, sizeof(var->meta), 1, outfile);
+
+    /* Loop through the series variables, writing data of each one. */
+    int s;
+    for(s=0; s<var->meta.series_count; s++) {
+      series *ser = &var->series_list[s];
+      fwrite(&ser->meta, sizeof(ser->meta), 1, outfile);
+
+      /* Write the list of terms. */
+      fwrite(ser->terms, sizeof(*(ser->terms)), ser->meta.num_terms, outfile);
+    }
   }
+}
 
+/*! @brief De-allocates the space that was allocated for a
+ *  body_elements structure in memory.
+ */
+static void destroy_body_elements(body_elements *b)
+{
+  /* Not done yet. */
+}
+
+/*! @brief Allocates space for and builds a body_elements structure in
+ *  memory, given an opened file to read from.
+ */
+static body_elements *build_body_elements(FILE *infile)
+{
   /* Write the header at the start to force space.  It'll need
    * overwriting at the end, as the data isn't available yet.
    */
-  body_elements_meta_bin body_meta;
-  memset(&body_meta, 0, sizeof(body_meta));
-  sprintf(body_meta.eph_header_text, EPHEMERITIS_BIN_HEADER_TEXT_FORMAT, VERSION);
-  fwrite(&body_meta, sizeof(body_meta), 1, outfile);
+  body_elements *body_el = (body_elements *)malloc(sizeof(body_elements));
+  memset(body_el, '\0', sizeof(*body_el));
+  sprintf(body_el->meta.eph_header_text, EPHEMERITIS_BIN_HEADER_TEXT_FORMAT, VERSION);
+  body_el->meta.num_variables = 0;
 
   /* Allocate a reasonably sized buffer for reading lines into. */
   char buf[BUF_SIZE];
 
   char *incoming;
   char ch_body_name[8];
-  char ch_coordinate_index[2];
+  char ch_variable_num[2];
   char ch_alpha[2];
   char ch_num_terms[8];
 
-  vsop_variable_meta_bin var_meta;
 
-
   incoming = fgets(buf, BUF_SIZE, infile);
   while(NULL != incoming) {
     /* Extract some data. */
-    printf("%s, %d\n", substr(ch_body_name, incoming, 22, 29), strlen(ch_body_name));
+    substr(ch_body_name, incoming, 22, 29);
+    substr(ch_variable_num, incoming, 41, 42);
+    substr(ch_alpha, incoming, 59, 60);
+    substr(ch_num_terms, incoming, 60, 67);
 
+    int variable_index = atoi(ch_variable_num) - 1;
+    int alpha = atoi(ch_alpha);
+    int num_terms = atoi(ch_num_terms);
+
+    /* Copy in the name of the body (redundant all times except the first). */
+    strncpy(body_el->meta.body_name, strtrim(ch_body_name, ch_body_name), sizeof(body_el->meta.body_name));
+
+
+    /* Find the current variable structure. */
+    vsop_variable *this_var = &(body_el->variable_list[variable_index]);
+    if(variable_index+1 > body_el->meta.num_variables) {
+      body_el->meta.num_variables = variable_index+1;
+    }
+
+
+    /* This is a series header, so add a new series to the variable. */
+    this_var->meta.series_count++;
+
+
+    this_var->series_list = realloc(this_var->series_list, sizeof(series) * this_var->meta.series_count);
+
+    series *this_series = &(this_var->series_list[this_var->meta.series_count-1]);
+    this_series->meta.alpha = alpha;
+    this_series->meta.num_terms = num_terms;
+    this_series->terms = (term_bin *)malloc(num_terms * sizeof(term_bin));
+
+    int n;
+    for(n = 0; n < num_terms; n++) {
+      incoming = fgets(buf, BUF_SIZE, infile);
+      fill_term(&(this_series->terms[n]), incoming);
+    }
+
+
+    /* Read the next line. */
     incoming = fgets(buf, BUF_SIZE, infile);
   }
 
+  return body_el;
+}
+
+/*! @brief Takes a source file and generate a binary file.
+ *
+ *  @warning Any existing output files on the file system may be
+ *  overwritten without warning.
+ */
+static int process_streams(const char input_file[], const char output_file[])
+{
+  FILE *infile, *outfile;
+
+  /* Open files. */
+  if(!strcmp(input_file, "-")) {
+    infile = stdin;
+  } else if(NULL == (infile = fopen(input_file, "r"))) {
+    fprintf(stderr, "%s: %s\n", input_file, strerror(errno));
+    return 2;
+  }
+
+  if(!strcmp(output_file, "-")) {
+    outfile = stdout;
+  } else if(NULL == (outfile = fopen(output_file, "wb"))) {
+    fclose(infile);
+    fprintf(stderr, "%s: %s\n", output_file, strerror(errno));
+    return 3;
+  }
+
+  body_elements *body_el = build_body_elements(infile);
+
+
+  print_body_elements(stdout, body_el);
+  write_body_elements(outfile, body_el);
+
+  destroy_body_elements(body_el);
+
   /* Close files. */
-  fclose(infile);
-  fclose(outfile);
+  if(infile != stdin) {
+    fclose(infile);
+  }
+  if((outfile != stdout) && (outfile != stderr)) {
+    fclose(outfile);
+  }
 
   return 0;
 }
@@ -106,5 +257,5 @@
   }
   char* input_file = argv[1];
   char* output_file = argv[2];
-  return process(input_file, output_file);
+  return process_streams(input_file, output_file);
 }



From izogi at berlios.de  Mon Jan  9 10:17:34 2006
From: izogi at berlios.de (izogi at BerliOS)
Date: Mon, 9 Jan 2006 10:17:34 +0100
Subject: [Ephemeritis-svn] r199 - in branches/new-vsop-prepare/src/c: libephemeritis utils
Message-ID: <200601090917.k099HYG3004817@sheep.berlios.de>

Author: izogi
Date: 2006-01-09 10:17:33 +0100 (Mon, 09 Jan 2006)
New Revision: 199

Modified:
   branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_structs.h
   branches/new-vsop-prepare/src/c/utils/build_vsop_data.c
Log:
Added memory deallocation code to build_vsop_data utility.


Modified: branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_structs.h
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_structs.h	2006-01-09 08:03:03 UTC (rev 198)
+++ branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_structs.h	2006-01-09 09:17:33 UTC (rev 199)
@@ -55,16 +55,17 @@
 #define EPHEMERITIS_BIN_HEADER_TEXT_FORMAT "EphB v=%s"
 
 typedef struct{
-  char eph_header_text[23]; /*!< @brief Ephemeritis header text. */
-  char body_name[8];   /*!< @brief The name of the body represented by these elements. */
-  char num_variables;  /*!< @brief The number of variables included in these elements. */
+  char eph_header_text[23]; /*!< @brief Ephemeritis header text.                            */
+  char body_name[8];        /*!< @brief The name of the body represented by these elements. */
+  char num_variables;       /*!< @brief The number of variables included in these elements. */
 } body_elements_meta_bin;
+
 /*! @brief Collects together a particular set of elements for a
  *  particular body.
  */
 typedef struct {
   body_elements_meta_bin meta;    /*!< Binary meta data about the body elements. */
-  vsop_variable variable_list[6]; /*!< The variables. */
+  vsop_variable variable_list[6]; /*!< The variables.                            */
 } body_elements;
 
 #endif

Modified: branches/new-vsop-prepare/src/c/utils/build_vsop_data.c
===================================================================
--- branches/new-vsop-prepare/src/c/utils/build_vsop_data.c	2006-01-09 08:03:03 UTC (rev 198)
+++ branches/new-vsop-prepare/src/c/utils/build_vsop_data.c	2006-01-09 09:17:33 UTC (rev 199)
@@ -126,12 +126,35 @@
   }
 }
 
+
+/*! @brief De-allocates the space that was allocated for a series
+ *  structure in memory.
+ */
+static void destroy_series(series s)
+{
+  free(s.terms);
+}
+
 /*! @brief De-allocates the space that was allocated for a
  *  body_elements structure in memory.
  */
 static void destroy_body_elements(body_elements *b)
 {
-  /* Not done yet. */
+  int n;
+  for(n = 0; n < b->meta.num_variables; n++) {
+    vsop_variable *var = &b->variable_list[n];
+
+    int o;
+    for(o = 0; o < var->meta.series_count; o++) {
+      /* Destroy each series. */
+      destroy_series(var->series_list[o]);
+    }
+
+    /* Free the list of series for the variable. */
+    free(b->variable_list[n].series_list);
+  }
+  
+  free(b);
 }
 
 /*! @brief Allocates space for and builds a body_elements structure in
@@ -184,12 +207,12 @@
     this_var->meta.series_count++;
 
 
-    this_var->series_list = realloc(this_var->series_list, sizeof(series) * this_var->meta.series_count);
+    this_var->series_list = (series *)realloc(this_var->series_list, sizeof(series) * this_var->meta.series_count);
 
     series *this_series = &(this_var->series_list[this_var->meta.series_count-1]);
     this_series->meta.alpha = alpha;
     this_series->meta.num_terms = num_terms;
-    this_series->terms = (term_bin *)malloc(num_terms * sizeof(term_bin));
+    this_series->terms = (term_bin *)calloc(num_terms, sizeof(term_bin));
 
     int n;
     for(n = 0; n < num_terms; n++) {
@@ -197,7 +220,6 @@
       fill_term(&(this_series->terms[n]), incoming);
     }
 
-
     /* Read the next line. */
     incoming = fgets(buf, BUF_SIZE, infile);
   }
@@ -232,8 +254,9 @@
 
   body_elements *body_el = build_body_elements(infile);
 
-
+  /*
   print_body_elements(stdout, body_el);
+  */
   write_body_elements(outfile, body_el);
 
   destroy_body_elements(body_el);



From izogi at berlios.de  Mon Jan  9 10:38:35 2006
From: izogi at berlios.de (izogi at BerliOS)
Date: Mon, 9 Jan 2006 10:38:35 +0100
Subject: [Ephemeritis-svn] r200 - branches/new-vsop-prepare/src/c/utils
Message-ID: <200601090938.k099cZkj007717@sheep.berlios.de>

Author: izogi
Date: 2006-01-09 10:38:32 +0100 (Mon, 09 Jan 2006)
New Revision: 200

Modified:
   branches/new-vsop-prepare/src/c/utils/build_vsop_data.c
Log:
More minor changes to program.


Modified: branches/new-vsop-prepare/src/c/utils/build_vsop_data.c
===================================================================
--- branches/new-vsop-prepare/src/c/utils/build_vsop_data.c	2006-01-09 09:17:33 UTC (rev 199)
+++ branches/new-vsop-prepare/src/c/utils/build_vsop_data.c	2006-01-09 09:38:32 UTC (rev 200)
@@ -22,6 +22,11 @@
  * A program to build binary VSOP87 data files, based on the
  * text-based source files.
  *
+ * The following command, in a bash shell, will convert all files to
+ * their ephemeritis binary equivalents:
+ *
+ *    find source_path -name "VSOP87*" -exec build_vsop_data {} {}.eph.bin \;
+ *
  * @author Mike McGavin.
  */
 
@@ -275,7 +280,9 @@
 int main(int argc, char *argv[])
 {
   if(3 != argc) {
-    fprintf(stderr, "Usage: build_vsop_data <input_file> <output_file>\n");
+    fprintf(stderr,
+	    "Usage: build_vsop_data <input_file> <output_file>\n"
+	    "Specifying - for either file will respectively represent stdin and stdout.\n");
     return 1;
   }
   char* input_file = argv[1];



From izogi at berlios.de  Mon Jan  9 10:40:24 2006
From: izogi at berlios.de (izogi at BerliOS)
Date: Mon, 9 Jan 2006 10:40:24 +0100
Subject: [Ephemeritis-svn] r201 - branches/new-vsop-prepare/src/c/libephemeritis
Message-ID: <200601090940.k099eO8w008026@sheep.berlios.de>

Author: izogi
Date: 2006-01-09 10:40:23 +0100 (Mon, 09 Jan 2006)
New Revision: 201

Modified:
   branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_structs.h
Log:
Minor documentation additions to struct header.


Modified: branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_structs.h
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_structs.h	2006-01-09 09:38:32 UTC (rev 200)
+++ branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_structs.h	2006-01-09 09:40:23 UTC (rev 201)
@@ -29,6 +29,8 @@
  * @author Mike McGavin.
  */
 
+/*! @brief Represents a VSOP87 term.
+ */
 typedef struct {
   double A, B, C;
 } term_bin;



From izogi at berlios.de  Mon Jan  9 11:03:09 2006
From: izogi at berlios.de (izogi at BerliOS)
Date: Mon, 9 Jan 2006 11:03:09 +0100
Subject: [Ephemeritis-svn] r202 - in branches/new-vsop-prepare/src/c: libephemeritis utils
Message-ID: <200601091003.k09A39fx010942@sheep.berlios.de>

Author: izogi
Date: 2006-01-09 11:03:09 +0100 (Mon, 09 Jan 2006)
New Revision: 202

Added:
   branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.c
   branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.h
Removed:
   branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_structs.h
Modified:
   branches/new-vsop-prepare/src/c/libephemeritis/Makefile.am
   branches/new-vsop-prepare/src/c/utils/build_vsop_data.c
Log:
Renamed ephemeritis_vsop_structs.h to ephemeritis_vsop_data.h, so it can prototype data-handling related functions as well as defining structures.
Moved several VSOP-data-handling functions from build_vsop_data.c into the main library -- specifically ephemeritis_vsop_data.c.


Modified: branches/new-vsop-prepare/src/c/libephemeritis/Makefile.am
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/Makefile.am	2006-01-09 09:40:23 UTC (rev 201)
+++ branches/new-vsop-prepare/src/c/libephemeritis/Makefile.am	2006-01-09 10:03:09 UTC (rev 202)
@@ -13,6 +13,7 @@
 	dynamical.c \
 	elliptical.c \
 	elp2000.c \
+	ephemeritis_vsop_data.c \
 	equationoftime.c \
 	equinox.c \
 	nutation.c \
@@ -26,6 +27,6 @@
 	util.c
 
 include_HEADERS = ephemeritis.h ephemeritis_constid.h
-noinst_HEADERS = vsop_structures.h
+noinst_HEADERS = vsop_structures.h ephemeritis_vsop_data.h
 
 libephemeritis_la_ldflags = --version-info 0:0:0

Added: branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.c
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.c	2006-01-09 09:40:23 UTC (rev 201)
+++ branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.c	2006-01-09 10:03:09 UTC (rev 202)
@@ -0,0 +1,119 @@
+/* Copyright 2000, 2001, 2005 William McClain, Mike McGavin
+
+This file is part of Ephemeritis.
+
+Ephemeritis is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+Ephemeritis is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Ephemeritis; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+/*! @file ephemeritis_vsop_data.c
+ *
+ * @brief Management of VSOP data files, and in-memory structures.
+ *
+ * @author Mike McGavin.
+ */
+
+#include "ephemeritis_vsop_data.h"
+
+
+/*! @brief De-allocates the space that was allocated for a series
+ *  structure in memory.
+ *
+ *  @param[in] s The series struct.
+ */
+static void destroy_series(series s)
+{
+  free(s.terms);
+}
+
+/*! @brief De-allocates the space that was allocated for a
+ *  body_elements structure in memory.
+ *
+ *  @param[in] b A pointer to a body_elements object.  This will be
+ *  free()'d, as will the entire strucutre underneath it.  Ensure that
+ *  nothing inside is referenced from elsewhere.
+ */
+void destroy_body_elements(body_elements *b)
+{
+  int n;
+  for(n = 0; n < b->meta.num_variables; n++) {
+    vsop_variable *var = &b->variable_list[n];
+
+    int o;
+    for(o = 0; o < var->meta.series_count; o++) {
+      /* Destroy each series. */
+      destroy_series(var->series_list[o]);
+    }
+
+    /* Free the list of series for the variable. */
+    free(b->variable_list[n].series_list);
+  }
+  
+  free(b);
+}
+
+/*! @brief Prints details about the body elements in a human readable
+ *  form.
+ *
+ *  @param[in] ostream A stream pointer to which the text should be printed.  (eg. stdin, stderr, or an open file.)
+ *  @param[in] b       Pointer to the body elements.
+ */
+void print_body_elements(FILE *ostream, body_elements *b)
+{
+  fprintf(ostream, "Ephemeritis Version String: %s.\n", b->meta.eph_header_text);
+  fprintf(ostream, "Data for \"%s\".\n", b->meta.body_name);
+  fprintf(ostream, "%d variables overall.\n", b->meta.num_variables);
+
+  int v;
+  for(v=0; v<b->meta.num_variables; v++) {
+    vsop_variable *var = &(b->variable_list[v]);
+    fprintf(ostream, "\nVariable %d contains %d series':\n\n", v, var->meta.series_count);
+
+    int s;
+    for(s=0; s<var->meta.series_count; s++) {
+      series *ser = &var->series_list[s];
+      fprintf(ostream, "  Series %d has alpha %d and contains %d terms.\n", s, ser->meta.alpha, (ser->meta.num_terms));
+    }
+  }
+}
+
+/*! @brief Given an open output file and a body_elements structure,
+ *  output the body elements in binary format.
+ *
+ *  @param[in] outfile An open file to which the data should be written. The file is not closed after the operation.
+ *  @param[in] b       Pointer to the body elements.
+ */
+void write_body_elements(FILE *outfile, body_elements *b)
+{
+  /* Write the header data. */
+  fwrite(&b->meta, sizeof(b->meta), 1, outfile);
+
+  /* Loop through the variables, writing data of each one. */
+  int v;
+  for(v=0; v<b->meta.num_variables; v++) {
+    vsop_variable *var = &(b->variable_list[v]);
+    fwrite(&var->meta, sizeof(var->meta), 1, outfile);
+
+    /* Loop through the series variables, writing data of each one. */
+    int s;
+    for(s=0; s<var->meta.series_count; s++) {
+      series *ser = &var->series_list[s];
+      fwrite(&ser->meta, sizeof(ser->meta), 1, outfile);
+
+      /* Write the list of terms. */
+      fwrite(ser->terms, sizeof(*(ser->terms)), ser->meta.num_terms, outfile);
+    }
+  }
+}
+

Copied: branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.h (from rev 201, branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_structs.h)
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_structs.h	2006-01-09 09:40:23 UTC (rev 201)
+++ branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.h	2006-01-09 10:03:09 UTC (rev 202)
@@ -0,0 +1,84 @@
+/* Copyright 2000, 2001, 2005 William McClain, Mike McGavin
+
+This file is part of Ephemeritis.
+
+Ephemeritis is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+Ephemeritis is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Ephemeritis; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#ifndef _ephemeritis_vsop_structs_h_
+#define _ephemeritis_vsop_structs_h_
+
+/*! @file ephemeritis_vsop_structs.h
+ *
+ * Type definitions for VSOP data structures.  This list is included
+ * by various parts of the code and utilities to allow them to share
+ * commonly understood data structures.
+ *
+ * @todo Document the structures.
+ *
+ * @author Mike McGavin.
+ */
+
+#include <stdio.h>
+
+
+/*! @brief Represents a VSOP87 term.
+ */
+typedef struct {
+  double A, B, C;
+} term_bin;
+
+
+typedef struct {
+  char alpha;          /*!< @brief The degree alpha of time variable for this series. */
+  short int num_terms; /*!< @brief The number of terms listed for this series. */
+} series_meta_bin;
+typedef struct {
+  series_meta_bin meta;/*!< @brief Binary meta data about the series'. */
+  term_bin *terms;     /*!< @brief The terms. */
+} series;
+
+
+typedef struct {
+  char series_count;   /*!< @brief The number of series' listed in the series_list field. */
+} vsop_variable_meta_bin;
+typedef struct {
+  vsop_variable_meta_bin meta; /*!< @brief Binary meta data about the VSOP variable. */
+  series *series_list;         /*!< @brief The series'. */
+} vsop_variable;
+
+#define EPHEMERITIS_BIN_HEADER_TEXT_FORMAT "EphB v=%s"
+
+typedef struct{
+  char eph_header_text[23]; /*!< @brief Ephemeritis header text.                            */
+  char body_name[8];        /*!< @brief The name of the body represented by these elements. */
+  char num_variables;       /*!< @brief The number of variables included in these elements. */
+} body_elements_meta_bin;
+
+/*! @brief Collects together a particular set of elements for a
+ *  particular body.
+ */
+typedef struct {
+  body_elements_meta_bin meta;    /*!< Binary meta data about the body elements. */
+  vsop_variable variable_list[6]; /*!< The variables.                            */
+} body_elements;
+
+
+void destroy_body_elements(body_elements *b);
+void print_body_elements(FILE *ostream, body_elements *b);
+void write_body_elements(FILE *outfile, body_elements *b);
+
+
+#endif

Deleted: branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_structs.h
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_structs.h	2006-01-09 09:40:23 UTC (rev 201)
+++ branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_structs.h	2006-01-09 10:03:09 UTC (rev 202)
@@ -1,73 +0,0 @@
-/* Copyright 2000, 2001, 2005 William McClain, Mike McGavin
-
-This file is part of Ephemeritis.
-
-Ephemeritis is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2 of the License, or
-(at your option) any later version.
-
-Ephemeritis is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with Ephemeritis; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-*/
-
-#ifndef _ephemeritis_vsop_structs_h_
-#define _ephemeritis_vsop_structs_h_
-
-/*! @file ephemeritis_vsop_structs.h
- *
- * Type definitions for VSOP data structures.  This list is included
- * by various parts of the code and utilities to allow them to share
- * commonly understood data structures.
- *
- * @author Mike McGavin.
- */
-
-/*! @brief Represents a VSOP87 term.
- */
-typedef struct {
-  double A, B, C;
-} term_bin;
-
-
-typedef struct {
-  char alpha;          /*!< @brief The degree alpha of time variable for this series. */
-  short int num_terms; /*!< @brief The number of terms listed for this series. */
-} series_meta_bin;
-typedef struct {
-  series_meta_bin meta;/*!< @brief Binary meta data about the series'. */
-  term_bin *terms;     /*!< @brief The terms. */
-} series;
-
-
-typedef struct {
-  char series_count;   /*!< @brief The number of series' listed in the series_list field. */
-} vsop_variable_meta_bin;
-typedef struct {
-  vsop_variable_meta_bin meta; /*!< @brief Binary meta data about the VSOP variable. */
-  series *series_list;         /*!< @brief The series'. */
-} vsop_variable;
-
-#define EPHEMERITIS_BIN_HEADER_TEXT_FORMAT "EphB v=%s"
-
-typedef struct{
-  char eph_header_text[23]; /*!< @brief Ephemeritis header text.                            */
-  char body_name[8];        /*!< @brief The name of the body represented by these elements. */
-  char num_variables;       /*!< @brief The number of variables included in these elements. */
-} body_elements_meta_bin;
-
-/*! @brief Collects together a particular set of elements for a
- *  particular body.
- */
-typedef struct {
-  body_elements_meta_bin meta;    /*!< Binary meta data about the body elements. */
-  vsop_variable variable_list[6]; /*!< The variables.                            */
-} body_elements;
-
-#endif

Modified: branches/new-vsop-prepare/src/c/utils/build_vsop_data.c
===================================================================
--- branches/new-vsop-prepare/src/c/utils/build_vsop_data.c	2006-01-09 09:40:23 UTC (rev 201)
+++ branches/new-vsop-prepare/src/c/utils/build_vsop_data.c	2006-01-09 10:03:09 UTC (rev 202)
@@ -19,11 +19,11 @@
 
 /*! @file build_vsop_data.c
  *
- * A program to build binary VSOP87 data files, based on the
- * text-based source files.
+ *  @brief A program to build binary VSOP87 data files, based on the
+ *  text-based source files.
  *
- * The following command, in a bash shell, will convert all files to
- * their ephemeritis binary equivalents:
+ *  The following command, in a bash shell, will convert all files to
+ *  their ephemeritis binary equivalents:
  *
  *    find source_path -name "VSOP87*" -exec build_vsop_data {} {}.eph.bin \;
  *
@@ -31,7 +31,7 @@
  */
 
 #include "config.h"
-#include <ephemeritis_vsop_structs.h>
+#include <ephemeritis_vsop_data.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <errno.h>
@@ -132,36 +132,7 @@
 }
 
 
-/*! @brief De-allocates the space that was allocated for a series
- *  structure in memory.
- */
-static void destroy_series(series s)
-{
-  free(s.terms);
-}
 
-/*! @brief De-allocates the space that was allocated for a
- *  body_elements structure in memory.
- */
-static void destroy_body_elements(body_elements *b)
-{
-  int n;
-  for(n = 0; n < b->meta.num_variables; n++) {
-    vsop_variable *var = &b->variable_list[n];
-
-    int o;
-    for(o = 0; o < var->meta.series_count; o++) {
-      /* Destroy each series. */
-      destroy_series(var->series_list[o]);
-    }
-
-    /* Free the list of series for the variable. */
-    free(b->variable_list[n].series_list);
-  }
-  
-  free(b);
-}
-
 /*! @brief Allocates space for and builds a body_elements structure in
  *  memory, given an opened file to read from.
  */



From izogi at berlios.de  Mon Jan  9 11:05:00 2006
From: izogi at berlios.de (izogi at BerliOS)
Date: Mon, 9 Jan 2006 11:05:00 +0100
Subject: [Ephemeritis-svn] r203 - branches/new-vsop-prepare/src/c/utils
Message-ID: <200601091005.k09A50jw011104@sheep.berlios.de>

Author: izogi
Date: 2006-01-09 11:05:00 +0100 (Mon, 09 Jan 2006)
New Revision: 203

Modified:
   branches/new-vsop-prepare/src/c/utils/build_vsop_data.c
Log:
Committed changes that were accidentally unsaved in previous commit.


Modified: branches/new-vsop-prepare/src/c/utils/build_vsop_data.c
===================================================================
--- branches/new-vsop-prepare/src/c/utils/build_vsop_data.c	2006-01-09 10:03:09 UTC (rev 202)
+++ branches/new-vsop-prepare/src/c/utils/build_vsop_data.c	2006-01-09 10:05:00 UTC (rev 203)
@@ -86,53 +86,8 @@
 }
 
 
-static void print_body_elements(FILE *ostream, body_elements *b)
-{
-  fprintf(ostream, "Ephemeritis Version String: %s.\n", b->meta.eph_header_text);
-  fprintf(ostream, "Data for \"%s\".\n", b->meta.body_name);
-  fprintf(ostream, "%d variables overall.\n", b->meta.num_variables);
 
-  int v;
-  for(v=0; v<b->meta.num_variables; v++) {
-    vsop_variable *var = &(b->variable_list[v]);
-    fprintf(ostream, "\nVariable %d contains %d series':\n\n", v, var->meta.series_count);
 
-    int s;
-    for(s=0; s<var->meta.series_count; s++) {
-      series *ser = &var->series_list[s];
-      fprintf(ostream, "  Series %d has alpha %d and contains %d terms.\n", s, ser->meta.alpha, (ser->meta.num_terms));
-    }
-  }
-}
-
-/*! @brief Given an open output file and a body_elements structure,
- *  output the body elements in binary format.
- */
-static void write_body_elements(FILE *outfile, body_elements *b)
-{
-  /* Write the header data. */
-  fwrite(&b->meta, sizeof(b->meta), 1, outfile);
-
-  /* Loop through the variables, writing data of each one. */
-  int v;
-  for(v=0; v<b->meta.num_variables; v++) {
-    vsop_variable *var = &(b->variable_list[v]);
-    fwrite(&var->meta, sizeof(var->meta), 1, outfile);
-
-    /* Loop through the series variables, writing data of each one. */
-    int s;
-    for(s=0; s<var->meta.series_count; s++) {
-      series *ser = &var->series_list[s];
-      fwrite(&ser->meta, sizeof(ser->meta), 1, outfile);
-
-      /* Write the list of terms. */
-      fwrite(ser->terms, sizeof(*(ser->terms)), ser->meta.num_terms, outfile);
-    }
-  }
-}
-
-
-
 /*! @brief Allocates space for and builds a body_elements structure in
  *  memory, given an opened file to read from.
  */



From izogi at berlios.de  Tue Jan 10 06:25:28 2006
From: izogi at berlios.de (izogi at BerliOS)
Date: Tue, 10 Jan 2006 06:25:28 +0100
Subject: [Ephemeritis-svn] r204 - in branches/new-vsop-prepare/src/c: libephemeritis utils
Message-ID: <200601100525.k0A5PS5U002114@sheep.berlios.de>

Author: izogi
Date: 2006-01-10 06:25:26 +0100 (Tue, 10 Jan 2006)
New Revision: 204

Modified:
   branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.c
   branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.h
   branches/new-vsop-prepare/src/c/utils/build_vsop_data.c
Log:
Removed some typedefs from new vsop header code, and moved them to be anonymous structs inside other structs.


Modified: branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.c
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.c	2006-01-09 10:05:00 UTC (rev 203)
+++ branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.c	2006-01-10 05:25:26 UTC (rev 204)
@@ -26,6 +26,7 @@
 
 #include "ephemeritis_vsop_data.h"
 
+#include <stdlib.h>
 
 /*! @brief De-allocates the space that was allocated for a series
  *  structure in memory.
@@ -48,12 +49,10 @@
 {
   int n;
   for(n = 0; n < b->meta.num_variables; n++) {
-    vsop_variable *var = &b->variable_list[n];
-
     int o;
-    for(o = 0; o < var->meta.series_count; o++) {
+    for(o = 0; o < b->variable_list[n].meta.series_count; o++) {
       /* Destroy each series. */
-      destroy_series(var->series_list[o]);
+      destroy_series(b->variable_list[n].series_list[o]);
     }
 
     /* Free the list of series for the variable. */
@@ -77,12 +76,11 @@
 
   int v;
   for(v=0; v<b->meta.num_variables; v++) {
-    vsop_variable *var = &(b->variable_list[v]);
-    fprintf(ostream, "\nVariable %d contains %d series':\n\n", v, var->meta.series_count);
+    fprintf(ostream, "\nVariable %d contains %d series':\n\n", v, b->variable_list[v].meta.series_count);
 
     int s;
-    for(s=0; s<var->meta.series_count; s++) {
-      series *ser = &var->series_list[s];
+    for(s=0; s<b->variable_list[v].meta.series_count; s++) {
+      series *ser = &(b->variable_list[v].series_list[s]);
       fprintf(ostream, "  Series %d has alpha %d and contains %d terms.\n", s, ser->meta.alpha, (ser->meta.num_terms));
     }
   }
@@ -102,13 +100,12 @@
   /* Loop through the variables, writing data of each one. */
   int v;
   for(v=0; v<b->meta.num_variables; v++) {
-    vsop_variable *var = &(b->variable_list[v]);
-    fwrite(&var->meta, sizeof(var->meta), 1, outfile);
+    fwrite(&(b->variable_list[v].meta), sizeof(b->variable_list[v].meta), 1, outfile);
 
     /* Loop through the series variables, writing data of each one. */
     int s;
-    for(s=0; s<var->meta.series_count; s++) {
-      series *ser = &var->series_list[s];
+    for(s=0; s<b->variable_list[v].meta.series_count; s++) {
+      series *ser = &b->variable_list[v].series_list[s];
       fwrite(&ser->meta, sizeof(ser->meta), 1, outfile);
 
       /* Write the list of terms. */

Modified: branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.h
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.h	2006-01-09 10:05:00 UTC (rev 203)
+++ branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.h	2006-01-10 05:25:26 UTC (rev 204)
@@ -42,20 +42,20 @@
 
 
 typedef struct {
-  char alpha;          /*!< @brief The degree alpha of time variable for this series. */
-  short int num_terms; /*!< @brief The number of terms listed for this series. */
-} series_meta_bin;
-typedef struct {
-  series_meta_bin meta;/*!< @brief Binary meta data about the series'. */
+  struct {
+    char alpha;          /*!< @brief The degree alpha of time variable for this series. */
+    short int num_terms; /*!< @brief The number of terms listed for this series. */
+  } meta;
+
   term_bin *terms;     /*!< @brief The terms. */
 } series;
 
 
 typedef struct {
-  char series_count;   /*!< @brief The number of series' listed in the series_list field. */
-} vsop_variable_meta_bin;
-typedef struct {
-  vsop_variable_meta_bin meta; /*!< @brief Binary meta data about the VSOP variable. */
+  struct {
+    char series_count;   /*!< @brief The number of series' listed in the series_list field. */
+  } meta;
+
   series *series_list;         /*!< @brief The series'. */
 } vsop_variable;
 
@@ -72,7 +72,15 @@
  */
 typedef struct {
   body_elements_meta_bin meta;    /*!< Binary meta data about the body elements. */
-  vsop_variable variable_list[6]; /*!< The variables.                            */
+
+  struct {
+    struct {
+      char series_count;   /*!< @brief The number of series' listed in the series_list field. */
+    } meta;                /*!< @brief Binary meta data about the VSOP variable. */
+
+    series *series_list;         /*!< @brief The series'. */
+  } variable_list[6]; /*!< The variables.                            */
+
 } body_elements;
 
 

Modified: branches/new-vsop-prepare/src/c/utils/build_vsop_data.c
===================================================================
--- branches/new-vsop-prepare/src/c/utils/build_vsop_data.c	2006-01-09 10:05:00 UTC (rev 203)
+++ branches/new-vsop-prepare/src/c/utils/build_vsop_data.c	2006-01-10 05:25:26 UTC (rev 204)
@@ -127,20 +127,18 @@
     strncpy(body_el->meta.body_name, strtrim(ch_body_name, ch_body_name), sizeof(body_el->meta.body_name));
 
 
-    /* Find the current variable structure. */
-    vsop_variable *this_var = &(body_el->variable_list[variable_index]);
     if(variable_index+1 > body_el->meta.num_variables) {
       body_el->meta.num_variables = variable_index+1;
     }
 
 
     /* This is a series header, so add a new series to the variable. */
-    this_var->meta.series_count++;
+    body_el->variable_list[variable_index].meta.series_count++;
 
 
-    this_var->series_list = (series *)realloc(this_var->series_list, sizeof(series) * this_var->meta.series_count);
+    body_el->variable_list[variable_index].series_list = (series *)realloc(body_el->variable_list[variable_index].series_list, sizeof(series) * body_el->variable_list[variable_index].meta.series_count);
 
-    series *this_series = &(this_var->series_list[this_var->meta.series_count-1]);
+    series *this_series = &(body_el->variable_list[variable_index].series_list[body_el->variable_list[variable_index].meta.series_count-1]);
     this_series->meta.alpha = alpha;
     this_series->meta.num_terms = num_terms;
     this_series->terms = (term_bin *)calloc(num_terms, sizeof(term_bin));



From izogi at berlios.de  Tue Jan 10 10:54:07 2006
From: izogi at berlios.de (izogi at BerliOS)
Date: Tue, 10 Jan 2006 10:54:07 +0100
Subject: [Ephemeritis-svn] r205 - in branches/new-vsop-prepare: . data data/vsop src/c/libephemeritis src/c/utils
Message-ID: <200601100954.k0A9s7BJ025540@sheep.berlios.de>

Author: izogi
Date: 2006-01-10 10:54:05 +0100 (Tue, 10 Jan 2006)
New Revision: 205

Added:
   branches/new-vsop-prepare/data/
   branches/new-vsop-prepare/data/Makefile.am
   branches/new-vsop-prepare/data/vsop/
   branches/new-vsop-prepare/data/vsop/Makefile.am
Modified:
   branches/new-vsop-prepare/Makefile.am
   branches/new-vsop-prepare/config.h.in
   branches/new-vsop-prepare/configure.ac
   branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.c
   branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.h
   branches/new-vsop-prepare/src/c/utils/build_vsop_data.c
Log:
Removed obsolete structs from new vsop data header.
Wrote read_body_elements(), to read data from arch-dependent data files.
Played with autotools' files in an attempt to define another variable or two, for a user to specify where VSOP data will be located.  (Not complete.)


Modified: branches/new-vsop-prepare/Makefile.am
===================================================================
--- branches/new-vsop-prepare/Makefile.am	2006-01-10 05:25:26 UTC (rev 204)
+++ branches/new-vsop-prepare/Makefile.am	2006-01-10 09:54:05 UTC (rev 205)
@@ -1,5 +1,5 @@
 AUTOMAKE_OPTIONS = gnu
-SUBDIRS = src doc
+SUBDIRS = src data doc
 
 #TESTS = test.sh
 #TESTS_ENVIRONMENT = EXE_EXT=$(EXEEXT)

Modified: branches/new-vsop-prepare/config.h.in
===================================================================
--- branches/new-vsop-prepare/config.h.in	2006-01-10 05:25:26 UTC (rev 204)
+++ branches/new-vsop-prepare/config.h.in	2006-01-10 09:54:05 UTC (rev 205)
@@ -1,5 +1,17 @@
 /* config.h.in.  Generated from configure.ac by autoheader.  */
 
+/* Define to 1 if you have the `acos' function. */
+#undef HAVE_ACOS
+
+/* Define to 1 if you have the `asin' function. */
+#undef HAVE_ASIN
+
+/* Define to 1 if you have the `atan2' function. */
+#undef HAVE_ATAN2
+
+/* Define to 1 if you have the `cos' function. */
+#undef HAVE_COS
+
 /* Define to 1 if you have the <dlfcn.h> header file. */
 #undef HAVE_DLFCN_H
 
@@ -12,6 +24,9 @@
 /* Define to 1 if you have the `modf' function. */
 #undef HAVE_MODF
 
+/* Define to 1 if you have the `sin' function. */
+#undef HAVE_SIN
+
 /* Define to 1 if you have the `sqrt' function. */
 #undef HAVE_SQRT
 
@@ -36,6 +51,9 @@
 /* Define to 1 if you have the <sys/types.h> header file. */
 #undef HAVE_SYS_TYPES_H
 
+/* Define to 1 if you have the `tan' function. */
+#undef HAVE_TAN
+
 /* Define to 1 if you have the <unistd.h> header file. */
 #undef HAVE_UNISTD_H
 
@@ -66,5 +84,8 @@
 /* Version number of package */
 #undef VERSION
 
+/* The directory where the incoming VSOP text data is available. */
+#undef VSOPPATH
+
 /* Define to empty if `const' does not conform to ANSI C. */
 #undef const

Modified: branches/new-vsop-prepare/configure.ac
===================================================================
--- branches/new-vsop-prepare/configure.ac	2006-01-10 05:25:26 UTC (rev 204)
+++ branches/new-vsop-prepare/configure.ac	2006-01-10 09:54:05 UTC (rev 205)
@@ -1,4 +1,6 @@
-AC_INIT(src/c/libephemeritis/ephemeritis.h)
+AC_INIT(ephemeritis, 0.4.4)
+
+dnl AC_INIT(src/c/libephemeritis/ephemeritis.h)
 AC_CONFIG_AUX_DIR(config)
 
 DX_HTML_FEATURE(ON)
@@ -11,6 +13,7 @@
 DX_PS_FEATURE(OFF)
 
 AM_INIT_AUTOMAKE(ephemeritis, 0.4.4)
+
 AM_CONFIG_HEADER(config.h)
 
 DX_INIT_DOXYGEN(ephemeritis, doxygen.cfg)
@@ -24,6 +27,15 @@
 	esac], [debug=false])
 	AM_CONDITIONAL(DEBUG, test x$debug = xtrue)
 
+
+AC_ARG_WITH(	[vsop-data-dir],
+		AC_HELP_STRING([--with-vsop-data-dir], [Directory where VSOP data can be found.]),
+		vsop_data_dir=$withval,
+		vsop_data_dir=$datadir
+		)
+
+AC_DEFINE_UNQUOTED(VSOPPATH, "$vsop_data_dir", [The directory where the incoming VSOP text data is available.])
+
 AM_PROG_LIBTOOL
 
 dnl find and test the C++/C compiler
@@ -42,7 +54,7 @@
 AC_C_CONST
 AC_HEADER_STDBOOL
 
-AC_CHECK_FUNCS([modf sqrt])
+AC_CHECK_FUNCS([modf sqrt sin cos tan atan2 asin acos])
 
 dnl AC_CHECK_LIB(stdc++, main,  , AC_MSG_ERROR(libstdc++ is required))
 dnl AC_CHECK_HEADERS(exception map string vector list, , AC_MSG_ERROR(STL headers not found))
@@ -50,6 +62,8 @@
 
 AC_OUTPUT([
 	Makefile
+	data/Makefile
+	data/vsop/Makefile
 	doc/Makefile
 	doc/src-doxygen-main/Makefile
 	src/Makefile

Copied: branches/new-vsop-prepare/data/Makefile.am (from rev 196, branches/new-vsop-prepare/src/Makefile.am)
===================================================================
--- branches/new-vsop-prepare/src/Makefile.am	2006-01-08 09:14:38 UTC (rev 196)
+++ branches/new-vsop-prepare/data/Makefile.am	2006-01-10 09:54:05 UTC (rev 205)
@@ -0,0 +1,2 @@
+AUTOMAKE_OPTIONS = gnu
+SUBDIRS = vsop

Copied: branches/new-vsop-prepare/data/vsop/Makefile.am (from rev 196, branches/new-vsop-prepare/old-src/data/Makefile.am)
===================================================================
--- branches/new-vsop-prepare/old-src/data/Makefile.am	2006-01-08 09:14:38 UTC (rev 196)
+++ branches/new-vsop-prepare/data/vsop/Makefile.am	2006-01-10 09:54:05 UTC (rev 205)
@@ -0,0 +1,5 @@
+AUTOMAKE_OPTIONS = gnu
+
+pkgdata_DATA =
+EXTRA_DIST =
+

Modified: branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.c
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.c	2006-01-10 05:25:26 UTC (rev 204)
+++ branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.c	2006-01-10 09:54:05 UTC (rev 205)
@@ -45,7 +45,7 @@
  *  free()'d, as will the entire strucutre underneath it.  Ensure that
  *  nothing inside is referenced from elsewhere.
  */
-void destroy_body_elements(body_elements *b)
+void free_body_elements(body_elements *b)
 {
   int n;
   for(n = 0; n < b->meta.num_variables; n++) {
@@ -68,7 +68,7 @@
  *  @param[in] ostream A stream pointer to which the text should be printed.  (eg. stdin, stderr, or an open file.)
  *  @param[in] b       Pointer to the body elements.
  */
-void print_body_elements(FILE *ostream, body_elements *b)
+void print_body_statistics(FILE *ostream, body_elements *b)
 {
   fprintf(ostream, "Ephemeritis Version String: %s.\n", b->meta.eph_header_text);
   fprintf(ostream, "Data for \"%s\".\n", b->meta.body_name);
@@ -99,12 +99,12 @@
 
   /* Loop through the variables, writing data of each one. */
   int v;
-  for(v=0; v<b->meta.num_variables; v++) {
-    fwrite(&(b->variable_list[v].meta), sizeof(b->variable_list[v].meta), 1, outfile);
+  for(v = 0; v < b->meta.num_variables; v++) {
+    fwrite(&b->variable_list[v].meta, sizeof(b->variable_list[v].meta), 1, outfile);
 
     /* Loop through the series variables, writing data of each one. */
     int s;
-    for(s=0; s<b->variable_list[v].meta.series_count; s++) {
+    for(s = 0; s < b->variable_list[v].meta.series_count; s++) {
       series *ser = &b->variable_list[v].series_list[s];
       fwrite(&ser->meta, sizeof(ser->meta), 1, outfile);
 
@@ -114,3 +114,48 @@
   }
 }
 
+
+/*! @brief Given an open input file and a body_elements structure,
+ *  read the body elements from binary format.
+ *
+ *  @param[in] infile An open file from which the data should be
+ *  read. The file should be set to the beginning of its data, and is
+ *  not closed after the operation.
+ *
+ *  @return           Pointer to the body elements that have been read.
+ */
+body_elements *read_body_elements(FILE *infile)
+{
+  body_elements *b;
+
+  /* Allocate memory for the body_elements. */
+  b = (body_elements *)malloc(sizeof(body_elements));
+
+  /* Read the header data. */
+  fread(&b->meta, sizeof(b->meta), 1, infile);
+
+  /* Loop through the variables, reading data for each one. */
+  int v;
+  for(v = 0; v < b->meta.num_variables; v++) {
+    fread(&b->variable_list[v].meta, sizeof(b->variable_list[v].meta), 1, infile);
+
+    /* Allocate memory to hold the list of series' for this variable. */
+    b->variable_list[v].series_list = (series *)calloc(b->variable_list[v].meta.series_count, sizeof(series));
+
+    /* Loop through the series variables, reading data from each one. */
+    int s;
+    for(s = 0; s < b->variable_list[v].meta.series_count; s++) {
+      /* Read meta data for this series. */
+      series *ser = &b->variable_list[v].series_list[s];
+      fread(&ser->meta, sizeof(ser->meta), 1, infile);
+
+      /* Allocate memory for the terms. */
+      ser->terms = (term_bin *)calloc(ser->meta.num_terms, sizeof(term_bin));
+
+      /* Read the list of terms. */
+      fread(ser->terms, sizeof(*(ser->terms)), ser->meta.num_terms, infile);
+    }
+  }
+
+  return b;
+}

Modified: branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.h
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.h	2006-01-10 05:25:26 UTC (rev 204)
+++ branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.h	2006-01-10 09:54:05 UTC (rev 205)
@@ -51,27 +51,18 @@
 } series;
 
 
-typedef struct {
-  struct {
-    char series_count;   /*!< @brief The number of series' listed in the series_list field. */
-  } meta;
-
-  series *series_list;         /*!< @brief The series'. */
-} vsop_variable;
-
 #define EPHEMERITIS_BIN_HEADER_TEXT_FORMAT "EphB v=%s"
 
-typedef struct{
-  char eph_header_text[23]; /*!< @brief Ephemeritis header text.                            */
-  char body_name[8];        /*!< @brief The name of the body represented by these elements. */
-  char num_variables;       /*!< @brief The number of variables included in these elements. */
-} body_elements_meta_bin;
 
 /*! @brief Collects together a particular set of elements for a
  *  particular body.
  */
 typedef struct {
-  body_elements_meta_bin meta;    /*!< Binary meta data about the body elements. */
+  struct{
+    char eph_header_text[23]; /*!< @brief Ephemeritis header text.                            */
+    char body_name[8];        /*!< @brief The name of the body represented by these elements. */
+    char num_variables;       /*!< @brief The number of variables included in these elements. */
+  } meta;
 
   struct {
     struct {
@@ -84,9 +75,10 @@
 } body_elements;
 
 
-void destroy_body_elements(body_elements *b);
-void print_body_elements(FILE *ostream, body_elements *b);
+void print_body_statistics(FILE *ostream, body_elements *b);
 void write_body_elements(FILE *outfile, body_elements *b);
+body_elements *read_body_elements(FILE *infile);
+void free_body_elements(body_elements *b);
 
 
 #endif

Modified: branches/new-vsop-prepare/src/c/utils/build_vsop_data.c
===================================================================
--- branches/new-vsop-prepare/src/c/utils/build_vsop_data.c	2006-01-10 05:25:26 UTC (rev 204)
+++ branches/new-vsop-prepare/src/c/utils/build_vsop_data.c	2006-01-10 09:54:05 UTC (rev 205)
@@ -188,7 +188,7 @@
   */
   write_body_elements(outfile, body_el);
 
-  destroy_body_elements(body_el);
+  free_body_elements(body_el);
 
   /* Close files. */
   if(infile != stdin) {
@@ -201,6 +201,22 @@
   return 0;
 }
 
+/*
+void check_data(char *input_file)
+{
+  FILE *infile;
+  if(NULL == (infile = fopen(input_file, "r"))) {
+    fprintf(stderr, "Something strange happened...\n%s: %s\n", input_file, strerror(errno));
+    return 3;
+  }
+
+  printf("Testing output for file: %s", input_file);
+  body_elements *b = read_body_elements(infile);
+  print_body_statistics(stdout, b);
+
+  fclose(infile);
+}
+*/
 int main(int argc, char *argv[])
 {
   if(3 != argc) {
@@ -211,5 +227,9 @@
   }
   char* input_file = argv[1];
   char* output_file = argv[2];
-  return process_streams(input_file, output_file);
+  int result = process_streams(input_file, output_file);
+  /*
+  check_data(output_file);
+  */
+  return result;
 }



From izogi at berlios.de  Wed Jan 11 11:13:43 2006
From: izogi at berlios.de (izogi at BerliOS)
Date: Wed, 11 Jan 2006 11:13:43 +0100
Subject: [Ephemeritis-svn] r207 - in branches/new-vsop-prepare/src/c: libephemeritis tests
Message-ID: <200601111013.k0BADhZf016590@sheep.berlios.de>

Author: izogi
Date: 2006-01-11 11:13:43 +0100 (Wed, 11 Jan 2006)
New Revision: 207

Modified:
   branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.c
   branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.h
   branches/new-vsop-prepare/src/c/tests/validate_meeus.c
Log:
Created the vsop_body type to replace vPlanets, which had been borrowed from the old VSOP code.


Modified: branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.c
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.c	2006-01-11 09:45:16 UTC (rev 206)
+++ branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.c	2006-01-11 10:13:43 UTC (rev 207)
@@ -221,7 +221,7 @@
  *
  *  @return true if the data was loaded and returned, otherwise false.
  */
-static bool get_vsop_handle(const enum vPlanets planet, const vsop_version version, vsop_handle *h)
+static bool get_vsop_handle(const vsop_body planet, const vsop_version version, vsop_handle *h)
 {
   int n;
   for(n = 0; n < vhw_list_size; n++) {
@@ -241,9 +241,9 @@
 
 
 typedef struct {
-  enum vPlanets p;
+  vsop_body p;
   char *str;
-} vPlanets_str_map_type;
+} body_str_map_type;
 
 static version_str_map_type version_str_map[] = {
   {hel_ell_j2,   EPH_VSOP_HEJ2},
@@ -265,25 +265,25 @@
   return NULL;
 }
 
-static vPlanets_str_map_type vPlanets_str_map[] = {
-  {vMercury, EPH_MER},
-  {vVenus,   EPH_VEN},
-  {vEarth,   EPH_EAR},
-  {vMars,    EPH_MAR},
-  {vJupiter, EPH_JUP},
-  {vSaturn,  EPH_SAT},
-  {vUranus,  EPH_URA},
-  {vNeptune, EPH_NEP},
-  {vSun,     EPH_SOL},
-  {vEMB,     EPH_EMB}
+static body_str_map_type body_str_map[] = {
+  {vsop_mercury, EPH_MER},
+  {vsop_venus,   EPH_VEN},
+  {vsop_earth,   EPH_EAR},
+  {vsop_mars,    EPH_MAR},
+  {vsop_jupiter, EPH_JUP},
+  {vsop_saturn,  EPH_SAT},
+  {vsop_uranus,  EPH_URA},
+  {vsop_neptune, EPH_NEP},
+  {vsop_sun,     EPH_SOL},
+  {vsop_EMB,     EPH_EMB}
 };
 
-static char *planet_map_lookup(enum vPlanets p)
+static char *planet_map_lookup(vsop_body p)
 {
   int n;
-  for(n = 0; n < sizeof(vPlanets_str_map) / sizeof(*vPlanets_str_map); n++) {
-    if(p == vPlanets_str_map[n].p) {
-      return vPlanets_str_map[n].str;
+  for(n = 0; n < sizeof(body_str_map) / sizeof(*body_str_map); n++) {
+    if(p == body_str_map[n].p) {
+      return body_str_map[n].str;
     }
   }
   return NULL;
@@ -291,7 +291,7 @@
 
 /* Assumes that the handle isn't already loaded, and that the data in
    the file isn't corrupt, so use with care. */
-static bool load_vsop_handle(const enum vPlanets planet, const vsop_version version, vsop_handle *vh)
+static bool load_vsop_handle(const vsop_body planet, const vsop_version version, vsop_handle *vh)
 {
   /* Construct the filename. */
   char filename[512];
@@ -352,16 +352,14 @@
  *
  *  @return true if the requested data was available (and returned), false otherwise.
  */
-bool get_vsop_data_handle(const enum vPlanets planet, const vsop_version version, vsop_handle *vh)
+bool get_vsop_data_handle(const vsop_body planet, const vsop_version version, vsop_handle *vh)
 {
   /* Check to see if the data for this planet/series is already loaded. */
   if(get_vsop_handle(planet, version, vh)) {
     /* If so, return the handle.       */
-    printf("Found it early -- saving time.\n");
     return true;
   } else {
     /* If not, load it, then return it. */
-    printf("Oops -- loading from disk.\n");
     return load_vsop_handle(planet, version, vh);
   }
 }

Modified: branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.h
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.h	2006-01-11 09:45:16 UTC (rev 206)
+++ branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.h	2006-01-11 10:13:43 UTC (rev 207)
@@ -37,7 +37,25 @@
 
 #include <stdio.h>
 
+/*! @brief A list of bodies recognised by the VSOP model.
+ */
 typedef enum {
+  vsop_mercury,			/*!< @brief Mercury */
+  vsop_venus,			/*!< @brief Venus   */
+  vsop_earth,			/*!< @brief Earth   */
+  vsop_mars,			/*!< @brief Mars    */
+  vsop_jupiter,			/*!< @brief Jupiter */
+  vsop_saturn,			/*!< @brief Saturn  */
+  vsop_uranus,			/*!< @brief Uranus  */
+  vsop_neptune,			/*!< @brief Neptune */
+  
+  vsop_sun,                     /*!< @brief Sun                   */
+  vsop_EMB                      /*!< @brief Earth-Moon barycentre */
+} vsop_body;
+
+/*! @brief A list of versions available for the VSOP model.
+ */
+typedef enum {
     hel_ell_j2,			/*!< @brief Heliocentric Elliptic Elements J2000       */
     hel_rec_j2,			/*!< @brief Heliocentric Rectangular Variables J2000   */
     hel_sph_j2,			/*!< @brief Heliocentric Spherical Variables J2000     */
@@ -46,10 +64,11 @@
     bar_rec_j2                  /*!< @brief Barycentric Rectangular Variables J2000    */
 } vsop_version;
 
+
 /*! @brief A user-available structure to refer to VSOP data.
  */
 typedef struct {
-  enum vPlanets planet; /*!< @brief The planet to which this data relates.  */
+  vsop_body planet;     /*!< @brief The planet to which this data relates.  */
   vsop_version version; /*!< @brief The series which this data is for.      */
 
   int data_id;          /*!< @brief An internally recognised data identifier to identify where the data is held. */
@@ -57,7 +76,7 @@
 
 void vsop_data_init();
 void vsop_data_cleanup();
-bool get_vsop_data_handle(const enum vPlanets planet, const vsop_version version, vsop_handle *vh);
+bool get_vsop_data_handle(const vsop_body planet, const vsop_version version, vsop_handle *vh);
 
 
 

Modified: branches/new-vsop-prepare/src/c/tests/validate_meeus.c
===================================================================
--- branches/new-vsop-prepare/src/c/tests/validate_meeus.c	2006-01-11 09:45:16 UTC (rev 206)
+++ branches/new-vsop-prepare/src/c/tests/validate_meeus.c	2006-01-11 10:13:43 UTC (rev 207)
@@ -1144,16 +1144,16 @@
 
       vsop_handle vh;
       bool result;
-      result = get_vsop_data_handle(vMercury, hel_rec_date, &vh);
+      result = get_vsop_data_handle(vsop_mercury, hel_rec_date, &vh);
       printf("%d\n", vh.data_id);
 
-      result = get_vsop_data_handle(vVenus, hel_rec_date, &vh);
+      result = get_vsop_data_handle(vsop_venus, hel_rec_date, &vh);
       printf("%d\n", vh.data_id);
 
-      result = get_vsop_data_handle(vEarth, hel_rec_date, &vh);
+      result = get_vsop_data_handle(vsop_earth, hel_rec_date, &vh);
       printf("%d\n", vh.data_id);
 
-      result = get_vsop_data_handle(vMercury, hel_rec_date, &vh);
+      result = get_vsop_data_handle(vsop_mercury, hel_rec_date, &vh);
       printf("%d\n", vh.data_id);
 
       if(result) {



From izogi at berlios.de  Wed Jan 11 10:45:17 2006
From: izogi at berlios.de (izogi at BerliOS)
Date: Wed, 11 Jan 2006 10:45:17 +0100
Subject: [Ephemeritis-svn] r206 - in branches/new-vsop-prepare/src: . c/libephemeritis c/tests
Message-ID: <200601110945.k0B9jHJj013795@sheep.berlios.de>

Author: izogi
Date: 2006-01-11 10:45:16 +0100 (Wed, 11 Jan 2006)
New Revision: 206

Removed:
   branches/new-vsop-prepare/src/data/
Modified:
   branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis.h
   branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.c
   branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.h
   branches/new-vsop-prepare/src/c/tests/validate_meeus.c
Log:
Wrote code to load data from disk and place it in an encapsulated cache.
Client code can request a vsop_handle for a particular planet and VSOP
version -- the code will first check the cache to see if it's already there,
and return that handle if it is.  If not, it'll attempt to load it from
disk.



Modified: branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis.h
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis.h	2006-01-10 09:54:05 UTC (rev 205)
+++ branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis.h	2006-01-11 09:45:16 UTC (rev 206)
@@ -63,7 +63,10 @@
     vJupiter,			/*!< @brief Jupiter */
     vSaturn,			/*!< @brief Saturn  */
     vUranus,			/*!< @brief Uranus  */
-    vNeptune			/*!< @brief Neptune */
+    vNeptune,			/*!< @brief Neptune */
+
+    vSun,                       /*!< @brief Sun                   */
+    vEMB                        /*!< @brief Earth-Moon barycentre */
 };
 
 /*! @brief Contains a list of seasons.

Modified: branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.c
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.c	2006-01-10 09:54:05 UTC (rev 205)
+++ branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.c	2006-01-11 09:45:16 UTC (rev 206)
@@ -25,8 +25,11 @@
  */
 
 #include "ephemeritis_vsop_data.h"
+#include "ephemeritis.h"
 
 #include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
 
 /*! @brief De-allocates the space that was allocated for a series
  *  structure in memory.
@@ -123,6 +126,10 @@
  *  not closed after the operation.
  *
  *  @return           Pointer to the body elements that have been read.
+ *
+ *  @bug Doesn't indicate if there was an error, such as corrupted
+ *  data.  What should properly happen is that the function should
+ *  clean up whatever memory mess it's caused, and return NULL.
  */
 body_elements *read_body_elements(FILE *infile)
 {
@@ -159,3 +166,202 @@
 
   return b;
 }
+
+
+
+
+
+/*! @brief Internal struct to hold id data about a vsop_handle.
+ */
+typedef struct {
+  vsop_handle h;
+  body_elements *be;
+} vsop_handle_wrapper;
+
+static vsop_handle_wrapper *vhw_list = NULL;
+static int vhw_list_size = 0;
+static int next_data_id = 1;
+
+/*! @brief Initialise the VSOP data handling functionality.  This
+    should be called before using any VSOP data handling routines.
+ *
+ *  Calling this function initialises all the internal memory handling
+ *  overheads, and so on.
+ */
+void vsop_data_init()
+{
+  vhw_list = NULL;
+  vhw_list_size = 0;
+}
+
+/*! @brief Cleans up the VSOP data handling functionality.  This
+ *  should be called after using any VSOP data handling routines.
+ *
+ *  Calling this function cleans up all the internal memory handling
+ *  overheads, and so on.
+ */
+void vsop_data_cleanup()
+{
+  /* Loop through every loaded data set, and release it. */
+
+  /* Release the list, and re-initialise the meta variables. */
+  free(vhw_list);
+  vhw_list = NULL;
+  vhw_list_size = 0;
+}
+
+
+/*! @brief Check to see if data matching that requested is already in
+ *  memory.  If so, copy it to an output variable, and return true.
+ *
+ *  @param[in] planet  The planet being requested.
+ *  @param[in] version The version of the VSOP data being requested.
+ *
+ *  @param[out] h      A location where the vsop_handle data for the requested planet and version will be copied.
+ *
+ *  @return true if the data was loaded and returned, otherwise false.
+ */
+static bool get_vsop_handle(const enum vPlanets planet, const vsop_version version, vsop_handle *h)
+{
+  int n;
+  for(n = 0; n < vhw_list_size; n++) {
+    if(planet == vhw_list[n].h.planet && version == vhw_list[n].h.version) {
+      *h = vhw_list[n].h;
+      return true;
+    }
+  }
+  return false;
+}
+
+
+typedef struct {
+  vsop_version v;
+  char *str;
+} version_str_map_type;
+
+
+typedef struct {
+  enum vPlanets p;
+  char *str;
+} vPlanets_str_map_type;
+
+static version_str_map_type version_str_map[] = {
+  {hel_ell_j2,   EPH_VSOP_HEJ2},
+  {hel_rec_j2,   EPH_VSOP_HRJ2},
+  {hel_sph_j2,   EPH_VSOP_HSJ2},
+  {hel_rec_date, EPH_VSOP_HRD },
+  {hel_sph_date, EPH_VSOP_HSD },
+  {bar_rec_j2,   EPH_VSOP_BRJ2}
+};
+
+static char *version_map_lookup(vsop_version v)
+{
+  int n;
+  for(n = 0; n < sizeof(version_str_map) / sizeof(*version_str_map); n++) {
+    if(v == version_str_map[n].v) {
+      return version_str_map[n].str;
+    }
+  }
+  return NULL;
+}
+
+static vPlanets_str_map_type vPlanets_str_map[] = {
+  {vMercury, EPH_MER},
+  {vVenus,   EPH_VEN},
+  {vEarth,   EPH_EAR},
+  {vMars,    EPH_MAR},
+  {vJupiter, EPH_JUP},
+  {vSaturn,  EPH_SAT},
+  {vUranus,  EPH_URA},
+  {vNeptune, EPH_NEP},
+  {vSun,     EPH_SOL},
+  {vEMB,     EPH_EMB}
+};
+
+static char *planet_map_lookup(enum vPlanets p)
+{
+  int n;
+  for(n = 0; n < sizeof(vPlanets_str_map) / sizeof(*vPlanets_str_map); n++) {
+    if(p == vPlanets_str_map[n].p) {
+      return vPlanets_str_map[n].str;
+    }
+  }
+  return NULL;
+}
+
+/* Assumes that the handle isn't already loaded, and that the data in
+   the file isn't corrupt, so use with care. */
+static bool load_vsop_handle(const enum vPlanets planet, const vsop_version version, vsop_handle *vh)
+{
+  /* Construct the filename. */
+  char filename[512];
+  strncpy(filename, EPH_VSOP_DATA_PATH, 512);
+  strncat(filename, EPH_VSOP_PREFIX, 512);
+  strncat(filename, version_map_lookup(version), 512);
+  strncat(filename, ".", 512);
+  strncat(filename, planet_map_lookup(planet), 512);
+  strncat(filename, EPH_VSOP_SUFFIX, 512);
+  filename[511] = '\0';
+
+  /* Try to open the file. */
+  FILE *f;
+  if(NULL == (f = fopen(filename, "rb"))) {
+    /* File didn't open for some reason.  Probably not there. */
+    return false;
+  }
+
+  /* Attempt to read data from the file. */
+  body_elements *be = read_body_elements(f);
+
+
+  /* Note that there's no checking to make sure the file was loaded successfully.  This is bad. */
+
+
+  /* Close the file. */
+  fclose(f);
+
+  /* Allocate more space in the list of vsop handle wrappers. */
+  vhw_list = (vsop_handle_wrapper *)realloc(vhw_list, ++vhw_list_size * sizeof(vsop_handle_wrapper));
+
+  vhw_list[vhw_list_size-1].be = be;
+  vhw_list[vhw_list_size-1].h.data_id = next_data_id++;
+  vhw_list[vhw_list_size-1].h.planet = planet;
+  vhw_list[vhw_list_size-1].h.version = version;
+
+  *vh = vhw_list[vhw_list_size-1].h;
+  return true;
+}
+
+/*! @brief Returns a handle for accessing available VSOP data.
+ *
+ *  Data is stored in files on disk, with each file containing data
+ *  for a particular planet and a version.  Ephemeritis keeps an
+ *  internal cache of data that's already been loaded, and the cache
+ *  will be checked first to see if a handle for the data is already
+ *  available.  If it's not loaded already, the function will attempt
+ *  to load the data from the file.
+ *
+ *  Note that data may not always be available.  It might not be
+ *  installed (with the data file not being available), or the
+ *  combination of planet and version might not make sense.
+ *
+ *  @param[in] planet  The planet for which the data is being requested.
+ *  @param[in] version The version of VSOP data being requested.
+ *
+ *  @param[out] vh  A location to place the vsop_handle, if it's available.
+ *
+ *  @return true if the requested data was available (and returned), false otherwise.
+ */
+bool get_vsop_data_handle(const enum vPlanets planet, const vsop_version version, vsop_handle *vh)
+{
+  /* Check to see if the data for this planet/series is already loaded. */
+  if(get_vsop_handle(planet, version, vh)) {
+    /* If so, return the handle.       */
+    printf("Found it early -- saving time.\n");
+    return true;
+  } else {
+    /* If not, load it, then return it. */
+    printf("Oops -- loading from disk.\n");
+    return load_vsop_handle(planet, version, vh);
+  }
+}

Modified: branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.h
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.h	2006-01-10 09:54:05 UTC (rev 205)
+++ branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.h	2006-01-11 09:45:16 UTC (rev 206)
@@ -17,23 +17,84 @@
 Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
 
-#ifndef _ephemeritis_vsop_structs_h_
-#define _ephemeritis_vsop_structs_h_
+#ifndef _ephemeritis_vsop_data_h_
+#define _ephemeritis_vsop_data_h_
 
-/*! @file ephemeritis_vsop_structs.h
+/*! @file ephemeritis_vsop_data.h
  *
- * Type definitions for VSOP data structures.  This list is included
- * by various parts of the code and utilities to allow them to share
- * commonly understood data structures.
+ * Definitions for VSOP data and related functions.  This list is
+ * included by various parts of the code and utilities to allow them
+ * to share commonly understood data structures.
  *
  * @todo Document the structures.
+ * @todo Figure out which parts of this should be available everywhere, and which parts should be internal to the data-handling code (in a separate header file).
+ * @todo Update EPHEMERITIS_VSOP_DATA_PATH to make it configurable by the user at installation time.
  *
  * @author Mike McGavin.
  */
 
+#include "ephemeritis.h"
+
 #include <stdio.h>
 
+typedef enum {
+    hel_ell_j2,			/*!< @brief Heliocentric Elliptic Elements J2000       */
+    hel_rec_j2,			/*!< @brief Heliocentric Rectangular Variables J2000   */
+    hel_sph_j2,			/*!< @brief Heliocentric Spherical Variables J2000     */
+    hel_rec_date,		/*!< @brief Heliocentric Rectangular Variables of date */
+    hel_sph_date,		/*!< @brief Heliocentric Spherical Variables of date   */
+    bar_rec_j2                  /*!< @brief Barycentric Rectangular Variables J2000    */
+} vsop_version;
 
+/*! @brief A user-available structure to refer to VSOP data.
+ */
+typedef struct {
+  enum vPlanets planet; /*!< @brief The planet to which this data relates.  */
+  vsop_version version; /*!< @brief The series which this data is for.      */
+
+  int data_id;          /*!< @brief An internally recognised data identifier to identify where the data is held. */
+} vsop_handle;
+
+void vsop_data_init();
+void vsop_data_cleanup();
+bool get_vsop_data_handle(const enum vPlanets planet, const vsop_version version, vsop_handle *vh);
+
+
+
+
+
+#define EPHEMERITIS_BIN_HEADER_TEXT_FORMAT "EphB v=%s"
+
+/* Define data path -- this should be updated to something configurable. */
+#define EPH_VSOP_DATA_PATH "/home/izogi/ephemeritis/branches/new-vsop-prepare/data/vsop/"
+
+/* Start with... */
+#define EPH_VSOP_PREFIX    "VSOP87"
+
+/* Add one of... */
+#define EPH_VSOP_HEJ2      ""
+#define EPH_VSOP_HRJ2      "A"
+#define EPH_VSOP_HSJ2      "B"
+#define EPH_VSOP_HRD       "C"
+#define EPH_VSOP_HSD       "D"
+#define EPH_VSOP_BRJ2      "E"
+
+/* Followed by... */
+#define EPH_MER  "mer"
+#define EPH_VEN  "ven"
+#define EPH_EAR  "ear"
+#define EPH_MAR  "mar"
+#define EPH_JUP  "jup"
+#define EPH_SAT  "sat"
+#define EPH_URA  "ura"
+#define EPH_NEP  "nep"
+
+#define EPH_SOL  "sun"
+#define EPH_EMB  "emb"
+
+/* The suffix for binary files. */
+#define EPH_VSOP_SUFFIX    ".eph.bin"
+
 /*! @brief Represents a VSOP87 term.
  */
 typedef struct {
@@ -51,9 +112,7 @@
 } series;
 
 
-#define EPHEMERITIS_BIN_HEADER_TEXT_FORMAT "EphB v=%s"
 
-
 /*! @brief Collects together a particular set of elements for a
  *  particular body.
  */
@@ -81,4 +140,5 @@
 void free_body_elements(body_elements *b);
 
 
+
 #endif

Modified: branches/new-vsop-prepare/src/c/tests/validate_meeus.c
===================================================================
--- branches/new-vsop-prepare/src/c/tests/validate_meeus.c	2006-01-10 09:54:05 UTC (rev 205)
+++ branches/new-vsop-prepare/src/c/tests/validate_meeus.c	2006-01-11 09:45:16 UTC (rev 206)
@@ -53,6 +53,7 @@
  */
 
 #include <ephemeritis.h>
+#include <ephemeritis_vsop_data.h>
 
 #include <stdio.h>
 #include <math.h>
@@ -1135,6 +1136,35 @@
 	    report("Magnitude", mag, test->mag, 1.0, "");
 	}
     }
+
+
+    printf("\n\nPlaying with new VSOP methods:\n");
+    {
+      vsop_data_init();
+
+      vsop_handle vh;
+      bool result;
+      result = get_vsop_data_handle(vMercury, hel_rec_date, &vh);
+      printf("%d\n", vh.data_id);
+
+      result = get_vsop_data_handle(vVenus, hel_rec_date, &vh);
+      printf("%d\n", vh.data_id);
+
+      result = get_vsop_data_handle(vEarth, hel_rec_date, &vh);
+      printf("%d\n", vh.data_id);
+
+      result = get_vsop_data_handle(vMercury, hel_rec_date, &vh);
+      printf("%d\n", vh.data_id);
+
+      if(result) {
+	printf("Loaded okay\n");
+      } else {
+	printf("File didn't load for some reason\n");
+      }
+
+      vsop_data_cleanup();
+    }
+
 }
 
 int main(int argc, char *argv[])



From izogi at berlios.de  Fri Jan 13 11:35:11 2006
From: izogi at berlios.de (izogi at BerliOS)
Date: Fri, 13 Jan 2006 11:35:11 +0100
Subject: [Ephemeritis-svn] r208 - branches/new-vsop-prepare/src/c/libephemeritis
Message-ID: <200601131035.k0DAZBbH019398@sheep.berlios.de>

Author: izogi
Date: 2006-01-13 11:35:10 +0100 (Fri, 13 Jan 2006)
New Revision: 208

Modified:
   branches/new-vsop-prepare/src/c/libephemeritis/Makefile.am
   branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.c
   branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.h
Log:
Re-wrote more VSOP code based around loking up data, mapping certain bits of data with meta data, and abstracting the inner workings from the front end.
Wrote vsop_get_rectangular() and vsop_rec_vsop_to_fk5(), both of which work with vsop_handles to reference data, and will return errors if the data source doesn't match the requested function.


Modified: branches/new-vsop-prepare/src/c/libephemeritis/Makefile.am
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/Makefile.am	2006-01-11 10:13:43 UTC (rev 207)
+++ branches/new-vsop-prepare/src/c/libephemeritis/Makefile.am	2006-01-13 10:35:10 UTC (rev 208)
@@ -22,6 +22,7 @@
 	riseset.c \
 	separation.c \
 	solar.c \
+	vsop_calculate.c \
 	vsopdata.c \
 	vsop87d.c \
 	util.c

Modified: branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.c
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.c	2006-01-11 10:13:43 UTC (rev 207)
+++ branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.c	2006-01-13 10:35:10 UTC (rev 208)
@@ -121,11 +121,11 @@
 /*! @brief Given an open input file and a body_elements structure,
  *  read the body elements from binary format.
  *
- *  @param[in] infile An open file from which the data should be
- *  read. The file should be set to the beginning of its data, and is
- *  not closed after the operation.
+ *  @param[in] infile  An open file from which the data should be
+ *                     read. The file should be set to the beginning of its data, and is
+ *                     not closed after the operation.
  *
- *  @return           Pointer to the body elements that have been read.
+ *  @return            Pointer to the body elements that have been read.
  *
  *  @bug Doesn't indicate if there was an error, such as corrupted
  *  data.  What should properly happen is that the function should
@@ -363,3 +363,30 @@
     return load_vsop_handle(planet, version, vh);
   }
 }
+
+/*! @brief Maps a specified vsop_handle to the loaded body elements that it represents.
+ *
+ *  Given a vsop_handle (which is abstract from the loaded data), this
+ *  function locates the body_elements structure to which the handle
+ *  maps.
+ *
+ *  @param[in] vh The handle that represents the elements to search for.
+ *
+ *  @return A pointer to a structure containing the elements
+ *  associated with the specified vsop_handle, if it exists.
+ *  Otherwise NULL.
+ *
+ */
+body_elements *get_body_elements_for_handle(const vsop_handle vh)
+{
+  int n;
+  for(n = 0; n < vhw_list_size; n++) {
+    if(vh.data_id == vhw_list[n].h.data_id) {
+      /* Found the handle, so return its associated body_elements structure. */
+      return vhw_list[n].be;
+    }
+  }
+
+  /* The handle wasn't found in the list of loaded data, so return NULL. */
+  return NULL;
+}

Modified: branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.h
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.h	2006-01-11 10:13:43 UTC (rev 207)
+++ branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.h	2006-01-13 10:35:10 UTC (rev 208)
@@ -74,11 +74,33 @@
   int data_id;          /*!< @brief An internally recognised data identifier to identify where the data is held. */
 } vsop_handle;
 
+/*! @brief A struct to hold rectangular coordinates from a particular calculation.
+ */
+typedef struct {
+  vsop_handle vh;       /*!< @brief The VSOP handle representing the data these coordinates were calculated from. */
+  double jd;            /*!< @brief The Julian Date of these coordinates, in dynamical time.                      */
+  rec_coords rc;        /*!< @brief The XYZ coordinates.                                                          */
+  int error_state;      /*!< @brief The state of these coordinates,
+                                    indicating if they're okay to use.
+                                    Note that this field is only valid
+                                    once the struct values have been
+                                    calculated at least once.
+
+				    0 indicates no error.
+				    -1 (vsop_get_rectangular) indicates a vsop_handle error.  (Data referenced by this handle wasn't found - perhaps it was unloaded.)
+				    -2 (vsop_get_rectangular) indicates that a vsop_handle referenced data not suitable for providing rectangular coordinates.
+				    -3 (vsop_rec_vsop_to_fk5) indicates that supplied coordinates were unsuitable for converting to FK5.
+			*/
+} vsop_rec_coords;
+
 void vsop_data_init();
 void vsop_data_cleanup();
 bool get_vsop_data_handle(const vsop_body planet, const vsop_version version, vsop_handle *vh);
+vsop_rec_coords vsop_get_rectangular(const vsop_handle vh, const double jd);
+vsop_rec_coords vsop_rec_vsop_to_fk5(vsop_rec_coords vrc);
 
 
+/* Stuff below here should probably be in a header file that's local to the internal code. */
 
 
 
@@ -142,13 +164,16 @@
     char num_variables;       /*!< @brief The number of variables included in these elements. */
   } meta;
 
+/*   vsop_body planet;           /\*!< @brief The body for which these elements are designated.   *\/ */
+/*   vsop_version version;       /\*!< @brief The version that these elements will calculate.     *\/ */
+
   struct {
     struct {
       char series_count;   /*!< @brief The number of series' listed in the series_list field. */
-    } meta;                /*!< @brief Binary meta data about the VSOP variable. */
+    } meta;                /*!< @brief Binary meta data about the VSOP variable.              */
 
-    series *series_list;         /*!< @brief The series'. */
-  } variable_list[6]; /*!< The variables.                            */
+    series *series_list;   /*!< @brief The series list.                   */
+  } variable_list[6];      /*!< @brief The variables.                     */
 
 } body_elements;
 
@@ -157,7 +182,7 @@
 void write_body_elements(FILE *outfile, body_elements *b);
 body_elements *read_body_elements(FILE *infile);
 void free_body_elements(body_elements *b);
+body_elements *get_body_elements_for_handle(const vsop_handle vh);
 
 
-
 #endif



From izogi at berlios.de  Sat Jan 14 05:29:17 2006
From: izogi at berlios.de (izogi at BerliOS)
Date: Sat, 14 Jan 2006 05:29:17 +0100
Subject: [Ephemeritis-svn] r209 - in branches/new-vsop-prepare/src/c: libephemeritis tests
Message-ID: <200601140429.k0E4THc0020016@sheep.berlios.de>

Author: izogi
Date: 2006-01-14 05:29:13 +0100 (Sat, 14 Jan 2006)
New Revision: 209

Modified:
   branches/new-vsop-prepare/src/c/libephemeritis/Makefile.am
   branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.h
   branches/new-vsop-prepare/src/c/tests/validate_meeus.c
Log:
Wrote code for getting VSOP spherical coordinates, and began a new vsop_to_fk5 function for spherical coordinates.


Modified: branches/new-vsop-prepare/src/c/libephemeritis/Makefile.am
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/Makefile.am	2006-01-13 10:35:10 UTC (rev 208)
+++ branches/new-vsop-prepare/src/c/libephemeritis/Makefile.am	2006-01-14 04:29:13 UTC (rev 209)
@@ -1,6 +1,6 @@
 AUTOMAKE_OPTIONS = gnu
 
-AM_CFLAGS = -ansi -Wall
+AM_CFLAGS = -ansi -Wall -DVSOP_DATA_FILE="$(pkgdatadir)/vsop87d.txt"
 
 lib_LTLIBRARIES = libephemeritis.la
 

Modified: branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.h
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.h	2006-01-13 10:35:10 UTC (rev 208)
+++ branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.h	2006-01-14 04:29:13 UTC (rev 209)
@@ -74,7 +74,8 @@
   int data_id;          /*!< @brief An internally recognised data identifier to identify where the data is held. */
 } vsop_handle;
 
-/*! @brief A struct to hold rectangular coordinates from a particular calculation.
+/*! @brief A struct to hold rectangular coordinates from a particular
+ *  calculation, including meta information about their calculation.
  */
 typedef struct {
   vsop_handle vh;       /*!< @brief The VSOP handle representing the data these coordinates were calculated from. */
@@ -93,11 +94,37 @@
 			*/
 } vsop_rec_coords;
 
+/*! @brief Struct for holding spherical coordinates.
+ */
+typedef struct {
+  double L;
+  double B;
+  double R;
+} sph_coords;
+
+/*! @brief A struct to hold spherical coordinates from a particular
+ *  calculation, including meta information about their calculation.
+ */
+typedef struct {
+  vsop_handle vh;       /*!< @brief The VSOP handle representing the data these coordinates were calculated from. */
+  double jd;            /*!< @brief The Julian Date of these coordinates, in dynamical time.                      */
+  sph_coords sc;        /*!< @brief The spherical coordinates.                                                   */
+  int error_state;      /*!< @brief The state of these coordinates,
+                                    indicating if they're okay to use.
+                                    Note that this field is only valid
+                                    once the struct values have been
+                                    calculated at least once.
+
+				    0 indicates no error.
+			*/
+
+} vsop_sph_coords;
+
 void vsop_data_init();
 void vsop_data_cleanup();
 bool get_vsop_data_handle(const vsop_body planet, const vsop_version version, vsop_handle *vh);
 vsop_rec_coords vsop_get_rectangular(const vsop_handle vh, const double jd);
-vsop_rec_coords vsop_rec_vsop_to_fk5(vsop_rec_coords vrc);
+vsop_rec_coords vsop_rec_vsop_to_fk5(const vsop_rec_coords vrc);
 
 
 /* Stuff below here should probably be in a header file that's local to the internal code. */

Modified: branches/new-vsop-prepare/src/c/tests/validate_meeus.c
===================================================================
--- branches/new-vsop-prepare/src/c/tests/validate_meeus.c	2006-01-13 10:35:10 UTC (rev 208)
+++ branches/new-vsop-prepare/src/c/tests/validate_meeus.c	2006-01-14 04:29:13 UTC (rev 209)
@@ -756,6 +756,21 @@
 	report("X", rc.x * km_per_au, -0.9379952 * km_per_au, 5.0, "km");
 	report("Y", rc.y * km_per_au, -0.3116544 * km_per_au, 5.0, "km");
 	report("Z", rc.z * km_per_au, -0.1351215 * km_per_au, 5.0, "km");
+
+	printf("\tUsing the more newly coded method:");
+	vsop_handle vh;
+	if(!get_vsop_data_handle(vsop_earth, hel_rec_j2, &vh)) {
+	  printf("\t\tError loading Earth handle.\n");
+	} else {
+	  vsop_rec_coords vrc = vsop_get_rectangular(vh, jd);
+	  vrc = vsop_rec_vsop_to_fk5(vrc);
+
+	  report("X", -vrc.rc.x * km_per_au, -0.9379952 * km_per_au, 5.0, "km");
+	  report("Y", -vrc.rc.y * km_per_au, -0.3116544 * km_per_au, 5.0, "km");
+	  report("Z", -vrc.rc.z * km_per_au, -0.1351215 * km_per_au, 5.0, "km");
+	  
+	}
+ 
     }
 
     printf("27.a Approximate solstice\n");
@@ -879,6 +894,7 @@
 	report("longitude", r_to_d(L) * 3600, 26.11428 * 3600, 1.0, "arc-seconds");
 	report("latitude", r_to_d(B) * 3600, -2.62070 * 3600, 1.0, "arc-seconds");
 	report("radius", R * km_per_au, 0.724603 * km_per_au, 200.0, "km");
+	printf("%.12f : %.12f : %.12f\n", L, B, R);
     }
 
     printf("33.a Apparent position (vsop)\n");
@@ -1140,7 +1156,6 @@
 
     printf("\n\nPlaying with new VSOP methods:\n");
     {
-      vsop_data_init();
 
       vsop_handle vh;
       bool result;
@@ -1162,17 +1177,37 @@
 	printf("File didn't load for some reason\n");
       }
 
-      vsop_data_cleanup();
+
     }
+    {
+	printf("Checking new VSOP routines\n");
+	vsop_handle vh;
+	if(!get_vsop_data_handle(vsop_earth, hel_rec_j2, &vh)) {
+	  printf("\t\tError loading Earth handle.\n");
+	} else {
+	  double jd = 2448170.5;
+	  vsop_rec_coords vrc = vsop_get_rectangular(vh, jd);
+	  
+	  vrc = vsop_rec_vsop_to_fk5(vrc);
+	  
 
+	  report("X", vrc.rc.x * km_per_au, 0.975673220683  * km_per_au, 1.0e-15, "km");
+	  report("Y", vrc.rc.y * km_per_au, 0.200325394065  * km_per_au, 1.0e-15, "km");
+	  report("Z", vrc.rc.z * km_per_au, 0.0868565820014 * km_per_au, 1.0e-15, "km");
+	  
+	}
+    }
 }
 
 int main(int argc, char *argv[])
 {
-    _main();
-    printf
-	("\nWarning: Former exception throws (now error return values)"
-	 " have not been checked for.\n");
+  vsop_data_init();
+  _main();
+  vsop_data_cleanup();
+
+  printf
+    ("\nWarning: Former exception throws (now error return values)"
+     " have not been checked for.\n");
     /*
        try {
        _main();
@@ -1181,5 +1216,5 @@
        cout << e.what() << endl;
        }
      */
-    return 0;
+  return 0;
 }



From izogi at berlios.de  Sat Jan 14 11:30:23 2006
From: izogi at berlios.de (izogi at BerliOS)
Date: Sat, 14 Jan 2006 11:30:23 +0100
Subject: [Ephemeritis-svn] r210 - branches/new-vsop-prepare/src/c/libephemeritis
Message-ID: <200601141030.k0EAUN7j019994@sheep.berlios.de>

Author: izogi
Date: 2006-01-14 11:30:16 +0100 (Sat, 14 Jan 2006)
New Revision: 210

Added:
   branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c
Log:
Added the vsop_calculate.c file, which had been left out accidentally.


Added: branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c	2006-01-14 04:29:13 UTC (rev 209)
+++ branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c	2006-01-14 10:30:16 UTC (rev 210)
@@ -0,0 +1,253 @@
+/* Copyright 2000, 2001, 2005 William McClain, Mike McGavin
+
+This file is part of Ephemeritis.
+
+Ephemeritis is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+Ephemeritis is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Ephemeritis; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+/*! @file vsop_calculate.c
+ *
+ *  @brief Calculate planetary positions using the VSOP87 planetary
+ *  position model.
+ *
+ */
+
+#include "ephemeritis.h"
+#include "ephemeritis_vsop_data.h"
+#include "config.h"
+
+#include <math.h>
+#include <string.h>
+
+/*! @brief Internal function to sum together the series of a
+ *  particular variable within a set of body elements, and return the
+ *  result (in VSOP coordinates).
+ *
+ *  @param[in] be The set of body elements that contain the variable.
+ *  @param[in] var_num The variable number to return the value for.
+ *                     This is zero-based, and should be consistent with the
+ *                     variable_list array inside the body_elements structure.
+ *  @param[in] jd      THe Julian Day to calculate for, in Dynamical Time.
+ *
+ *  @return The calculated value.  0 will also be returned if the
+ *  var_num parameter was out of range.
+ *
+ *  @warning This function is intended to be internal, and will return
+ *  0.0 if the variable number is out of range for the set of values.
+ *  As this is also a valid return value, be sure to check that
+ *  var_num is within range before calling.
+ *
+ */
+static double internal_vsop_dimension_calc(const body_elements *be, const int var_num, const double jd)
+{
+  if(var_num < 0 || var_num > be->meta.num_variables-1) {
+    /* Oops, this variable doesn't exist. */
+    return 0;
+  }
+
+  /* Get a reference to the series's of this variable. */
+  int series_count = be->variable_list[var_num].meta.series_count;
+  series *series_list = be->variable_list[var_num].series_list;
+
+  /* Set tau to the Julian millenia. */
+  const double T = jd_to_jcent(jd) / 10.0;
+
+  double val = 0.0;
+
+  int sn;
+  for(sn = 0; sn < series_count; sn++) {
+    double s_val = 0.0;
+
+    /* Even though alphaoftime is always an integer, it's set it to a
+       double here to save having to re-convert it every time. */
+    double alphaoftime = (double)(series_list[sn].meta.alpha);
+
+    /* Loop through every term in the series. */
+    term_bin *t, *first_term, *last_term;
+    first_term = series_list[sn].terms;
+    last_term = first_term + (series_list[sn].meta.num_terms - 1);
+
+    for(t = first_term; t <= last_term; t++) {
+      s_val += t->A * (cos(t->B + (t->C * T)));
+    }
+
+    /* Now add the result of the set of terms to the overall value for
+       the variable, multiplying by T^alpha for the series. */
+    val += s_val * pow(T, alphaoftime);
+  }
+
+  return val;
+}
+
+
+/*! @brief Given a VSOP handle referencing data, and a Julian Date,
+ *  calculates rectangular variables.
+ *
+ *  The referenced VSOP data must be data designed for calculating
+ *  rectangular coordinates.  ie. vh.variable must be one of
+ *  hel_rec_j2, hel_rec_date, or bar_rec_j2.  If it isn't, the
+ *  error_state property of the returned struct will be set to a
+ *  non-zero value.
+ *
+ *  @param vh The VSOP handle referencing the data to use for the
+ *            calculation.
+ *  @param jd The Julian Date for which to
+ *            calculate coordinates, in dynamical time.
+ *
+ *  @sa vsop_rec_vsop_to_fk5
+ */
+vsop_rec_coords vsop_get_rectangular(const vsop_handle vh, const double jd)
+{
+  vsop_rec_coords vrc;
+
+  /* Init the struct properties. */
+  memset(&vrc, '\0', sizeof(vrc));
+  vrc.vh = vh;
+  vrc.jd = jd;
+
+  /* Get a reference to the body_elements structure for this handle. */
+  body_elements *be;
+  if(NULL == (be = get_body_elements_for_handle(vh))) {
+    vrc.error_state = -1;
+    return vrc;
+  }
+
+  /* Confirm that the body elements for the handle contain data with rectangular coordinates. */
+  if( ! (vh.version == hel_rec_j2 || vh.version == hel_rec_date || vh.version == bar_rec_j2) ) {
+    vrc.error_state = -2;
+    return vrc;
+  }
+
+  /* Now return X, Y and Z.                                 */
+  /* X, Y and Z come from varibles 0, 1 and 2 respectively. */
+  vrc.rc.x = internal_vsop_dimension_calc(be, 0, jd);
+  vrc.rc.y = internal_vsop_dimension_calc(be, 1, jd);
+  vrc.rc.z = internal_vsop_dimension_calc(be, 2, jd);
+  vrc.error_state = 0;
+
+  /* Return 0 for success. */
+  return vrc;
+}
+
+/*! @brief Rotate rectangular VSOP coordinates from the dynamical
+ *  ecliptic frame J2000 to the equatorial frame FK5 J2000.
+ *
+ *  The incoming rectangular coordinates must be designed to be
+ *  rotated.  ie. They must have been generated from hel_rec_j2 or
+ *  bar_rec_j2.  If it isn't, the error_state property of the returned
+ *  struct will be set to a non-zero value.  If it is already a
+ *  non-zero value for the incoming data, the data will be immediately
+ *  returned with no change.
+ *
+ *  @param vrc[in] The incoming coordinates to be rotated.
+ *
+ *  @return The rotated coordinates.
+ */
+vsop_rec_coords vsop_rec_vsop_to_fk5(const vsop_rec_coords vrc)
+{
+  /* Make a variable to return, and inialise it to the existing incoming values. */
+  vsop_rec_coords output = vrc;
+
+  /* Stop right here if the incoming coordinates are in an error state. */
+  if(output.error_state != 0) {
+    return output;
+  }
+
+  /* Check that the incoming coordinates are of a version designed to be rotated. */
+  if(! (output.vh.version == hel_rec_j2 || output.vh.version == bar_rec_j2)) {
+    output.error_state = -3;
+    return output;
+  }
+
+  output.rc.x = vrc.rc.x*1.000000000000  + vrc.rc.y*0.000000440360 + vrc.rc.z*-0.000000190919;
+  output.rc.y = vrc.rc.x*-0.000000479966 + vrc.rc.y*0.917482137087 + vrc.rc.z*-0.397776982902;
+  output.rc.z = vrc.rc.x*0.000000000000  + vrc.rc.y*0.397776982902 + vrc.rc.z*+0.917482137087;
+  output.error_state = 0;
+
+  return output;
+}
+
+
+vsop_sph_coords vsop_get_spherical(const vsop_handle vh, const double jd)
+{
+  vsop_sph_coords vsc;
+
+  /* Init the struct properties. */
+  memset(&vsc, '\0', sizeof(vsc));
+  vsc.vh = vh;
+  vsc.jd = jd;
+
+  /* Get a reference to the body_elements structure for this handle. */
+  body_elements *be;
+  if(NULL == (be = get_body_elements_for_handle(vh))) {
+    vsc.error_state = -1;
+    return vsc;
+  }
+
+  /* Confirm that the body elements for the handle contain data with spherical coordinates. */
+  if( ! (vh.version == hel_sph_j2 || vh.version == hel_sph_date) ) {
+    vsc.error_state = -2;
+    return vsc;
+  }
+
+  /* Now return L, B and R.                                 */
+  /* L, B and R come from varibles 0, 1 and 2 respectively. */
+  vsc.sc.L = internal_vsop_dimension_calc(be, 0, jd);
+  vsc.sc.B = internal_vsop_dimension_calc(be, 1, jd);
+  vsc.sc.R = internal_vsop_dimension_calc(be, 2, jd);
+  vsc.error_state = 0;
+
+  /* Return 0 for success. */
+  return vsc;
+}
+
+
+vsop_sph_coords vsop_sph_vsop_to_fk5(const vsop_sph_coords vsc) {
+  /* Make a variable to return, and inialise it to the existing incoming values. */
+  vsop_sph_coords output = vsc;
+
+  /* Stop right here if the incoming coordinates are in an error state. */
+  if(output.error_state != 0) {
+    return output;
+  }
+
+  /* Check that the incoming coordinates are of a version designed to be rotated. */
+  /*
+  if(! (output.vh.version == hel_rec_j2 || output.vh.version == bar_rec_j2)) {
+    output.error_state = -3;
+    return output;
+  }
+  */
+
+  static double l1, l2, b1;
+  static double vars[2];
+  static bool static_set = false;
+  if(!static_set) {
+    static_set = true;
+    l1 = -d_to_r(dms_to_d(0,0,0.09033));
+    l2 =  d_to_r(dms_to_d(0,0,0.03916));
+    vars[0] = d_to_r(1.397);
+    vars[1] = d_to_r(0.00031);
+  }
+  /*
+  double L1 = vsc.L - 
+
+    double deltaL = 999;
+  double deltaB;
+  */
+
+
+
+}



From izogi at berlios.de  Sat Jan 14 22:43:49 2006
From: izogi at berlios.de (izogi at BerliOS)
Date: Sat, 14 Jan 2006 22:43:49 +0100
Subject: [Ephemeritis-svn] r211 - branches/new-vsop-prepare/src/c/libephemeritis
Message-ID: <200601142143.k0ELhnAC016721@sheep.berlios.de>

Author: izogi
Date: 2006-01-14 22:43:48 +0100 (Sat, 14 Jan 2006)
New Revision: 211

Modified:
   branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.c
   branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.h
   branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c
Log:
Finished re-writing spherical-to-fk5 routine (untested), and added a note pointing out that it seems unclear about exactly when it should be used.


Modified: branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.c
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.c	2006-01-14 10:30:16 UTC (rev 210)
+++ branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.c	2006-01-14 21:43:48 UTC (rev 211)
@@ -27,6 +27,7 @@
 #include "ephemeritis_vsop_data.h"
 #include "ephemeritis.h"
 
+#include <errno.h>
 #include <stdlib.h>
 #include <string.h>
 #include <stdio.h>
@@ -291,7 +292,7 @@
 
 /* Assumes that the handle isn't already loaded, and that the data in
    the file isn't corrupt, so use with care. */
-static bool load_vsop_handle(const vsop_body planet, const vsop_version version, vsop_handle *vh)
+static int load_vsop_handle(const vsop_body planet, const vsop_version version, vsop_handle *vh)
 {
   /* Construct the filename. */
   char filename[512];
@@ -305,9 +306,10 @@
 
   /* Try to open the file. */
   FILE *f;
+  errno = 0;
   if(NULL == (f = fopen(filename, "rb"))) {
     /* File didn't open for some reason.  Probably not there. */
-    return false;
+    return errno;
   }
 
   /* Attempt to read data from the file. */
@@ -318,7 +320,11 @@
 
 
   /* Close the file. */
-  fclose(f);
+  errno = 0;
+  if(0 != fclose(f)) {
+    return errno;
+  }
+  
 
   /* Allocate more space in the list of vsop handle wrappers. */
   vhw_list = (vsop_handle_wrapper *)realloc(vhw_list, ++vhw_list_size * sizeof(vsop_handle_wrapper));
@@ -329,7 +335,7 @@
   vhw_list[vhw_list_size-1].h.version = version;
 
   *vh = vhw_list[vhw_list_size-1].h;
-  return true;
+  return 0;
 }
 
 /*! @brief Returns a handle for accessing available VSOP data.
@@ -350,14 +356,16 @@
  *
  *  @param[out] vh  A location to place the vsop_handle, if it's available.
  *
- *  @return true if the requested data was available (and returned), false otherwise.
+ *  @return 0 if the requested data was available (and returned),
+ *  otherwise an errno value that could have been set by fopen() or
+ *  fclose() is returned.
  */
-bool get_vsop_data_handle(const vsop_body planet, const vsop_version version, vsop_handle *vh)
+int get_vsop_data_handle(const vsop_body planet, const vsop_version version, vsop_handle *vh)
 {
   /* Check to see if the data for this planet/series is already loaded. */
   if(get_vsop_handle(planet, version, vh)) {
     /* If so, return the handle.       */
-    return true;
+    return 0;
   } else {
     /* If not, load it, then return it. */
     return load_vsop_handle(planet, version, vh);

Modified: branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.h
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.h	2006-01-14 10:30:16 UTC (rev 210)
+++ branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.h	2006-01-14 21:43:48 UTC (rev 211)
@@ -122,7 +122,7 @@
 
 void vsop_data_init();
 void vsop_data_cleanup();
-bool get_vsop_data_handle(const vsop_body planet, const vsop_version version, vsop_handle *vh);
+int get_vsop_data_handle(const vsop_body planet, const vsop_version version, vsop_handle *vh);
 vsop_rec_coords vsop_get_rectangular(const vsop_handle vh, const double jd);
 vsop_rec_coords vsop_rec_vsop_to_fk5(const vsop_rec_coords vrc);
 

Modified: branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c	2006-01-14 10:30:16 UTC (rev 210)
+++ branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c	2006-01-14 21:43:48 UTC (rev 211)
@@ -180,6 +180,21 @@
 }
 
 
+/*! @brief Given a VSOP handle referencing data, and a Julian Date,
+ *  calculates spherical variables.
+ *
+ *  The referenced VSOP data must be data designed for calculating
+ *  spherical coordinates.  ie. vh.variable must be one of hel_sph_j2,
+ *  or hel_sph_date.  If it isn't, the error_state property of the
+ *  returned struct will be set to a non-zero value.
+ *
+ *  @param vh The VSOP handle referencing the data to use for the
+ *            calculation.
+ *  @param jd The Julian Date for which to
+ *            calculate coordinates, in dynamical time.
+ *
+ *  @sa vsop_sph_vsop_to_fk5
+ */
 vsop_sph_coords vsop_get_spherical(const vsop_handle vh, const double jd)
 {
   vsop_sph_coords vsc;
@@ -214,6 +229,30 @@
 }
 
 
+/*! @brief Rotate spherical VSOP coordinates from the dynamical
+ *  ecliptic frame to the equatorial frame FK5.
+ *
+ *  The incoming coordinates must be spherical.  ie. They must have
+ *  been generated from hel_sph_j2 or hel_sph_date.  If it isn't, the
+ *  error_state property of the returned struct will be set to a
+ *  non-zero value.  If it is already a non-zero value for the
+ *  incoming data, the data will be immediately returned with no
+ *  change.
+ *
+ *  @param vsc[in] The incoming coordinates to be rotated.
+ *
+ *  @return The rotated coordinates.
+ *
+ *  @todo It isn't clear which coordinates are rotatable (and I'm not
+ *  really enough of an expert on this).  Basically Meeus seems to
+ *  imply that VSOP87D, which is framed for the ecliptic of the date,
+ *  can be rotated to FK5 with this formula.  This seems inconsistent
+ *  with the VSOP vsop.doc.gz file, which implies that those ones
+ *  framed for the ecliptic of the date can't (or possibly shouldn't)
+ *  be rotated... at least with rectangular coordinates.  This needs
+ *  to be checked with someone who has a clue about calculating
+ *  ephermerides and frames of reference.
+ */
 vsop_sph_coords vsop_sph_vsop_to_fk5(const vsop_sph_coords vsc) {
   /* Make a variable to return, and inialise it to the existing incoming values. */
   vsop_sph_coords output = vsc;
@@ -223,31 +262,32 @@
     return output;
   }
 
-  /* Check that the incoming coordinates are of a version designed to be rotated. */
-  /*
-  if(! (output.vh.version == hel_rec_j2 || output.vh.version == bar_rec_j2)) {
+  /* Check that the incoming coordinates are spherical. */
+  if(! (output.vh.version == hel_sph_j2 || output.vh.version == hel_sph_date)) {
     output.error_state = -3;
     return output;
   }
-  */
 
-  static double l1, l2, b1;
-  static double vars[2];
+  static double l1, l2;
+  static double terms[3];
   static bool static_set = false;
   if(!static_set) {
     static_set = true;
     l1 = -d_to_r(dms_to_d(0,0,0.09033));
     l2 =  d_to_r(dms_to_d(0,0,0.03916));
-    vars[0] = d_to_r(1.397);
-    vars[1] = d_to_r(0.00031);
+    terms[0] = 0.0;
+    terms[1] = d_to_r(1.397);
+    terms[2] = d_to_r(0.00031);
   }
-  /*
-  double L1 = vsc.L - 
 
-    double deltaL = 999;
-  double deltaB;
-  */
+  double T = jd_to_jcent(vsc.jd) / 10.0;
+  double L1 = vsc.sc.L - polynomial(terms, 3, T);
+  double cosL1 = cos(L1);
+  double sinL1 = sin(L1);
 
+  double deltaL = l1 + (l2 * (cosL1 + sinL1) * tan(vsc.sc.B));
+  double deltaB = l2 * (cosL1 - sinL1);
 
-
+  output.sc.L += deltaL;
+  output.sc.B += deltaB;
 }



From izogi at berlios.de  Sat Jan 14 23:37:33 2006
From: izogi at berlios.de (izogi at BerliOS)
Date: Sat, 14 Jan 2006 23:37:33 +0100
Subject: [Ephemeritis-svn] r212 - in branches/new-vsop-prepare/src/c: libephemeritis tests
Message-ID: <200601142237.k0EMbXsH022322@sheep.berlios.de>

Author: izogi
Date: 2006-01-14 23:37:32 +0100 (Sat, 14 Jan 2006)
New Revision: 212

Modified:
   branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.h
   branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c
   branches/new-vsop-prepare/src/c/tests/validate_meeus.c
Log:
Fixed validate_meeus for modified API, and added some basic tests for spherical coordinate calculation.


Modified: branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.h
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.h	2006-01-14 21:43:48 UTC (rev 211)
+++ branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.h	2006-01-14 22:37:32 UTC (rev 212)
@@ -89,7 +89,7 @@
 
 				    0 indicates no error.
 				    -1 (vsop_get_rectangular) indicates a vsop_handle error.  (Data referenced by this handle wasn't found - perhaps it was unloaded.)
-				    -2 (vsop_get_rectangular) indicates that a vsop_handle referenced data not suitable for providing rectangular coordinates.
+				    -2 (vsop_get_rectangular) indicates that a vsop_handle referenced data that wasn't rectangular, or otherwise not suitable for providing rectangular coordinates.
 				    -3 (vsop_rec_vsop_to_fk5) indicates that supplied coordinates were unsuitable for converting to FK5.
 			*/
 } vsop_rec_coords;
@@ -97,9 +97,9 @@
 /*! @brief Struct for holding spherical coordinates.
  */
 typedef struct {
-  double L;
-  double B;
-  double R;
+  double L;             /*!< @brief Heliocentric ecliptical longitude. */
+  double B;             /*!< @brief Heliocentric ecliptical latitude.  */
+  double R;             /*!< @brief The radius vector (distance to the Sun). */
 } sph_coords;
 
 /*! @brief A struct to hold spherical coordinates from a particular
@@ -116,8 +116,10 @@
                                     calculated at least once.
 
 				    0 indicates no error.
+				    -1 (vsop_get_spherical) indicates a vsop_handle error.  (Data referenced by this handle wasn't found - perhaps it was unloaded.)
+				    -2 (vsop_get_spherical) indicates that a vsop_handle referenced data that wasn't spherical, or otherwise not suitable for providing spherical coordinates.  (This should really only happen if the data in the struct has been corrupted somehow.)
+				    -3 (vsop_rec_vsop_to_fk5) indicates that supplied coordinates were unsuitable for converting to FK5.
 			*/
-
 } vsop_sph_coords;
 
 void vsop_data_init();
@@ -125,6 +127,8 @@
 int get_vsop_data_handle(const vsop_body planet, const vsop_version version, vsop_handle *vh);
 vsop_rec_coords vsop_get_rectangular(const vsop_handle vh, const double jd);
 vsop_rec_coords vsop_rec_vsop_to_fk5(const vsop_rec_coords vrc);
+vsop_sph_coords vsop_get_spherical(const vsop_handle vh, const double jd);
+vsop_sph_coords vsop_sph_vsop_to_fk5(const vsop_sph_coords vsc);
 
 
 /* Stuff below here should probably be in a header file that's local to the internal code. */

Modified: branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c	2006-01-14 21:43:48 UTC (rev 211)
+++ branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c	2006-01-14 22:37:32 UTC (rev 212)
@@ -22,6 +22,8 @@
  *  @brief Calculate planetary positions using the VSOP87 planetary
  *  position model.
  *
+ *
+ *  @author Mike McGavin.
  */
 
 #include "ephemeritis.h"
@@ -49,6 +51,7 @@
  *  As this is also a valid return value, be sure to check that
  *  var_num is within range before calling.
  *
+ *  @author Mike McGavin.
  */
 static double internal_vsop_dimension_calc(const body_elements *be, const int var_num, const double jd)
 {
@@ -107,6 +110,8 @@
  *            calculate coordinates, in dynamical time.
  *
  *  @sa vsop_rec_vsop_to_fk5
+ *
+ *  @author Mike McGavin.
  */
 vsop_rec_coords vsop_get_rectangular(const vsop_handle vh, const double jd)
 {
@@ -154,6 +159,8 @@
  *  @param vrc[in] The incoming coordinates to be rotated.
  *
  *  @return The rotated coordinates.
+ *
+ *  @author Mike McGavin.
  */
 vsop_rec_coords vsop_rec_vsop_to_fk5(const vsop_rec_coords vrc)
 {
@@ -194,6 +201,8 @@
  *            calculate coordinates, in dynamical time.
  *
  *  @sa vsop_sph_vsop_to_fk5
+ *
+ *  @author Mike McGavin.
  */
 vsop_sph_coords vsop_get_spherical(const vsop_handle vh, const double jd)
 {
@@ -219,7 +228,7 @@
 
   /* Now return L, B and R.                                 */
   /* L, B and R come from varibles 0, 1 and 2 respectively. */
-  vsc.sc.L = internal_vsop_dimension_calc(be, 0, jd);
+  vsc.sc.L = modpi2(internal_vsop_dimension_calc(be, 0, jd));
   vsc.sc.B = internal_vsop_dimension_calc(be, 1, jd);
   vsc.sc.R = internal_vsop_dimension_calc(be, 2, jd);
   vsc.error_state = 0;
@@ -252,6 +261,8 @@
  *  be rotated... at least with rectangular coordinates.  This needs
  *  to be checked with someone who has a clue about calculating
  *  ephermerides and frames of reference.
+ *
+ *  @author Mike McGavin.
  */
 vsop_sph_coords vsop_sph_vsop_to_fk5(const vsop_sph_coords vsc) {
   /* Make a variable to return, and inialise it to the existing incoming values. */
@@ -290,4 +301,5 @@
 
   output.sc.L += deltaL;
   output.sc.B += deltaB;
+  return output;
 }

Modified: branches/new-vsop-prepare/src/c/tests/validate_meeus.c
===================================================================
--- branches/new-vsop-prepare/src/c/tests/validate_meeus.c	2006-01-14 21:43:48 UTC (rev 211)
+++ branches/new-vsop-prepare/src/c/tests/validate_meeus.c	2006-01-14 22:37:32 UTC (rev 212)
@@ -1181,21 +1181,49 @@
     }
     {
 	printf("Checking new VSOP routines\n");
-	vsop_handle vh;
-	if(!get_vsop_data_handle(vsop_earth, hel_rec_j2, &vh)) {
-	  printf("\t\tError loading Earth handle.\n");
-	} else {
-	  double jd = 2448170.5;
-	  vsop_rec_coords vrc = vsop_get_rectangular(vh, jd);
+	{
+	  printf("Earth rectangular\n");
+	  vsop_handle vh;
+	  if(0 != get_vsop_data_handle(vsop_earth, hel_rec_j2, &vh)) {
+	    printf("\t\tError loading Earth handle.\n");
+	  } else {
+	    double jd = 2448170.5;
+	    vsop_rec_coords vrc = vsop_get_rectangular(vh, jd);
+	    
+	    vrc = vsop_rec_vsop_to_fk5(vrc);
 	  
-	  vrc = vsop_rec_vsop_to_fk5(vrc);
-	  
 
-	  report("X", vrc.rc.x * km_per_au, 0.975673220683  * km_per_au, 1.0e-15, "km");
-	  report("Y", vrc.rc.y * km_per_au, 0.200325394065  * km_per_au, 1.0e-15, "km");
-	  report("Z", vrc.rc.z * km_per_au, 0.0868565820014 * km_per_au, 1.0e-15, "km");
+	    report("X", vrc.rc.x * km_per_au, 0.975673220683  * km_per_au, 1.0e-15, "km");
+	    report("Y", vrc.rc.y * km_per_au, 0.200325394065  * km_per_au, 1.0e-15, "km");
+	    report("Z", vrc.rc.z * km_per_au, 0.0868565820014 * km_per_au, 1.0e-15, "km");
 	  
+	  }
 	}
+	{
+	  printf("Venus spherical\n");
+	  vsop_handle vh;
+	  if(0 != get_vsop_data_handle(vsop_venus, hel_sph_date, &vh)) {
+	    printf("\t\tError loading Venus handle.\n");
+	  } else {
+	    vsop_sph_coords vsc = vsop_get_spherical(vh, 2448976.5);
+	    /*
+	    vsc = vsop_sph_vsop_to_fk5(vsc);
+	    */
+	    report("longitude", r_to_d(modpi2(vsc.sc.L)) * 3600, 26.11428 * 3600, 0.001, "arc-seconds");
+	    report("latitude", r_to_d(vsc.sc.B) * 3600, -2.62070 * 3600, 0.00, "arc-seconds");
+	    report("radius", vsc.sc.R * km_per_au, 0.724603 * km_per_au, 1.0, "km");
+
+	    
+	    double L, B, R;
+	    vsop_dimension3_vsop(2448976.5, vVenus, &L, &B, &R);
+	    report("longitude", r_to_d(L) * 3600, 26.11428 * 3600, 1.0, "arc-seconds");
+	    report("latitude", r_to_d(B) * 3600, -2.62070 * 3600, 1.0, "arc-seconds");
+	    report("radius", R * km_per_au, 0.724603 * km_per_au, 200.0, "km");
+	    printf("%.12f : %.12f : %.12f\n", vsc.sc.L, vsc.sc.B, vsc.sc.R);
+	    printf("%.12f : %.12f : %.12f\n", L, B, R);
+	    
+	  }
+	}
     }
 }
 



From izogi at berlios.de  Sun Jan 15 01:04:27 2006
From: izogi at berlios.de (izogi at BerliOS)
Date: Sun, 15 Jan 2006 01:04:27 +0100
Subject: [Ephemeritis-svn] r213 - in branches/new-vsop-prepare/src/c: libephemeritis tests
Message-ID: <200601150004.k0F04Rlw022141@sheep.berlios.de>

Author: izogi
Date: 2006-01-15 01:04:23 +0100 (Sun, 15 Jan 2006)
New Revision: 213

Modified:
   branches/new-vsop-prepare/src/c/libephemeritis/solar.c
   branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c
   branches/new-vsop-prepare/src/c/tests/validate_meeus.c
Log:
More experimenting/playing with solar/vsop calculation.


Modified: branches/new-vsop-prepare/src/c/libephemeritis/solar.c
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/solar.c	2006-01-14 22:37:32 UTC (rev 212)
+++ branches/new-vsop-prepare/src/c/libephemeritis/solar.c	2006-01-15 00:04:23 UTC (rev 213)
@@ -28,10 +28,9 @@
  *  the Sun is the negative of the heliocentric latitude of the Earth.
  *  The radius is of course the same in both coordinate systems.
  *
- *  @author William McClain
+ *  @author William McClain, Mike McGavin.
  *
- *  @todo Check Solar routines against VSOP routines, to make sure
- *  it's all working appropriately.
+ *  @todo Adjust the API to make use of sph_coords.
  */
 
 #include "ephemeritis.h"

Modified: branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c	2006-01-14 22:37:32 UTC (rev 212)
+++ branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c	2006-01-15 00:04:23 UTC (rev 213)
@@ -37,6 +37,10 @@
  *  particular variable within a set of body elements, and return the
  *  result (in VSOP coordinates).
  *
+ *  This algorithm is adapted from that provided by Bretagnon P.,
+ *  Francou G., : 1988, Astron. Astrophys.  It's also explained in
+ *  [Meeus-1998: chapter 32.]
+ *
  *  @param[in] be The set of body elements that contain the variable.
  *  @param[in] var_num The variable number to return the value for.
  *                     This is zero-based, and should be consistent with the
@@ -156,6 +160,10 @@
  *  non-zero value for the incoming data, the data will be immediately
  *  returned with no change.
  *
+ *  This algorithm is adapted from that provided by Bretagnon P.,
+ *  Francou G., : 1988, Astron. Astrophys.  It's also explained in
+ *  [Meeus-1998: equation 26.3.]
+
  *  @param vrc[in] The incoming coordinates to be rotated.
  *
  *  @return The rotated coordinates.
@@ -231,9 +239,9 @@
   vsc.sc.L = modpi2(internal_vsop_dimension_calc(be, 0, jd));
   vsc.sc.B = internal_vsop_dimension_calc(be, 1, jd);
   vsc.sc.R = internal_vsop_dimension_calc(be, 2, jd);
-  vsc.error_state = 0;
 
   /* Return 0 for success. */
+  vsc.error_state = 0;
   return vsc;
 }
 
@@ -258,9 +266,9 @@
  *  can be rotated to FK5 with this formula.  This seems inconsistent
  *  with the VSOP vsop.doc.gz file, which implies that those ones
  *  framed for the ecliptic of the date can't (or possibly shouldn't)
- *  be rotated... at least with rectangular coordinates.  This needs
- *  to be checked with someone who has a clue about calculating
- *  ephermerides and frames of reference.
+ *  be rotated... at least with rectangular coordinates, which might
+ *  work differently.  This needs to be checked with someone who has a
+ *  clue about calculating ephermerides and frames of reference.
  *
  *  @author Mike McGavin.
  */

Modified: branches/new-vsop-prepare/src/c/tests/validate_meeus.c
===================================================================
--- branches/new-vsop-prepare/src/c/tests/validate_meeus.c	2006-01-14 22:37:32 UTC (rev 212)
+++ branches/new-vsop-prepare/src/c/tests/validate_meeus.c	2006-01-15 00:04:23 UTC (rev 213)
@@ -45,8 +45,8 @@
  *
  *  Note that Meeus presents a truncated version of VSOP87d and some
  *  differences are to be expected when comparing results with the
- *  complete version that Ephemeritis uses. He sometimes prints values
- *  are derived from the complete theory, and we use those where
+ *  complete version that Ephemeritis uses. He sometimes provides
+ *  values derived from the complete theory, and we use those where
  *  possible.
  *
  *  @author Bill McClain, Mike McGavin.
@@ -742,34 +742,51 @@
     printf("26.a Rectangular coordinates of the Sun\n");
     {
 	double jd = 2448908.5;
-	double L, B, R;
-	sol_dimension3_fk5(jd, &L, &B, &R);
 
-	/* VSOP calculates slightly different values from the book, so
-	   L, B and R will, here, be overridden from those stated on
-	   p172. */
-	L = d_to_r(199.907347);
-	B = d_to_r(dms_to_d(0, 0, 0.62));
-	R = 0.99760775;
-	double E = obliquity_hi(jd);
-	rec_coords rc = sol_rectangular(L, B, R, E);
-	report("X", rc.x * km_per_au, -0.9379952 * km_per_au, 5.0, "km");
-	report("Y", rc.y * km_per_au, -0.3116544 * km_per_au, 5.0, "km");
-	report("Z", rc.z * km_per_au, -0.1351215 * km_per_au, 5.0, "km");
+/* 	double L, B, R; */
+/* 	sol_dimension3_fk5(jd, &L, &B, &R); */
 
-	printf("\tUsing the more newly coded method:");
+/* 	/\* VSOP calculates slightly different values from the book, so */
+/* 	   L, B and R will, here, be overridden from those stated on */
+/* 	   p172. *\/ */
+/* 	L = d_to_r(199.907347); */
+/* 	B = d_to_r(dms_to_d(0, 0, 0.62)); */
+/* 	R = 0.99760775; */
+
+/* 	double E = obliquity_hi(jd); */
+/* 	rec_coords rc = sol_rectangular(L, B, R, E); */
+/* 	report("X", rc.x * km_per_au, -0.9379952 * km_per_au, 5.0, "km"); */
+/* 	report("Y", rc.y * km_per_au, -0.3116544 * km_per_au, 5.0, "km"); */
+/* 	report("Z", rc.z * km_per_au, -0.1351215 * km_per_au, 5.0, "km"); */
+
+
 	vsop_handle vh;
-	if(!get_vsop_data_handle(vsop_earth, hel_rec_j2, &vh)) {
-	  printf("\t\tError loading Earth handle.\n");
+	int result;
+	if(0 != (result = get_vsop_data_handle(vsop_earth, hel_sph_date, &vh))) {
+	  printf("Problem opening file: %s", strerror(result));
 	} else {
-	  vsop_rec_coords vrc = vsop_get_rectangular(vh, jd);
-	  vrc = vsop_rec_vsop_to_fk5(vrc);
+	  vsop_sph_coords vsc = vsop_sph_vsop_to_fk5(vsop_get_spherical(vh, jd));
 
-	  report("X", -vrc.rc.x * km_per_au, -0.9379952 * km_per_au, 5.0, "km");
-	  report("Y", -vrc.rc.y * km_per_au, -0.3116544 * km_per_au, 5.0, "km");
-	  report("Z", -vrc.rc.z * km_per_au, -0.1351215 * km_per_au, 5.0, "km");
+	  double E = obliquity_hi(jd);
+	  rec_coords rc = sol_rectangular(vsc.sc.L, vsc.sc.B, vsc.sc.R, E);
+	  report("X", -rc.x * km_per_au, -0.9379952 * km_per_au, 5.0, "km");
+	  report("Y", -rc.y * km_per_au, -0.3116544 * km_per_au, 5.0, "km");
+	  report("Z", -rc.z * km_per_au, -0.1351215 * km_per_au, 5.0, "km");
+
+	}
+
+/* 	printf("Using the more newly coded method:\n"); */
+/* 	if(0 != get_vsop_data_handle(vsop_earth, hel_rec_date, &vh)) { */
+/* 	  printf("\t\tError loading Earth handle.\n"); */
+/* 	} else { */
+/* 	  vsop_rec_coords vrc = vsop_get_rectangular(vh, jd); */
+/* 	  vrc = vsop_rec_vsop_to_fk5(vrc); */
+
+/* 	  report("X", -vrc.rc.x * km_per_au, -0.9379952 * km_per_au, 5.0, "km"); */
+/* 	  report("Y", -vrc.rc.y * km_per_au, -0.3116544 * km_per_au, 5.0, "km"); */
+/* 	  report("Z", -vrc.rc.z * km_per_au, -0.1351215 * km_per_au, 5.0, "km"); */
 	  
-	}
+/* 	} */
  
     }
 
@@ -1154,77 +1171,75 @@
     }
 
 
-    printf("\n\nPlaying with new VSOP methods:\n");
-    {
+/*     printf("\n\nPlaying with new VSOP methods:\n"); */
+/*     { */
 
-      vsop_handle vh;
-      bool result;
-      result = get_vsop_data_handle(vsop_mercury, hel_rec_date, &vh);
-      printf("%d\n", vh.data_id);
+/*       vsop_handle vh; */
+/*       bool result; */
+/*       result = get_vsop_data_handle(vsop_mercury, hel_rec_date, &vh); */
+/*       printf("%d\n", vh.data_id); */
 
-      result = get_vsop_data_handle(vsop_venus, hel_rec_date, &vh);
-      printf("%d\n", vh.data_id);
+/*       result = get_vsop_data_handle(vsop_venus, hel_rec_date, &vh); */
+/*       printf("%d\n", vh.data_id); */
 
-      result = get_vsop_data_handle(vsop_earth, hel_rec_date, &vh);
-      printf("%d\n", vh.data_id);
+/*       result = get_vsop_data_handle(vsop_earth, hel_rec_date, &vh); */
+/*       printf("%d\n", vh.data_id); */
 
-      result = get_vsop_data_handle(vsop_mercury, hel_rec_date, &vh);
-      printf("%d\n", vh.data_id);
+/*       result = get_vsop_data_handle(vsop_mercury, hel_rec_date, &vh); */
+/*       printf("%d\n", vh.data_id); */
 
-      if(result) {
-	printf("Loaded okay\n");
-      } else {
-	printf("File didn't load for some reason\n");
-      }
-
-
-    }
-    {
-	printf("Checking new VSOP routines\n");
-	{
-	  printf("Earth rectangular\n");
-	  vsop_handle vh;
-	  if(0 != get_vsop_data_handle(vsop_earth, hel_rec_j2, &vh)) {
-	    printf("\t\tError loading Earth handle.\n");
-	  } else {
-	    double jd = 2448170.5;
-	    vsop_rec_coords vrc = vsop_get_rectangular(vh, jd);
+/*       if(result) { */
+/* 	printf("Loaded okay\n"); */
+/*       } else { */
+/* 	printf("File didn't load for some reason\n"); */
+/*       } */
+/*     } */
+/*     { */
+/* 	printf("Checking new VSOP routines\n"); */
+/* 	{ */
+/* 	  printf("Earth rectangular\n"); */
+/* 	  vsop_handle vh; */
+/* 	  if(0 != get_vsop_data_handle(vsop_earth, hel_rec_j2, &vh)) { */
+/* 	    printf("\t\tError loading Earth handle.\n"); */
+/* 	  } else { */
+/* 	    double jd = 2448170.5; */
+/* 	    vsop_rec_coords vrc = vsop_get_rectangular(vh, jd); */
 	    
-	    vrc = vsop_rec_vsop_to_fk5(vrc);
+/* 	    vrc = vsop_rec_vsop_to_fk5(vrc); */
 	  
 
-	    report("X", vrc.rc.x * km_per_au, 0.975673220683  * km_per_au, 1.0e-15, "km");
-	    report("Y", vrc.rc.y * km_per_au, 0.200325394065  * km_per_au, 1.0e-15, "km");
-	    report("Z", vrc.rc.z * km_per_au, 0.0868565820014 * km_per_au, 1.0e-15, "km");
+/* 	    report("X", vrc.rc.x * km_per_au, 0.975673220683  * km_per_au, 1.0e-15, "km"); */
+/* 	    report("Y", vrc.rc.y * km_per_au, 0.200325394065  * km_per_au, 1.0e-15, "km"); */
+/* 	    report("Z", vrc.rc.z * km_per_au, 0.0868565820014 * km_per_au, 1.0e-15, "km"); */
 	  
-	  }
-	}
-	{
-	  printf("Venus spherical\n");
-	  vsop_handle vh;
-	  if(0 != get_vsop_data_handle(vsop_venus, hel_sph_date, &vh)) {
-	    printf("\t\tError loading Venus handle.\n");
-	  } else {
-	    vsop_sph_coords vsc = vsop_get_spherical(vh, 2448976.5);
-	    /*
-	    vsc = vsop_sph_vsop_to_fk5(vsc);
-	    */
-	    report("longitude", r_to_d(modpi2(vsc.sc.L)) * 3600, 26.11428 * 3600, 0.001, "arc-seconds");
-	    report("latitude", r_to_d(vsc.sc.B) * 3600, -2.62070 * 3600, 0.00, "arc-seconds");
-	    report("radius", vsc.sc.R * km_per_au, 0.724603 * km_per_au, 1.0, "km");
+/* 	  } */
+/* 	} */
+/* 	{ */
+/* 	  printf("Venus spherical\n"); */
+/* 	  vsop_handle vh; */
+/* 	  if(0 != get_vsop_data_handle(vsop_venus, hel_sph_date, &vh)) { */
+/* 	    printf("\t\tError loading Venus handle.\n"); */
+/* 	  } else { */
+/* 	    vsop_sph_coords vsc = vsop_get_spherical(vh, 2448976.5); */
+/* 	    /\* */
+/* 	    vsc = vsop_sph_vsop_to_fk5(vsc); */
+/* 	    *\/ */
+/* 	    report("longitude", r_to_d(modpi2(vsc.sc.L)) * 3600, 26.11428 * 3600, 0.001, "arc-seconds"); */
+/* 	    report("latitude", r_to_d(vsc.sc.B) * 3600, -2.62070 * 3600, 0.001, "arc-seconds"); */
+/* 	    report("radius", vsc.sc.R * km_per_au, 0.724603 * km_per_au, 1.0, "km"); */
 
-	    
-	    double L, B, R;
-	    vsop_dimension3_vsop(2448976.5, vVenus, &L, &B, &R);
-	    report("longitude", r_to_d(L) * 3600, 26.11428 * 3600, 1.0, "arc-seconds");
-	    report("latitude", r_to_d(B) * 3600, -2.62070 * 3600, 1.0, "arc-seconds");
-	    report("radius", R * km_per_au, 0.724603 * km_per_au, 200.0, "km");
-	    printf("%.12f : %.12f : %.12f\n", vsc.sc.L, vsc.sc.B, vsc.sc.R);
-	    printf("%.12f : %.12f : %.12f\n", L, B, R);
-	    
-	  }
-	}
-    }
+/* 	    /\* */
+/* 	    double L, B, R; */
+/* 	    vsop_dimension3_vsop(2448976.5, vVenus, &L, &B, &R); */
+/* 	    report("longitude", r_to_d(L) * 3600, 26.11428 * 3600, 1.0, "arc-seconds"); */
+/* 	    report("latitude", r_to_d(B) * 3600, -2.62070 * 3600, 1.0, "arc-seconds"); */
+/* 	    report("radius", R * km_per_au, 0.724603 * km_per_au, 200.0, "km"); */
+/* 	    printf("%.12f : %.12f : %.12f\n", vsc.sc.L, vsc.sc.B, vsc.sc.R); */
+/* 	    printf("%.12f : %.12f : %.12f\n", L, B, R); */
+/* 	    *\/	     */
+/* 	  } */
+/* 	} */
+/*     } */
 }
 
 int main(int argc, char *argv[])



From izogi at berlios.de  Sun Jan 15 10:26:40 2006
From: izogi at berlios.de (izogi at BerliOS)
Date: Sun, 15 Jan 2006 10:26:40 +0100
Subject: [Ephemeritis-svn] r214 - branches/new-vsop-prepare/src/c/tests
Message-ID: <200601150926.k0F9QeaI005758@sheep.berlios.de>

Author: izogi
Date: 2006-01-15 10:26:40 +0100 (Sun, 15 Jan 2006)
New Revision: 214

Modified:
   branches/new-vsop-prepare/src/c/tests/validate_meeus.c
Log:
More playing with code to try and take advantage of new vsop code.  (Not yet working.)


Modified: branches/new-vsop-prepare/src/c/tests/validate_meeus.c
===================================================================
--- branches/new-vsop-prepare/src/c/tests/validate_meeus.c	2006-01-15 00:04:23 UTC (rev 213)
+++ branches/new-vsop-prepare/src/c/tests/validate_meeus.c	2006-01-15 09:26:40 UTC (rev 214)
@@ -949,42 +949,56 @@
 	report("y", rc.y, 0.4849175, 0.0000001, "AU");
 	report("z", rc.z, 0.3573373, 0.0000001, "AU");
 
-	double L, B, R;
-	sol_dimension3_fk5(jd, &L, &B, &R);
 
+	vsop_handle vh;
+	int result;
+	if(0 != (result = get_vsop_data_handle(vsop_earth, hel_sph_j2, &vh))) {
+	  printf("Problem opening file: %s", strerror(result));
+	} else {
+	  vsop_sph_coords vsc = vsop_sph_vsop_to_fk5(vsop_get_spherical(vh, jd));
 
-	rec_coords src = sol_rectangular(L, B, R, obl2000);
-	report("solar x", src.x * km_per_au, -0.9756732 * km_per_au, 1, "km");
-	report("solar y", src.y * km_per_au, -0.2003254 * km_per_au, 1, "km");
-	report("solar z", src.z * km_per_au, -0.0868566 * km_per_au, 1, "km");
+	  double E = obliquity_hi(jd);
+	  rec_coords src = sol_rectangular(vsc.sc.L, vsc.sc.B, vsc.sc.R, E);
+	  src.x = -src.x;
+	  src.y = -src.y;
+	  src.z = -src.z;
 
-	printf("Resetting sol values to those in example (because VSOP isn't calculating them properly as above)\n");
-	src.x = -0.9756732;
-	src.y = -0.2003254;
-	src.z = -0.0868566;
+/* 	double L, B, R; */
+/* 	sol_dimension3_fk5(jd, &L, &B, &R); */
+/* 	rec_coords src = sol_rectangular(L, B, R, obl2000); */
+	  report("solar x", src.x * km_per_au, -0.9756732 * km_per_au, 800, "km");
+	  report("solar y", src.y * km_per_au, -0.2003254 * km_per_au, 800, "km");
+	  report("solar z", src.z * km_per_au, -0.0868566 * km_per_au, 800, "km");
 
-	double ra, dec, elongation, phase_angle, body_r_earth;
-	elliptical_orbit_ecliptical(src, rc, r_sun, &ra, &dec, &elongation, &phase_angle, &body_r_earth);
+/* 	printf("Resetting sol values to those in example (because VSOP isn't calculating them properly as above)\n"); */
+/* 	src.x = -0.9756732; */
+/* 	src.y = -0.2003254; */
+/* 	src.z = -0.0868566; */
 
-	report("delta-earth", body_r_earth, 0.8243689, 0.0000001, "AU");
+	  double ra, dec, elongation, phase_angle, body_r_earth;
+	  elliptical_orbit_ecliptical(src, rc, r_sun, &ra, &dec, &elongation, &phase_angle, &body_r_earth);
 
-	double tau = 0.0057755183 * body_r_earth;
-	jd = jd - tau;
-	el.M = mean_anomoly(jd, T, el.n);
-	ec = get_element_constants(obl2000, el, 53);
-	r_sun = get_r_sun(ec);
-	rc = elliptical_orbit_rectangular(ec, r_sun);
+	  report("delta-earth", body_r_earth, 0.8243689, 0.000001, "AU");
 
-	report("recalc-x", rc.x, 0.2509310, 0.0000001, "AU");
-	report("recalc-y", rc.y, 0.4849477, 0.0000001, "AU");
-	report("recalc-z", rc.z, 0.3573712, 0.0000001, "AU");
+	  double tau = 0.0057755183 * body_r_earth;
+	  jd = jd - tau;
+	  el.M = mean_anomoly(jd, T, el.n);
+	  ec = get_element_constants(obl2000, el, 53);
+	  r_sun = get_r_sun(ec);
+	  rc = elliptical_orbit_rectangular(ec, r_sun);
 
-	elliptical_orbit_ecliptical(src, rc, r_sun, &ra, &dec, &elongation, &phase_angle, &body_r_earth);
+	  report("recalc-x", rc.x, 0.2509310, 0.000001, "AU");
+	  report("recalc-y", rc.y, 0.4849477, 0.000001, "AU");
+	  report("recalc-z", rc.z, 0.3573712, 0.000001, "AU");
 
-	report("recalc-delta-earth", body_r_earth, 0.8242811, 0.0000001, "AU");
-	report("ra", ra, d_to_r(158.558965), 0.0000001, "radians");
-	report("dec", dec, d_to_r(19.158496), 0.0000001, "radians");
-	report("elongation", elongation, d_to_r(40.51), 0.0000001, "radians");
+	  elliptical_orbit_ecliptical(src, rc, r_sun, &ra, &dec, &elongation, &phase_angle, &body_r_earth);
+
+	  report("recalc-delta-earth", body_r_earth, 0.8242811, 0.000001, "AU");
+	  report("ra", ra, d_to_r(158.558965), 0.00001, "radians");
+	  report("dec", dec, d_to_r(19.158496), 0.00001, "radians");
+	  report("elongation", elongation, d_to_r(40.51), 0.00001, "radians");
+	}
+
     }
 
     printf("47.a Moon position\n");
@@ -1091,11 +1105,23 @@
 	    printf("Testing %s, test %d\n", or->name, o);
 
 
+	    vsop_handle vh;
+	    get_vsop_data_handle(vsop_earth, hel_sph_j2, &vh);
+	    vsop_sph_coords vsc = vsop_sph_vsop_to_fk5(vsop_get_spherical(vh, test->jd));
+
+	    double E = obliquity_hi(test->jd);
+	    vsc.sc.L = modpi2(vsc.sc.L + pi);
+	    vsc.sc.B = -vsc.sc.B;
+	    rec_coords sun_rec = sol_rectangular(vsc.sc.L, vsc.sc.B, vsc.sc.R, E);
+
+
+
+	    /*
 	    double L, B, R;
 	    sol_dimension3_fk5(test->jd, &L, &B, &R);
 	    rec_coords sun_rec = sol_rectangular(L, B, R, obliquity_hi(je_to_jd(2000)));
+	    */
 
-
 	    double ra;
 	    double dec;
 	    double elongation;
@@ -1144,7 +1170,7 @@
 
 	    /* Adjust for nutation. */
 	    double a_in_ra, a_in_dec;
-	    aberration_in_ra_dec_low(test->jd, ra, dec, obliquity_hi(test->jd), L, &a_in_ra, &a_in_dec);
+	    aberration_in_ra_dec_low(test->jd, ra, dec, obliquity_hi(test->jd), vsc.sc.L, &a_in_ra, &a_in_dec);
 	    ra  += a_in_ra;
 	    dec += a_in_dec;
 



From izogi at berlios.de  Wed Jan 18 10:21:06 2006
From: izogi at berlios.de (izogi at BerliOS)
Date: Wed, 18 Jan 2006 10:21:06 +0100
Subject: [Ephemeritis-svn] r215 - branches/new-vsop-prepare/src/python
Message-ID: <200601180921.k0I9L6Ks030283@sheep.berlios.de>

Author: izogi
Date: 2006-01-18 10:21:05 +0100 (Wed, 18 Jan 2006)
New Revision: 215

Added:
   branches/new-vsop-prepare/src/python/vsop2-experiment.py
Log:
Adding experimental python script to repository (so it doesn't get lost)


Added: branches/new-vsop-prepare/src/python/vsop2-experiment.py
===================================================================
--- branches/new-vsop-prepare/src/python/vsop2-experiment.py	2006-01-15 09:26:40 UTC (rev 214)
+++ branches/new-vsop-prepare/src/python/vsop2-experiment.py	2006-01-18 09:21:05 UTC (rev 215)
@@ -0,0 +1,144 @@
+
+import os, math
+
+class bodydata:
+  def __init__(self, filename):
+    self.versioncode = None
+    self.bodyname = None
+    self.series = [[], [], [], [], [], []]
+    self.__load(filename)
+
+  def __load(self, filename):
+
+    def isnum(x):
+      try:
+        int(x)
+        return 1
+      except:
+        return 0
+
+    # Get a file object.
+    f = file(filename)
+
+    dataline = f.readline()
+    while dataline:
+      # Split the data line into its fields.
+      self.versioncode = int(dataline[17])
+      self.bodyname = dataline[22:29]
+
+      indexofcoordinate = int(dataline[41])
+      alphaoftime = int(dataline[59])
+      numterms = int(dataline[60:67])
+
+      indexl = indexofcoordinate - 1
+
+      self.series[indexl] += [{}]
+      this_series = self.series[indexl][len(self.series[indexl]) - 1]
+      this_series['indexofcoordinate'] = indexofcoordinate
+      this_series['alphaoftime'] = alphaoftime
+
+      this_series['data'] = []
+      data = this_series['data']
+
+      # Loop through the data lines.
+      for n in range(0, numterms):
+          dataline = f.readline()
+
+          d = {}
+
+          vsop_version = int(dataline[1])
+          bodycode = int(dataline[2])
+          indexofcoordinate = int(dataline[3])
+          alphaoftime = int(dataline[4])
+
+          # Not needed thanks to ordering in list.
+          series_rank = int(dataline[5:10])
+
+          d['coefficients'] = filter(isnum, dataline[10:46].split(' '))
+          d['S'] = float(dataline[46:61])
+          d['K'] = float(dataline[61:79])
+          d['A'] = float(dataline[79:97])
+          d['B'] = float(dataline[97:111])
+          d['C'] = float(dataline[111:131])
+
+          data += [d]
+
+      dataline = f.readline()
+
+    # Close the file.
+    f.close()    
+
+
+def load_data(filename):
+  print "loading %s"%(filename)
+  bd = bodydata(filename)
+  return bd
+
+def vsop_to_fk5(xyz):
+  (x1,y1,z1) = xyz
+  x = x1*1.000000000000  + y1*0.000000440360 + z1*-0.000000190919
+  y = x1*-0.000000479966 + y1*0.917482137087 + z1*-0.397776982902
+  z = x1*0.000000000000  + y1*0.397776982902 + z1*+0.917482137087
+  return (x,y,z)
+
+def calc_at(bd, jd, indexl):
+  j2000 = 2451545.0
+  T = (jd - j2000) / 365250.0
+
+  series_set = bd.series[indexl]
+  val = 0.0
+  for s in series_set:
+    series_val = 0.0
+    alphaoftime = s['alphaoftime']
+    for d in s['data']:
+      series_val += d['A'] * (math.cos(d['B'] + d['C']*T))
+
+    val += series_val * math.pow(T, alphaoftime)
+
+#    print series_val, T, alphaoftime, val
+
+#  print "Returning " + str(val)
+  return val
+
+def run():
+  bd = load_data('/home/izogi/ephemeritis/branches/new-vsop-prepare/data/vsop/VSOP87B.ven')
+  jd = 2448976.5
+
+#  bd = load_data('/home/izogi/ephemeritis/branches/new-vsop-prepare/data/vsop/VSOP87A.ear')
+#  jd = 2448170.5
+
+  #double L, B, R;
+  #vsop_dimension3_vsop(2448976.5, vVenus, &L, &B, &R);
+  #/*
+  #   report_diff("longitude", r_to_d(L) * 3600, 26.11428 * 3600,
+  #           "arc-seconds");
+  #   report_diff("latitude", r_to_d(B) * 3600, -2.62070 * 3600,
+  #           "arc-seconds");
+  #   report_diff("radius", R * km_per_au, 0.724603 * km_per_au, "km");
+  # */
+  #report("longitude", r_to_d(L) * 3600, 26.11428 * 3600, 1.0, "arc-seconds");
+  #report("latitude", r_to_d(B) * 3600, -2.62070 * 3600, 1.0, "arc-seconds");
+  #report("radius", R * km_per_au, 0.724603 * km_per_au, 200.0, "km");
+                                    
+
+#  print "L: ", calc_at(bd, jd, 1)
+#  print "B: ", calc_at(bd, jd, 2)
+#  print "R: ", calc_at(bd, jd, 0)
+
+  print "L: ", calc_at(bd, jd, 0)
+  print "B: ", calc_at(bd, jd, 1)
+  print "R: ", calc_at(bd, jd, 2)
+
+#  x = calc_at(bd, jd, 0)
+#  y = calc_at(bd, jd, 1)
+#  z = calc_at(bd, jd, 2)
+#  print "X0: ", -x
+#  print "Y0: ", -y
+#  print "Z0: ", -z
+#  (x,y,z) = vsop_to_fk5((x,y,z))
+#  print "X: ", -x
+#  print "Y: ", -y
+#  print "Z: ", -z
+
+if '__main__' == __name__:
+  run()



From izogi at berlios.de  Wed Jan 18 10:57:28 2006
From: izogi at berlios.de (izogi at BerliOS)
Date: Wed, 18 Jan 2006 10:57:28 +0100
Subject: [Ephemeritis-svn] r216 - in branches/new-vsop-prepare/src: c/libephemeritis c/tests python
Message-ID: <200601180957.k0I9vSna000849@sheep.berlios.de>

Author: izogi
Date: 2006-01-18 10:57:28 +0100 (Wed, 18 Jan 2006)
New Revision: 216

Modified:
   branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.h
   branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c
   branches/new-vsop-prepare/src/c/tests/validate_meeus.c
   branches/new-vsop-prepare/src/python/vsop2-experiment.py
Log:
Added vsop_rec_invert() for inverting rectangular coordinates (such as for determining the Sun's position having calculated Earth).


Modified: branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.h
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.h	2006-01-18 09:21:05 UTC (rev 215)
+++ branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.h	2006-01-18 09:57:28 UTC (rev 216)
@@ -81,6 +81,7 @@
   vsop_handle vh;       /*!< @brief The VSOP handle representing the data these coordinates were calculated from. */
   double jd;            /*!< @brief The Julian Date of these coordinates, in dynamical time.                      */
   rec_coords rc;        /*!< @brief The XYZ coordinates.                                                          */
+  int is_inverted;      /*!< @brief Set to 1 if these coordinates are inverted (eg. for Solar coordinates), 0 otherwise. */
   int error_state;      /*!< @brief The state of these coordinates,
                                     indicating if they're okay to use.
                                     Note that this field is only valid
@@ -109,6 +110,7 @@
   vsop_handle vh;       /*!< @brief The VSOP handle representing the data these coordinates were calculated from. */
   double jd;            /*!< @brief The Julian Date of these coordinates, in dynamical time.                      */
   sph_coords sc;        /*!< @brief The spherical coordinates.                                                   */
+  int is_inverted;      /*!< @brief Set to 1 if these coordinates are inverted (eg. for Solar coordinates), 0 otherwise. */
   int error_state;      /*!< @brief The state of these coordinates,
                                     indicating if they're okay to use.
                                     Note that this field is only valid
@@ -127,6 +129,7 @@
 int get_vsop_data_handle(const vsop_body planet, const vsop_version version, vsop_handle *vh);
 vsop_rec_coords vsop_get_rectangular(const vsop_handle vh, const double jd);
 vsop_rec_coords vsop_rec_vsop_to_fk5(const vsop_rec_coords vrc);
+vsop_rec_coords vsop_rec_invert(const vsop_rec_coords vrc);
 vsop_sph_coords vsop_get_spherical(const vsop_handle vh, const double jd);
 vsop_sph_coords vsop_sph_vsop_to_fk5(const vsop_sph_coords vsc);
 
@@ -138,7 +141,7 @@
 #define EPHEMERITIS_BIN_HEADER_TEXT_FORMAT "EphB v=%s"
 
 /* Define data path -- this should be updated to something configurable. */
-#define EPH_VSOP_DATA_PATH "/home/izogi/ephemeritis/branches/new-vsop-prepare/data/vsop/"
+#define EPH_VSOP_DATA_PATH "/home/izogi/misc/ephemeritis/branches/new-vsop-prepare/data/vsop/"
 
 /* Start with... */
 #define EPH_VSOP_PREFIX    "VSOP87"

Modified: branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c	2006-01-18 09:21:05 UTC (rev 215)
+++ branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c	2006-01-18 09:57:28 UTC (rev 216)
@@ -125,6 +125,7 @@
   memset(&vrc, '\0', sizeof(vrc));
   vrc.vh = vh;
   vrc.jd = jd;
+  vrc.is_inverted = 0;
 
   /* Get a reference to the body_elements structure for this handle. */
   body_elements *be;
@@ -194,7 +195,37 @@
   return output;
 }
 
+/*! @brief Given a set of rectangular VSOP coordinates, invert them.
+ *  This is useful, for instance, to convert rectangular Earth
+ *  coordinates to Sun coordinates.
+ *
+ *  The is_inverted property of the coordinates structure is flipped
+ *  in the returned value of this function.  If the provided
+ *  coordinates are in an error state, they are returned immediately
+ *  without any additional operations being performed.
+ *
+ *  @param[in]  vrc A set of rectangular coordinates.
+ *
+ *  @return A set of rectangular coordinates identical to those
+ *  provided, but inverted.
+ */
+vsop_rec_coords vsop_rec_invert(const vsop_rec_coords vrc)
+{
+  vsop_rec_coords output = vrc;
 
+  /* Stop right here if the incoming coordinates are in an error state. */
+  if(output.error_state != 0) {
+    return output;
+  }
+
+  output.rc.x = -output.rc.x;
+  output.rc.y = -output.rc.y;
+  output.rc.z = -output.rc.z;
+  output.is_inverted = output.is_inverted ^ 0x01;
+  return output;
+}
+
+
 /*! @brief Given a VSOP handle referencing data, and a Julian Date,
  *  calculates spherical variables.
  *
@@ -220,6 +251,7 @@
   memset(&vsc, '\0', sizeof(vsc));
   vsc.vh = vh;
   vsc.jd = jd;
+  vsc.is_inverted = 0;
 
   /* Get a reference to the body_elements structure for this handle. */
   body_elements *be;

Modified: branches/new-vsop-prepare/src/c/tests/validate_meeus.c
===================================================================
--- branches/new-vsop-prepare/src/c/tests/validate_meeus.c	2006-01-18 09:21:05 UTC (rev 215)
+++ branches/new-vsop-prepare/src/c/tests/validate_meeus.c	2006-01-18 09:57:28 UTC (rev 216)
@@ -1220,26 +1220,27 @@
 /* 	printf("File didn't load for some reason\n"); */
 /*       } */
 /*     } */
-/*     { */
-/* 	printf("Checking new VSOP routines\n"); */
-/* 	{ */
-/* 	  printf("Earth rectangular\n"); */
-/* 	  vsop_handle vh; */
-/* 	  if(0 != get_vsop_data_handle(vsop_earth, hel_rec_j2, &vh)) { */
-/* 	    printf("\t\tError loading Earth handle.\n"); */
-/* 	  } else { */
-/* 	    double jd = 2448170.5; */
-/* 	    vsop_rec_coords vrc = vsop_get_rectangular(vh, jd); */
+    {
+	printf("Checking new VSOP routines\n");
+	{
+	  vsop_handle vh;
+
+ 	  if(0 != get_vsop_data_handle(vsop_earth, hel_rec_j2, &vh)) {
+	    printf("\t\tError loading Earth handle.\n");
+	  } else {
+	    double jd = 2448170.5;
+	    vsop_rec_coords vrc = vsop_get_rectangular(vh, jd);
 	    
-/* 	    vrc = vsop_rec_vsop_to_fk5(vrc); */
+	    vrc = vsop_rec_invert(vsop_rec_vsop_to_fk5(vrc));
 	  
 
-/* 	    report("X", vrc.rc.x * km_per_au, 0.975673220683  * km_per_au, 1.0e-15, "km"); */
-/* 	    report("Y", vrc.rc.y * km_per_au, 0.200325394065  * km_per_au, 1.0e-15, "km"); */
-/* 	    report("Z", vrc.rc.z * km_per_au, 0.0868565820014 * km_per_au, 1.0e-15, "km"); */
+	    report("X", vrc.rc.x * km_per_au, -0.975673220683  * km_per_au, 1.0e-4, "km");
+	    report("Y", vrc.rc.y * km_per_au, -0.200325394065  * km_per_au, 1.0e-4, "km");
+	    report("Z", vrc.rc.z * km_per_au, -0.0868565820014 * km_per_au, 1.0e-4, "km");
 	  
-/* 	  } */
-/* 	} */
+	  }
+	}
+    }
 /* 	{ */
 /* 	  printf("Venus spherical\n"); */
 /* 	  vsop_handle vh; */

Modified: branches/new-vsop-prepare/src/python/vsop2-experiment.py
===================================================================
--- branches/new-vsop-prepare/src/python/vsop2-experiment.py	2006-01-18 09:21:05 UTC (rev 215)
+++ branches/new-vsop-prepare/src/python/vsop2-experiment.py	2006-01-18 09:57:28 UTC (rev 216)
@@ -101,11 +101,11 @@
   return val
 
 def run():
-  bd = load_data('/home/izogi/ephemeritis/branches/new-vsop-prepare/data/vsop/VSOP87B.ven')
-  jd = 2448976.5
+#  bd = load_data('/home/izogi/ephemeritis/branches/new-vsop-prepare/data/vsop/VSOP87B.ven')
+#  jd = 2448976.5
 
-#  bd = load_data('/home/izogi/ephemeritis/branches/new-vsop-prepare/data/vsop/VSOP87A.ear')
-#  jd = 2448170.5
+  bd = load_data('../../data/vsop/VSOP87A.ear')
+  jd = 2448170.5
 
   #double L, B, R;
   #vsop_dimension3_vsop(2448976.5, vVenus, &L, &B, &R);
@@ -125,20 +125,20 @@
 #  print "B: ", calc_at(bd, jd, 2)
 #  print "R: ", calc_at(bd, jd, 0)
 
-  print "L: ", calc_at(bd, jd, 0)
-  print "B: ", calc_at(bd, jd, 1)
-  print "R: ", calc_at(bd, jd, 2)
+#  print "L: ", calc_at(bd, jd, 0)
+#  print "B: ", calc_at(bd, jd, 1)
+#  print "R: ", calc_at(bd, jd, 2)
 
-#  x = calc_at(bd, jd, 0)
-#  y = calc_at(bd, jd, 1)
-#  z = calc_at(bd, jd, 2)
+  x = calc_at(bd, jd, 0)
+  y = calc_at(bd, jd, 1)
+  z = calc_at(bd, jd, 2)
 #  print "X0: ", -x
 #  print "Y0: ", -y
 #  print "Z0: ", -z
-#  (x,y,z) = vsop_to_fk5((x,y,z))
-#  print "X: ", -x
-#  print "Y: ", -y
-#  print "Z: ", -z
+  (x,y,z) = vsop_to_fk5((x,y,z))
+  print "X: ", -x
+  print "Y: ", -y
+  print "Z: ", -z
 
 if '__main__' == __name__:
   run()



From izogi at berlios.de  Wed Jan 18 11:03:50 2006
From: izogi at berlios.de (izogi at BerliOS)
Date: Wed, 18 Jan 2006 11:03:50 +0100
Subject: [Ephemeritis-svn] r217 - in branches/new-vsop-prepare/src/c: libephemeritis tests
Message-ID: <200601181003.k0IA3oQB001812@sheep.berlios.de>

Author: izogi
Date: 2006-01-18 11:03:50 +0100 (Wed, 18 Jan 2006)
New Revision: 217

Modified:
   branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.h
   branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c
   branches/new-vsop-prepare/src/c/tests/validate_meeus.c
Log:
Added vsop_sph_invert() for inverting spherical coordinates.


Modified: branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.h
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.h	2006-01-18 09:57:28 UTC (rev 216)
+++ branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.h	2006-01-18 10:03:50 UTC (rev 217)
@@ -132,6 +132,7 @@
 vsop_rec_coords vsop_rec_invert(const vsop_rec_coords vrc);
 vsop_sph_coords vsop_get_spherical(const vsop_handle vh, const double jd);
 vsop_sph_coords vsop_sph_vsop_to_fk5(const vsop_sph_coords vsc);
+vsop_sph_coords vsop_sph_invert(const vsop_sph_coords vsc);
 
 
 /* Stuff below here should probably be in a header file that's local to the internal code. */

Modified: branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c	2006-01-18 09:57:28 UTC (rev 216)
+++ branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c	2006-01-18 10:03:50 UTC (rev 217)
@@ -343,3 +343,32 @@
   output.sc.B += deltaB;
   return output;
 }
+
+/*! @brief Given a set of spherical VSOP coordinates, invert them.
+ *  This is useful, for instance, to convert rectangular Earth
+ *  coordinates to Sun coordinates.
+ *
+ *  The is_inverted property of the coordinates structure is flipped
+ *  in the returned value of this function.  If the provided
+ *  coordinates are in an error state, they are returned immediately
+ *  without any additional operations being performed.
+ *
+ *  @param[in]  vrc A set of spherical coordinates.
+ *
+ *  @return A set of spherical coordinates identical to those
+ *  provided, but inverted.
+ */
+vsop_sph_coords vsop_sph_invert(const vsop_sph_coords vsc)
+{
+  vsop_sph_coords output = vsc;
+
+  /* Stop right here if the incoming coordinates are in an error state. */
+  if(output.error_state != 0) {
+    return output;
+  }
+
+  output.sc.L = modpi2(output.sc.L + pi);
+  output.sc.B = -output.sc.B;
+  output.is_inverted = output.is_inverted ^ 0x01;
+  return output;
+}

Modified: branches/new-vsop-prepare/src/c/tests/validate_meeus.c
===================================================================
--- branches/new-vsop-prepare/src/c/tests/validate_meeus.c	2006-01-18 09:57:28 UTC (rev 216)
+++ branches/new-vsop-prepare/src/c/tests/validate_meeus.c	2006-01-18 10:03:50 UTC (rev 217)
@@ -1230,14 +1230,11 @@
 	  } else {
 	    double jd = 2448170.5;
 	    vsop_rec_coords vrc = vsop_get_rectangular(vh, jd);
-	    
 	    vrc = vsop_rec_invert(vsop_rec_vsop_to_fk5(vrc));
-	  
 
 	    report("X", vrc.rc.x * km_per_au, -0.975673220683  * km_per_au, 1.0e-4, "km");
 	    report("Y", vrc.rc.y * km_per_au, -0.200325394065  * km_per_au, 1.0e-4, "km");
 	    report("Z", vrc.rc.z * km_per_au, -0.0868565820014 * km_per_au, 1.0e-4, "km");
-	  
 	  }
 	}
     }



From izogi at berlios.de  Thu Jan 19 11:20:27 2006
From: izogi at berlios.de (izogi at BerliOS)
Date: Thu, 19 Jan 2006 11:20:27 +0100
Subject: [Ephemeritis-svn] r218 - in branches/new-vsop-prepare: . src/c/utils
Message-ID: <200601191020.k0JAKRbq002429@sheep.berlios.de>

Author: izogi
Date: 2006-01-19 11:20:25 +0100 (Thu, 19 Jan 2006)
New Revision: 218

Modified:
   branches/new-vsop-prepare/Makefile.am
   branches/new-vsop-prepare/src/c/utils/Makefile.am
Log:
Made a start at writing an install hook to build the VSOP data files to the pkgdatadir.  The hook doesn't work yet.


Modified: branches/new-vsop-prepare/Makefile.am
===================================================================
--- branches/new-vsop-prepare/Makefile.am	2006-01-18 10:03:50 UTC (rev 217)
+++ branches/new-vsop-prepare/Makefile.am	2006-01-19 10:20:25 UTC (rev 218)
@@ -6,6 +6,7 @@
 EXTRA_DIST = $(DX_CONFIG)
 MOSTLYCLEANFILES = $(DX_CLEANFILES)
 
+
 #####noinst_PROGRAMS = doxygen-doc
 
 #if DX_COND_man

Modified: branches/new-vsop-prepare/src/c/utils/Makefile.am
===================================================================
--- branches/new-vsop-prepare/src/c/utils/Makefile.am	2006-01-18 10:03:50 UTC (rev 217)
+++ branches/new-vsop-prepare/src/c/utils/Makefile.am	2006-01-19 10:20:25 UTC (rev 218)
@@ -14,6 +14,12 @@
 
 INCLUDES = -I../libephemeritis/
 
+# This install hook doesn't seem to work properly yet.
+install-exec-hook:
+	echo The output data dir is: $(srcdir)  $(distdir)  % $(top_srcdir)
+	find ../../../data/vsop -name "VSOP87*" -execdir ../../src/c/utils/build_vsop_data {} $(pkgdatadir)/$(basename {}).eph.bin \;
+
+
 ## if DEBUG
 ## 	DBG = debug
 ## else



From izogi at berlios.de  Mon Jan 23 09:47:19 2006
From: izogi at berlios.de (izogi at BerliOS)
Date: Mon, 23 Jan 2006 09:47:19 +0100
Subject: [Ephemeritis-svn] r219 - in branches/new-vsop-prepare/src/c: libephemeritis utils
Message-ID: <200601230847.k0N8lJRB011464@sheep.berlios.de>

Author: izogi
Date: 2006-01-23 09:47:17 +0100 (Mon, 23 Jan 2006)
New Revision: 219

Added:
   branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_internal.h
Modified:
   branches/new-vsop-prepare/src/c/libephemeritis/Makefile.am
   branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis.h
   branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.c
   branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.h
   branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c
   branches/new-vsop-prepare/src/c/utils/build_vsop_data.c
Log:
Rearranged header files to hide information that's internal to VSOP calculations.  (Mostly, at least -- there's still work to do.)


Modified: branches/new-vsop-prepare/src/c/libephemeritis/Makefile.am
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/Makefile.am	2006-01-19 10:20:25 UTC (rev 218)
+++ branches/new-vsop-prepare/src/c/libephemeritis/Makefile.am	2006-01-23 08:47:17 UTC (rev 219)
@@ -28,6 +28,6 @@
 	util.c
 
 include_HEADERS = ephemeritis.h ephemeritis_constid.h
-noinst_HEADERS = vsop_structures.h ephemeritis_vsop_data.h
+noinst_HEADERS = vsop_structures.h ephemeritis_vsop_internal.h
 
 libephemeritis_la_ldflags = --version-info 0:0:0

Modified: branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis.h
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis.h	2006-01-19 10:20:25 UTC (rev 218)
+++ branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis.h	2006-01-23 08:47:17 UTC (rev 219)
@@ -435,4 +435,120 @@
 void constid_name(const const_id constid, constellation_name * namedata);
 int get_const_id(const double ra, const double dec, const double epoch);
 
+
+
+
+/* /\*! @file ephemeritis_vsop_data.h */
+/*  * */
+/*  * Definitions for VSOP data and related functions.  This list is */
+/*  * included by various parts of the code and utilities to allow them */
+/*  * to share commonly understood data structures. */
+/*  * */
+/*  * @todo Document the structures. */
+/*  * @todo Figure out which parts of this should be available everywhere, and which parts should be internal to the data-handling code (in a separate header file). */
+/*  * @todo Update EPHEMERITIS_VSOP_DATA_PATH to make it configurable by the user at installation time. */
+/*  * */
+/*  * @author Mike McGavin. */
+/*  *\/ */
+
+#include "ephemeritis.h"
+
+/*! @brief A list of bodies recognised by the VSOP model.
+ */
+typedef enum {
+  vsop_mercury,			/*!< @brief Mercury */
+  vsop_venus,			/*!< @brief Venus   */
+  vsop_earth,			/*!< @brief Earth   */
+  vsop_mars,			/*!< @brief Mars    */
+  vsop_jupiter,			/*!< @brief Jupiter */
+  vsop_saturn,			/*!< @brief Saturn  */
+  vsop_uranus,			/*!< @brief Uranus  */
+  vsop_neptune,			/*!< @brief Neptune */
+  
+  vsop_sun,                     /*!< @brief Sun                   */
+  vsop_EMB                      /*!< @brief Earth-Moon barycentre */
+} vsop_body;
+
+/*! @brief A list of versions available for the VSOP model.
+ */
+typedef enum {
+    hel_ell_j2,			/*!< @brief Heliocentric Elliptic Elements J2000       */
+    hel_rec_j2,			/*!< @brief Heliocentric Rectangular Variables J2000   */
+    hel_sph_j2,			/*!< @brief Heliocentric Spherical Variables J2000     */
+    hel_rec_date,		/*!< @brief Heliocentric Rectangular Variables of date */
+    hel_sph_date,		/*!< @brief Heliocentric Spherical Variables of date   */
+    bar_rec_j2                  /*!< @brief Barycentric Rectangular Variables J2000    */
+} vsop_version;
+
+
+/*! @brief A user-available structure to refer to VSOP data.
+ */
+typedef struct {
+  vsop_body planet;     /*!< @brief The planet to which this data relates.  */
+  vsop_version version; /*!< @brief The series which this data is for.      */
+
+  int data_id;          /*!< @brief An internally recognised data identifier to identify where the data is held. */
+} vsop_handle;
+
+/*! @brief A struct to hold rectangular coordinates from a particular
+ *  calculation, including meta information about their calculation.
+ */
+typedef struct {
+  vsop_handle vh;       /*!< @brief The VSOP handle representing the data these coordinates were calculated from. */
+  double jd;            /*!< @brief The Julian Date of these coordinates, in dynamical time.                      */
+  rec_coords rc;        /*!< @brief The XYZ coordinates.                                                          */
+  int is_inverted;      /*!< @brief Set to 1 if these coordinates are inverted (eg. for Solar coordinates), 0 otherwise. */
+  int error_state;      /*!< @brief The state of these coordinates,
+                                    indicating if they're okay to use.
+                                    Note that this field is only valid
+                                    once the struct values have been
+                                    calculated at least once.
+
+				    0 indicates no error.
+				    -1 (vsop_get_rectangular) indicates a vsop_handle error.  (Data referenced by this handle wasn't found - perhaps it was unloaded.)
+				    -2 (vsop_get_rectangular) indicates that a vsop_handle referenced data that wasn't rectangular, or otherwise not suitable for providing rectangular coordinates.
+				    -3 (vsop_rec_vsop_to_fk5) indicates that supplied coordinates were unsuitable for converting to FK5.
+			*/
+} vsop_rec_coords;
+
+/*! @brief Struct for holding spherical coordinates.
+ */
+typedef struct {
+  double L;             /*!< @brief Heliocentric ecliptical longitude. */
+  double B;             /*!< @brief Heliocentric ecliptical latitude.  */
+  double R;             /*!< @brief The radius vector (distance to the Sun). */
+} sph_coords;
+
+/*! @brief A struct to hold spherical coordinates from a particular
+ *  calculation, including meta information about their calculation.
+ */
+typedef struct {
+  vsop_handle vh;       /*!< @brief The VSOP handle representing the data these coordinates were calculated from. */
+  double jd;            /*!< @brief The Julian Date of these coordinates, in dynamical time.                      */
+  sph_coords sc;        /*!< @brief The spherical coordinates.                                                   */
+  int is_inverted;      /*!< @brief Set to 1 if these coordinates are inverted (eg. for Solar coordinates), 0 otherwise. */
+  int error_state;      /*!< @brief The state of these coordinates,
+                                    indicating if they're okay to use.
+                                    Note that this field is only valid
+                                    once the struct values have been
+                                    calculated at least once.
+
+				    0 indicates no error.
+				    -1 (vsop_get_spherical) indicates a vsop_handle error.  (Data referenced by this handle wasn't found - perhaps it was unloaded.)
+				    -2 (vsop_get_spherical) indicates that a vsop_handle referenced data that wasn't spherical, or otherwise not suitable for providing spherical coordinates.  (This should really only happen if the data in the struct has been corrupted somehow.)
+				    -3 (vsop_rec_vsop_to_fk5) indicates that supplied coordinates were unsuitable for converting to FK5.
+			*/
+} vsop_sph_coords;
+
+void vsop_data_init();
+void vsop_data_cleanup();
+int get_vsop_data_handle(const vsop_body planet, const vsop_version version, vsop_handle *vh);
+vsop_rec_coords vsop_get_rectangular(const vsop_handle vh, const double jd);
+vsop_rec_coords vsop_rec_vsop_to_fk5(const vsop_rec_coords vrc);
+vsop_rec_coords vsop_rec_invert(const vsop_rec_coords vrc);
+vsop_sph_coords vsop_get_spherical(const vsop_handle vh, const double jd);
+vsop_sph_coords vsop_sph_vsop_to_fk5(const vsop_sph_coords vsc);
+vsop_sph_coords vsop_sph_invert(const vsop_sph_coords vsc);
+
+
 #endif

Modified: branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.c
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.c	2006-01-19 10:20:25 UTC (rev 218)
+++ branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.c	2006-01-23 08:47:17 UTC (rev 219)
@@ -24,7 +24,7 @@
  * @author Mike McGavin.
  */
 
-#include "ephemeritis_vsop_data.h"
+#include "ephemeritis_vsop_internal.h"
 #include "ephemeritis.h"
 
 #include <errno.h>

Modified: branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.h
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.h	2006-01-19 10:20:25 UTC (rev 218)
+++ branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.h	2006-01-23 08:47:17 UTC (rev 219)
@@ -1,223 +1,135 @@
-/* Copyright 2000, 2001, 2005 William McClain, Mike McGavin
+/* /\* Copyright 2000, 2001, 2005 William McClain, Mike McGavin */
 
-This file is part of Ephemeritis.
+/* This file is part of Ephemeritis. */
 
-Ephemeritis is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2 of the License, or
-(at your option) any later version.
+/* Ephemeritis is free software; you can redistribute it and/or modify */
+/* it under the terms of the GNU General Public License as published by */
+/* the Free Software Foundation; either version 2 of the License, or */
+/* (at your option) any later version. */
 
-Ephemeritis is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
+/* Ephemeritis is distributed in the hope that it will be useful, */
+/* but WITHOUT ANY WARRANTY; without even the implied warranty of */
+/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the */
+/* GNU General Public License for more details. */
 
-You should have received a copy of the GNU General Public License
-along with Ephemeritis; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-*/
+/* You should have received a copy of the GNU General Public License */
+/* along with Ephemeritis; if not, write to the Free Software */
+/* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */
+/* *\/ */
 
-#ifndef _ephemeritis_vsop_data_h_
-#define _ephemeritis_vsop_data_h_
+/* #ifndef _ephemeritis_vsop_data_h_ */
+/* #define _ephemeritis_vsop_data_h_ */
 
-/*! @file ephemeritis_vsop_data.h
- *
- * Definitions for VSOP data and related functions.  This list is
- * included by various parts of the code and utilities to allow them
- * to share commonly understood data structures.
- *
- * @todo Document the structures.
- * @todo Figure out which parts of this should be available everywhere, and which parts should be internal to the data-handling code (in a separate header file).
- * @todo Update EPHEMERITIS_VSOP_DATA_PATH to make it configurable by the user at installation time.
- *
- * @author Mike McGavin.
- */
+/* /\*! @file ephemeritis_vsop_data.h */
+/*  * */
+/*  * Definitions for VSOP data and related functions.  This list is */
+/*  * included by various parts of the code and utilities to allow them */
+/*  * to share commonly understood data structures. */
+/*  * */
+/*  * @todo Document the structures. */
+/*  * @todo Figure out which parts of this should be available everywhere, and which parts should be internal to the data-handling code (in a separate header file). */
+/*  * @todo Update EPHEMERITIS_VSOP_DATA_PATH to make it configurable by the user at installation time. */
+/*  * */
+/*  * @author Mike McGavin. */
+/*  *\/ */
 
-#include "ephemeritis.h"
+/* #include "ephemeritis.h" */
 
-#include <stdio.h>
-
-/*! @brief A list of bodies recognised by the VSOP model.
- */
-typedef enum {
-  vsop_mercury,			/*!< @brief Mercury */
-  vsop_venus,			/*!< @brief Venus   */
-  vsop_earth,			/*!< @brief Earth   */
-  vsop_mars,			/*!< @brief Mars    */
-  vsop_jupiter,			/*!< @brief Jupiter */
-  vsop_saturn,			/*!< @brief Saturn  */
-  vsop_uranus,			/*!< @brief Uranus  */
-  vsop_neptune,			/*!< @brief Neptune */
+/* /\*! @brief A list of bodies recognised by the VSOP model. */
+/*  *\/ */
+/* typedef enum { */
+/*   vsop_mercury,			/\*!< @brief Mercury *\/ */
+/*   vsop_venus,			/\*!< @brief Venus   *\/ */
+/*   vsop_earth,			/\*!< @brief Earth   *\/ */
+/*   vsop_mars,			/\*!< @brief Mars    *\/ */
+/*   vsop_jupiter,			/\*!< @brief Jupiter *\/ */
+/*   vsop_saturn,			/\*!< @brief Saturn  *\/ */
+/*   vsop_uranus,			/\*!< @brief Uranus  *\/ */
+/*   vsop_neptune,			/\*!< @brief Neptune *\/ */
   
-  vsop_sun,                     /*!< @brief Sun                   */
-  vsop_EMB                      /*!< @brief Earth-Moon barycentre */
-} vsop_body;
+/*   vsop_sun,                     /\*!< @brief Sun                   *\/ */
+/*   vsop_EMB                      /\*!< @brief Earth-Moon barycentre *\/ */
+/* } vsop_body; */
 
-/*! @brief A list of versions available for the VSOP model.
- */
-typedef enum {
-    hel_ell_j2,			/*!< @brief Heliocentric Elliptic Elements J2000       */
-    hel_rec_j2,			/*!< @brief Heliocentric Rectangular Variables J2000   */
-    hel_sph_j2,			/*!< @brief Heliocentric Spherical Variables J2000     */
-    hel_rec_date,		/*!< @brief Heliocentric Rectangular Variables of date */
-    hel_sph_date,		/*!< @brief Heliocentric Spherical Variables of date   */
-    bar_rec_j2                  /*!< @brief Barycentric Rectangular Variables J2000    */
-} vsop_version;
+/* /\*! @brief A list of versions available for the VSOP model. */
+/*  *\/ */
+/* typedef enum { */
+/*     hel_ell_j2,			/\*!< @brief Heliocentric Elliptic Elements J2000       *\/ */
+/*     hel_rec_j2,			/\*!< @brief Heliocentric Rectangular Variables J2000   *\/ */
+/*     hel_sph_j2,			/\*!< @brief Heliocentric Spherical Variables J2000     *\/ */
+/*     hel_rec_date,		/\*!< @brief Heliocentric Rectangular Variables of date *\/ */
+/*     hel_sph_date,		/\*!< @brief Heliocentric Spherical Variables of date   *\/ */
+/*     bar_rec_j2                  /\*!< @brief Barycentric Rectangular Variables J2000    *\/ */
+/* } vsop_version; */
 
 
-/*! @brief A user-available structure to refer to VSOP data.
- */
-typedef struct {
-  vsop_body planet;     /*!< @brief The planet to which this data relates.  */
-  vsop_version version; /*!< @brief The series which this data is for.      */
+/* /\*! @brief A user-available structure to refer to VSOP data. */
+/*  *\/ */
+/* typedef struct { */
+/*   vsop_body planet;     /\*!< @brief The planet to which this data relates.  *\/ */
+/*   vsop_version version; /\*!< @brief The series which this data is for.      *\/ */
 
-  int data_id;          /*!< @brief An internally recognised data identifier to identify where the data is held. */
-} vsop_handle;
+/*   int data_id;          /\*!< @brief An internally recognised data identifier to identify where the data is held. *\/ */
+/* } vsop_handle; */
 
-/*! @brief A struct to hold rectangular coordinates from a particular
- *  calculation, including meta information about their calculation.
- */
-typedef struct {
-  vsop_handle vh;       /*!< @brief The VSOP handle representing the data these coordinates were calculated from. */
-  double jd;            /*!< @brief The Julian Date of these coordinates, in dynamical time.                      */
-  rec_coords rc;        /*!< @brief The XYZ coordinates.                                                          */
-  int is_inverted;      /*!< @brief Set to 1 if these coordinates are inverted (eg. for Solar coordinates), 0 otherwise. */
-  int error_state;      /*!< @brief The state of these coordinates,
-                                    indicating if they're okay to use.
-                                    Note that this field is only valid
-                                    once the struct values have been
-                                    calculated at least once.
+/* /\*! @brief A struct to hold rectangular coordinates from a particular */
+/*  *  calculation, including meta information about their calculation. */
+/*  *\/ */
+/* typedef struct { */
+/*   vsop_handle vh;       /\*!< @brief The VSOP handle representing the data these coordinates were calculated from. *\/ */
+/*   double jd;            /\*!< @brief The Julian Date of these coordinates, in dynamical time.                      *\/ */
+/*   rec_coords rc;        /\*!< @brief The XYZ coordinates.                                                          *\/ */
+/*   int is_inverted;      /\*!< @brief Set to 1 if these coordinates are inverted (eg. for Solar coordinates), 0 otherwise. *\/ */
+/*   int error_state;      /\*!< @brief The state of these coordinates, */
+/*                                     indicating if they're okay to use. */
+/*                                     Note that this field is only valid */
+/*                                     once the struct values have been */
+/*                                     calculated at least once. */
 
-				    0 indicates no error.
-				    -1 (vsop_get_rectangular) indicates a vsop_handle error.  (Data referenced by this handle wasn't found - perhaps it was unloaded.)
-				    -2 (vsop_get_rectangular) indicates that a vsop_handle referenced data that wasn't rectangular, or otherwise not suitable for providing rectangular coordinates.
-				    -3 (vsop_rec_vsop_to_fk5) indicates that supplied coordinates were unsuitable for converting to FK5.
-			*/
-} vsop_rec_coords;
+/* 				    0 indicates no error. */
+/* 				    -1 (vsop_get_rectangular) indicates a vsop_handle error.  (Data referenced by this handle wasn't found - perhaps it was unloaded.) */
+/* 				    -2 (vsop_get_rectangular) indicates that a vsop_handle referenced data that wasn't rectangular, or otherwise not suitable for providing rectangular coordinates. */
+/* 				    -3 (vsop_rec_vsop_to_fk5) indicates that supplied coordinates were unsuitable for converting to FK5. */
+/* 			*\/ */
+/* } vsop_rec_coords; */
 
-/*! @brief Struct for holding spherical coordinates.
- */
-typedef struct {
-  double L;             /*!< @brief Heliocentric ecliptical longitude. */
-  double B;             /*!< @brief Heliocentric ecliptical latitude.  */
-  double R;             /*!< @brief The radius vector (distance to the Sun). */
-} sph_coords;
+/* /\*! @brief Struct for holding spherical coordinates. */
+/*  *\/ */
+/* typedef struct { */
+/*   double L;             /\*!< @brief Heliocentric ecliptical longitude. *\/ */
+/*   double B;             /\*!< @brief Heliocentric ecliptical latitude.  *\/ */
+/*   double R;             /\*!< @brief The radius vector (distance to the Sun). *\/ */
+/* } sph_coords; */
 
-/*! @brief A struct to hold spherical coordinates from a particular
- *  calculation, including meta information about their calculation.
- */
-typedef struct {
-  vsop_handle vh;       /*!< @brief The VSOP handle representing the data these coordinates were calculated from. */
-  double jd;            /*!< @brief The Julian Date of these coordinates, in dynamical time.                      */
-  sph_coords sc;        /*!< @brief The spherical coordinates.                                                   */
-  int is_inverted;      /*!< @brief Set to 1 if these coordinates are inverted (eg. for Solar coordinates), 0 otherwise. */
-  int error_state;      /*!< @brief The state of these coordinates,
-                                    indicating if they're okay to use.
-                                    Note that this field is only valid
-                                    once the struct values have been
-                                    calculated at least once.
+/* /\*! @brief A struct to hold spherical coordinates from a particular */
+/*  *  calculation, including meta information about their calculation. */
+/*  *\/ */
+/* typedef struct { */
+/*   vsop_handle vh;       /\*!< @brief The VSOP handle representing the data these coordinates were calculated from. *\/ */
+/*   double jd;            /\*!< @brief The Julian Date of these coordinates, in dynamical time.                      *\/ */
+/*   sph_coords sc;        /\*!< @brief The spherical coordinates.                                                   *\/ */
+/*   int is_inverted;      /\*!< @brief Set to 1 if these coordinates are inverted (eg. for Solar coordinates), 0 otherwise. *\/ */
+/*   int error_state;      /\*!< @brief The state of these coordinates, */
+/*                                     indicating if they're okay to use. */
+/*                                     Note that this field is only valid */
+/*                                     once the struct values have been */
+/*                                     calculated at least once. */
 
-				    0 indicates no error.
-				    -1 (vsop_get_spherical) indicates a vsop_handle error.  (Data referenced by this handle wasn't found - perhaps it was unloaded.)
-				    -2 (vsop_get_spherical) indicates that a vsop_handle referenced data that wasn't spherical, or otherwise not suitable for providing spherical coordinates.  (This should really only happen if the data in the struct has been corrupted somehow.)
-				    -3 (vsop_rec_vsop_to_fk5) indicates that supplied coordinates were unsuitable for converting to FK5.
-			*/
-} vsop_sph_coords;
+/* 				    0 indicates no error. */
+/* 				    -1 (vsop_get_spherical) indicates a vsop_handle error.  (Data referenced by this handle wasn't found - perhaps it was unloaded.) */
+/* 				    -2 (vsop_get_spherical) indicates that a vsop_handle referenced data that wasn't spherical, or otherwise not suitable for providing spherical coordinates.  (This should really only happen if the data in the struct has been corrupted somehow.) */
+/* 				    -3 (vsop_rec_vsop_to_fk5) indicates that supplied coordinates were unsuitable for converting to FK5. */
+/* 			*\/ */
+/* } vsop_sph_coords; */
 
-void vsop_data_init();
-void vsop_data_cleanup();
-int get_vsop_data_handle(const vsop_body planet, const vsop_version version, vsop_handle *vh);
-vsop_rec_coords vsop_get_rectangular(const vsop_handle vh, const double jd);
-vsop_rec_coords vsop_rec_vsop_to_fk5(const vsop_rec_coords vrc);
-vsop_rec_coords vsop_rec_invert(const vsop_rec_coords vrc);
-vsop_sph_coords vsop_get_spherical(const vsop_handle vh, const double jd);
-vsop_sph_coords vsop_sph_vsop_to_fk5(const vsop_sph_coords vsc);
-vsop_sph_coords vsop_sph_invert(const vsop_sph_coords vsc);
+/* void vsop_data_init(); */
+/* void vsop_data_cleanup(); */
+/* int get_vsop_data_handle(const vsop_body planet, const vsop_version version, vsop_handle *vh); */
+/* vsop_rec_coords vsop_get_rectangular(const vsop_handle vh, const double jd); */
+/* vsop_rec_coords vsop_rec_vsop_to_fk5(const vsop_rec_coords vrc); */
+/* vsop_rec_coords vsop_rec_invert(const vsop_rec_coords vrc); */
+/* vsop_sph_coords vsop_get_spherical(const vsop_handle vh, const double jd); */
+/* vsop_sph_coords vsop_sph_vsop_to_fk5(const vsop_sph_coords vsc); */
+/* vsop_sph_coords vsop_sph_invert(const vsop_sph_coords vsc); */
 
-
-/* Stuff below here should probably be in a header file that's local to the internal code. */
-
-
-
-#define EPHEMERITIS_BIN_HEADER_TEXT_FORMAT "EphB v=%s"
-
-/* Define data path -- this should be updated to something configurable. */
-#define EPH_VSOP_DATA_PATH "/home/izogi/misc/ephemeritis/branches/new-vsop-prepare/data/vsop/"
-
-/* Start with... */
-#define EPH_VSOP_PREFIX    "VSOP87"
-
-/* Add one of... */
-#define EPH_VSOP_HEJ2      ""
-#define EPH_VSOP_HRJ2      "A"
-#define EPH_VSOP_HSJ2      "B"
-#define EPH_VSOP_HRD       "C"
-#define EPH_VSOP_HSD       "D"
-#define EPH_VSOP_BRJ2      "E"
-
-/* Followed by... */
-#define EPH_MER  "mer"
-#define EPH_VEN  "ven"
-#define EPH_EAR  "ear"
-#define EPH_MAR  "mar"
-#define EPH_JUP  "jup"
-#define EPH_SAT  "sat"
-#define EPH_URA  "ura"
-#define EPH_NEP  "nep"
-
-#define EPH_SOL  "sun"
-#define EPH_EMB  "emb"
-
-/* The suffix for binary files. */
-#define EPH_VSOP_SUFFIX    ".eph.bin"
-
-/*! @brief Represents a VSOP87 term.
- */
-typedef struct {
-  double A, B, C;
-} term_bin;
-
-
-typedef struct {
-  struct {
-    char alpha;          /*!< @brief The degree alpha of time variable for this series. */
-    short int num_terms; /*!< @brief The number of terms listed for this series. */
-  } meta;
-
-  term_bin *terms;     /*!< @brief The terms. */
-} series;
-
-
-
-/*! @brief Collects together a particular set of elements for a
- *  particular body.
- */
-typedef struct {
-  struct{
-    char eph_header_text[23]; /*!< @brief Ephemeritis header text.                            */
-    char body_name[8];        /*!< @brief The name of the body represented by these elements. */
-    char num_variables;       /*!< @brief The number of variables included in these elements. */
-  } meta;
-
-/*   vsop_body planet;           /\*!< @brief The body for which these elements are designated.   *\/ */
-/*   vsop_version version;       /\*!< @brief The version that these elements will calculate.     *\/ */
-
-  struct {
-    struct {
-      char series_count;   /*!< @brief The number of series' listed in the series_list field. */
-    } meta;                /*!< @brief Binary meta data about the VSOP variable.              */
-
-    series *series_list;   /*!< @brief The series list.                   */
-  } variable_list[6];      /*!< @brief The variables.                     */
-
-} body_elements;
-
-
-void print_body_statistics(FILE *ostream, body_elements *b);
-void write_body_elements(FILE *outfile, body_elements *b);
-body_elements *read_body_elements(FILE *infile);
-void free_body_elements(body_elements *b);
-body_elements *get_body_elements_for_handle(const vsop_handle vh);
-
-
-#endif
+/* #endif */

Added: branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_internal.h
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_internal.h	2006-01-19 10:20:25 UTC (rev 218)
+++ branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_internal.h	2006-01-23 08:47:17 UTC (rev 219)
@@ -0,0 +1,118 @@
+/* Copyright 2000, 2001, 2005 William McClain, Mike McGavin
+
+This file is part of Ephemeritis.
+
+Ephemeritis is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+Ephemeritis is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Ephemeritis; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#ifndef _ephemeritis_vsop_internal_h_
+#define _ephemeritis_vsop_internal_h_
+
+#include "ephemeritis.h"
+
+/*! @file ephemeritis_vsop_internal.h
+ *
+ * Definitions for VSOP data and related functions.  This list is
+ * included by various parts of the code and utilities to allow them
+ * to share commonly understood data structures.
+ *
+ * @todo Document the defines.
+ * @todo Update EPHEMERITIS_VSOP_DATA_PATH to make it configurable by the user at installation time.
+ *
+ * @author Mike McGavin.
+ */
+
+
+#include <stdio.h>
+
+#define EPHEMERITIS_BIN_HEADER_TEXT_FORMAT "EphB v=%s"
+
+/* Define data path -- this should be updated to something configurable. */
+#define EPH_VSOP_DATA_PATH "/home/izogi/misc/ephemeritis/branches/new-vsop-prepare/data/vsop/"
+
+/* Start with... */
+#define EPH_VSOP_PREFIX    "VSOP87"
+
+/* Add one of... */
+#define EPH_VSOP_HEJ2      ""
+#define EPH_VSOP_HRJ2      "A"
+#define EPH_VSOP_HSJ2      "B"
+#define EPH_VSOP_HRD       "C"
+#define EPH_VSOP_HSD       "D"
+#define EPH_VSOP_BRJ2      "E"
+
+/* Followed by... */
+#define EPH_MER  "mer"
+#define EPH_VEN  "ven"
+#define EPH_EAR  "ear"
+#define EPH_MAR  "mar"
+#define EPH_JUP  "jup"
+#define EPH_SAT  "sat"
+#define EPH_URA  "ura"
+#define EPH_NEP  "nep"
+
+#define EPH_SOL  "sun"
+#define EPH_EMB  "emb"
+
+/* The suffix for binary files. */
+#define EPH_VSOP_SUFFIX    ".eph.bin"
+
+/*! @brief Represents a VSOP87 term.
+ */
+typedef struct {
+  double A, B, C;
+} term_bin;
+
+
+typedef struct {
+  struct {
+    char alpha;          /*!< @brief The degree alpha of time variable for this series. */
+    short int num_terms; /*!< @brief The number of terms listed for this series. */
+  } meta;
+
+  term_bin *terms;     /*!< @brief The terms. */
+} series;
+
+
+
+/*! @brief Collects together a particular set of elements for a
+ *  particular body.
+ */
+typedef struct {
+  struct{
+    char eph_header_text[23]; /*!< @brief Ephemeritis header text.                            */
+    char body_name[8];        /*!< @brief The name of the body represented by these elements. */
+    char num_variables;       /*!< @brief The number of variables included in these elements. */
+  } meta;
+
+  struct {
+    struct {
+      char series_count;   /*!< @brief The number of series' listed in the series_list field. */
+    } meta;                /*!< @brief Binary meta data about the VSOP variable.              */
+
+    series *series_list;   /*!< @brief The series list.                   */
+  } variable_list[6];      /*!< @brief The variables.                     */
+
+} body_elements;
+
+
+void print_body_statistics(FILE *ostream, body_elements *b);
+void write_body_elements(FILE *outfile, body_elements *b);
+body_elements *read_body_elements(FILE *infile);
+void free_body_elements(body_elements *b);
+body_elements *get_body_elements_for_handle(const vsop_handle vh);
+
+
+#endif

Modified: branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c	2006-01-19 10:20:25 UTC (rev 218)
+++ branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c	2006-01-23 08:47:17 UTC (rev 219)
@@ -27,7 +27,7 @@
  */
 
 #include "ephemeritis.h"
-#include "ephemeritis_vsop_data.h"
+#include "ephemeritis_vsop_internal.h"
 #include "config.h"
 
 #include <math.h>

Modified: branches/new-vsop-prepare/src/c/utils/build_vsop_data.c
===================================================================
--- branches/new-vsop-prepare/src/c/utils/build_vsop_data.c	2006-01-19 10:20:25 UTC (rev 218)
+++ branches/new-vsop-prepare/src/c/utils/build_vsop_data.c	2006-01-23 08:47:17 UTC (rev 219)
@@ -32,6 +32,7 @@
 
 #include "config.h"
 #include <ephemeritis_vsop_data.h>
+#include <ephemeritis_vsop_internal.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <errno.h>
@@ -80,9 +81,6 @@
   t->A = atof(ch_A);
   t->B = atof(ch_B);
   t->C = atof(ch_C);
-  /*
-  printf("%.16f, %.16f, %.16f\n", t->A, t->B, t->C);
-  */
 }
 
 



From izogi at berlios.de  Mon Jan 23 10:11:50 2006
From: izogi at berlios.de (izogi at BerliOS)
Date: Mon, 23 Jan 2006 10:11:50 +0100
Subject: [Ephemeritis-svn] r220 - in branches/new-vsop-prepare/src/c: libephemeritis tests utils
Message-ID: <200601230911.k0N9Boo3013622@sheep.berlios.de>

Author: izogi
Date: 2006-01-23 10:11:48 +0100 (Mon, 23 Jan 2006)
New Revision: 220

Added:
   branches/new-vsop-prepare/src/c/libephemeritis/vsop_data_handling.c
Removed:
   branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.c
   branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.h
Modified:
   branches/new-vsop-prepare/src/c/libephemeritis/Makefile.am
   branches/new-vsop-prepare/src/c/tests/validate_meeus.c
   branches/new-vsop-prepare/src/c/utils/build_vsop_data.c
Log:
More re-arranging of code locations.


Modified: branches/new-vsop-prepare/src/c/libephemeritis/Makefile.am
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/Makefile.am	2006-01-23 08:47:17 UTC (rev 219)
+++ branches/new-vsop-prepare/src/c/libephemeritis/Makefile.am	2006-01-23 09:11:48 UTC (rev 220)
@@ -13,7 +13,6 @@
 	dynamical.c \
 	elliptical.c \
 	elp2000.c \
-	ephemeritis_vsop_data.c \
 	equationoftime.c \
 	equinox.c \
 	nutation.c \
@@ -23,6 +22,7 @@
 	separation.c \
 	solar.c \
 	vsop_calculate.c \
+	vsop_data_handling.c \
 	vsopdata.c \
 	vsop87d.c \
 	util.c

Deleted: branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.c
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.c	2006-01-23 08:47:17 UTC (rev 219)
+++ branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.c	2006-01-23 09:11:48 UTC (rev 220)
@@ -1,400 +0,0 @@
-/* Copyright 2000, 2001, 2005 William McClain, Mike McGavin
-
-This file is part of Ephemeritis.
-
-Ephemeritis is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2 of the License, or
-(at your option) any later version.
-
-Ephemeritis is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with Ephemeritis; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-*/
-
-/*! @file ephemeritis_vsop_data.c
- *
- * @brief Management of VSOP data files, and in-memory structures.
- *
- * @author Mike McGavin.
- */
-
-#include "ephemeritis_vsop_internal.h"
-#include "ephemeritis.h"
-
-#include <errno.h>
-#include <stdlib.h>
-#include <string.h>
-#include <stdio.h>
-
-/*! @brief De-allocates the space that was allocated for a series
- *  structure in memory.
- *
- *  @param[in] s The series struct.
- */
-static void destroy_series(series s)
-{
-  free(s.terms);
-}
-
-/*! @brief De-allocates the space that was allocated for a
- *  body_elements structure in memory.
- *
- *  @param[in] b A pointer to a body_elements object.  This will be
- *  free()'d, as will the entire strucutre underneath it.  Ensure that
- *  nothing inside is referenced from elsewhere.
- */
-void free_body_elements(body_elements *b)
-{
-  int n;
-  for(n = 0; n < b->meta.num_variables; n++) {
-    int o;
-    for(o = 0; o < b->variable_list[n].meta.series_count; o++) {
-      /* Destroy each series. */
-      destroy_series(b->variable_list[n].series_list[o]);
-    }
-
-    /* Free the list of series for the variable. */
-    free(b->variable_list[n].series_list);
-  }
-  
-  free(b);
-}
-
-/*! @brief Prints details about the body elements in a human readable
- *  form.
- *
- *  @param[in] ostream A stream pointer to which the text should be printed.  (eg. stdin, stderr, or an open file.)
- *  @param[in] b       Pointer to the body elements.
- */
-void print_body_statistics(FILE *ostream, body_elements *b)
-{
-  fprintf(ostream, "Ephemeritis Version String: %s.\n", b->meta.eph_header_text);
-  fprintf(ostream, "Data for \"%s\".\n", b->meta.body_name);
-  fprintf(ostream, "%d variables overall.\n", b->meta.num_variables);
-
-  int v;
-  for(v=0; v<b->meta.num_variables; v++) {
-    fprintf(ostream, "\nVariable %d contains %d series':\n\n", v, b->variable_list[v].meta.series_count);
-
-    int s;
-    for(s=0; s<b->variable_list[v].meta.series_count; s++) {
-      series *ser = &(b->variable_list[v].series_list[s]);
-      fprintf(ostream, "  Series %d has alpha %d and contains %d terms.\n", s, ser->meta.alpha, (ser->meta.num_terms));
-    }
-  }
-}
-
-/*! @brief Given an open output file and a body_elements structure,
- *  output the body elements in binary format.
- *
- *  @param[in] outfile An open file to which the data should be written. The file is not closed after the operation.
- *  @param[in] b       Pointer to the body elements.
- */
-void write_body_elements(FILE *outfile, body_elements *b)
-{
-  /* Write the header data. */
-  fwrite(&b->meta, sizeof(b->meta), 1, outfile);
-
-  /* Loop through the variables, writing data of each one. */
-  int v;
-  for(v = 0; v < b->meta.num_variables; v++) {
-    fwrite(&b->variable_list[v].meta, sizeof(b->variable_list[v].meta), 1, outfile);
-
-    /* Loop through the series variables, writing data of each one. */
-    int s;
-    for(s = 0; s < b->variable_list[v].meta.series_count; s++) {
-      series *ser = &b->variable_list[v].series_list[s];
-      fwrite(&ser->meta, sizeof(ser->meta), 1, outfile);
-
-      /* Write the list of terms. */
-      fwrite(ser->terms, sizeof(*(ser->terms)), ser->meta.num_terms, outfile);
-    }
-  }
-}
-
-
-/*! @brief Given an open input file and a body_elements structure,
- *  read the body elements from binary format.
- *
- *  @param[in] infile  An open file from which the data should be
- *                     read. The file should be set to the beginning of its data, and is
- *                     not closed after the operation.
- *
- *  @return            Pointer to the body elements that have been read.
- *
- *  @bug Doesn't indicate if there was an error, such as corrupted
- *  data.  What should properly happen is that the function should
- *  clean up whatever memory mess it's caused, and return NULL.
- */
-body_elements *read_body_elements(FILE *infile)
-{
-  body_elements *b;
-
-  /* Allocate memory for the body_elements. */
-  b = (body_elements *)malloc(sizeof(body_elements));
-
-  /* Read the header data. */
-  fread(&b->meta, sizeof(b->meta), 1, infile);
-
-  /* Loop through the variables, reading data for each one. */
-  int v;
-  for(v = 0; v < b->meta.num_variables; v++) {
-    fread(&b->variable_list[v].meta, sizeof(b->variable_list[v].meta), 1, infile);
-
-    /* Allocate memory to hold the list of series' for this variable. */
-    b->variable_list[v].series_list = (series *)calloc(b->variable_list[v].meta.series_count, sizeof(series));
-
-    /* Loop through the series variables, reading data from each one. */
-    int s;
-    for(s = 0; s < b->variable_list[v].meta.series_count; s++) {
-      /* Read meta data for this series. */
-      series *ser = &b->variable_list[v].series_list[s];
-      fread(&ser->meta, sizeof(ser->meta), 1, infile);
-
-      /* Allocate memory for the terms. */
-      ser->terms = (term_bin *)calloc(ser->meta.num_terms, sizeof(term_bin));
-
-      /* Read the list of terms. */
-      fread(ser->terms, sizeof(*(ser->terms)), ser->meta.num_terms, infile);
-    }
-  }
-
-  return b;
-}
-
-
-
-
-
-/*! @brief Internal struct to hold id data about a vsop_handle.
- */
-typedef struct {
-  vsop_handle h;
-  body_elements *be;
-} vsop_handle_wrapper;
-
-static vsop_handle_wrapper *vhw_list = NULL;
-static int vhw_list_size = 0;
-static int next_data_id = 1;
-
-/*! @brief Initialise the VSOP data handling functionality.  This
-    should be called before using any VSOP data handling routines.
- *
- *  Calling this function initialises all the internal memory handling
- *  overheads, and so on.
- */
-void vsop_data_init()
-{
-  vhw_list = NULL;
-  vhw_list_size = 0;
-}
-
-/*! @brief Cleans up the VSOP data handling functionality.  This
- *  should be called after using any VSOP data handling routines.
- *
- *  Calling this function cleans up all the internal memory handling
- *  overheads, and so on.
- */
-void vsop_data_cleanup()
-{
-  /* Loop through every loaded data set, and release it. */
-
-  /* Release the list, and re-initialise the meta variables. */
-  free(vhw_list);
-  vhw_list = NULL;
-  vhw_list_size = 0;
-}
-
-
-/*! @brief Check to see if data matching that requested is already in
- *  memory.  If so, copy it to an output variable, and return true.
- *
- *  @param[in] planet  The planet being requested.
- *  @param[in] version The version of the VSOP data being requested.
- *
- *  @param[out] h      A location where the vsop_handle data for the requested planet and version will be copied.
- *
- *  @return true if the data was loaded and returned, otherwise false.
- */
-static bool get_vsop_handle(const vsop_body planet, const vsop_version version, vsop_handle *h)
-{
-  int n;
-  for(n = 0; n < vhw_list_size; n++) {
-    if(planet == vhw_list[n].h.planet && version == vhw_list[n].h.version) {
-      *h = vhw_list[n].h;
-      return true;
-    }
-  }
-  return false;
-}
-
-
-typedef struct {
-  vsop_version v;
-  char *str;
-} version_str_map_type;
-
-
-typedef struct {
-  vsop_body p;
-  char *str;
-} body_str_map_type;
-
-static version_str_map_type version_str_map[] = {
-  {hel_ell_j2,   EPH_VSOP_HEJ2},
-  {hel_rec_j2,   EPH_VSOP_HRJ2},
-  {hel_sph_j2,   EPH_VSOP_HSJ2},
-  {hel_rec_date, EPH_VSOP_HRD },
-  {hel_sph_date, EPH_VSOP_HSD },
-  {bar_rec_j2,   EPH_VSOP_BRJ2}
-};
-
-static char *version_map_lookup(vsop_version v)
-{
-  int n;
-  for(n = 0; n < sizeof(version_str_map) / sizeof(*version_str_map); n++) {
-    if(v == version_str_map[n].v) {
-      return version_str_map[n].str;
-    }
-  }
-  return NULL;
-}
-
-static body_str_map_type body_str_map[] = {
-  {vsop_mercury, EPH_MER},
-  {vsop_venus,   EPH_VEN},
-  {vsop_earth,   EPH_EAR},
-  {vsop_mars,    EPH_MAR},
-  {vsop_jupiter, EPH_JUP},
-  {vsop_saturn,  EPH_SAT},
-  {vsop_uranus,  EPH_URA},
-  {vsop_neptune, EPH_NEP},
-  {vsop_sun,     EPH_SOL},
-  {vsop_EMB,     EPH_EMB}
-};
-
-static char *planet_map_lookup(vsop_body p)
-{
-  int n;
-  for(n = 0; n < sizeof(body_str_map) / sizeof(*body_str_map); n++) {
-    if(p == body_str_map[n].p) {
-      return body_str_map[n].str;
-    }
-  }
-  return NULL;
-}
-
-/* Assumes that the handle isn't already loaded, and that the data in
-   the file isn't corrupt, so use with care. */
-static int load_vsop_handle(const vsop_body planet, const vsop_version version, vsop_handle *vh)
-{
-  /* Construct the filename. */
-  char filename[512];
-  strncpy(filename, EPH_VSOP_DATA_PATH, 512);
-  strncat(filename, EPH_VSOP_PREFIX, 512);
-  strncat(filename, version_map_lookup(version), 512);
-  strncat(filename, ".", 512);
-  strncat(filename, planet_map_lookup(planet), 512);
-  strncat(filename, EPH_VSOP_SUFFIX, 512);
-  filename[511] = '\0';
-
-  /* Try to open the file. */
-  FILE *f;
-  errno = 0;
-  if(NULL == (f = fopen(filename, "rb"))) {
-    /* File didn't open for some reason.  Probably not there. */
-    return errno;
-  }
-
-  /* Attempt to read data from the file. */
-  body_elements *be = read_body_elements(f);
-
-
-  /* Note that there's no checking to make sure the file was loaded successfully.  This is bad. */
-
-
-  /* Close the file. */
-  errno = 0;
-  if(0 != fclose(f)) {
-    return errno;
-  }
-  
-
-  /* Allocate more space in the list of vsop handle wrappers. */
-  vhw_list = (vsop_handle_wrapper *)realloc(vhw_list, ++vhw_list_size * sizeof(vsop_handle_wrapper));
-
-  vhw_list[vhw_list_size-1].be = be;
-  vhw_list[vhw_list_size-1].h.data_id = next_data_id++;
-  vhw_list[vhw_list_size-1].h.planet = planet;
-  vhw_list[vhw_list_size-1].h.version = version;
-
-  *vh = vhw_list[vhw_list_size-1].h;
-  return 0;
-}
-
-/*! @brief Returns a handle for accessing available VSOP data.
- *
- *  Data is stored in files on disk, with each file containing data
- *  for a particular planet and a version.  Ephemeritis keeps an
- *  internal cache of data that's already been loaded, and the cache
- *  will be checked first to see if a handle for the data is already
- *  available.  If it's not loaded already, the function will attempt
- *  to load the data from the file.
- *
- *  Note that data may not always be available.  It might not be
- *  installed (with the data file not being available), or the
- *  combination of planet and version might not make sense.
- *
- *  @param[in] planet  The planet for which the data is being requested.
- *  @param[in] version The version of VSOP data being requested.
- *
- *  @param[out] vh  A location to place the vsop_handle, if it's available.
- *
- *  @return 0 if the requested data was available (and returned),
- *  otherwise an errno value that could have been set by fopen() or
- *  fclose() is returned.
- */
-int get_vsop_data_handle(const vsop_body planet, const vsop_version version, vsop_handle *vh)
-{
-  /* Check to see if the data for this planet/series is already loaded. */
-  if(get_vsop_handle(planet, version, vh)) {
-    /* If so, return the handle.       */
-    return 0;
-  } else {
-    /* If not, load it, then return it. */
-    return load_vsop_handle(planet, version, vh);
-  }
-}
-
-/*! @brief Maps a specified vsop_handle to the loaded body elements that it represents.
- *
- *  Given a vsop_handle (which is abstract from the loaded data), this
- *  function locates the body_elements structure to which the handle
- *  maps.
- *
- *  @param[in] vh The handle that represents the elements to search for.
- *
- *  @return A pointer to a structure containing the elements
- *  associated with the specified vsop_handle, if it exists.
- *  Otherwise NULL.
- *
- */
-body_elements *get_body_elements_for_handle(const vsop_handle vh)
-{
-  int n;
-  for(n = 0; n < vhw_list_size; n++) {
-    if(vh.data_id == vhw_list[n].h.data_id) {
-      /* Found the handle, so return its associated body_elements structure. */
-      return vhw_list[n].be;
-    }
-  }
-
-  /* The handle wasn't found in the list of loaded data, so return NULL. */
-  return NULL;
-}

Deleted: branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.h
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.h	2006-01-23 08:47:17 UTC (rev 219)
+++ branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.h	2006-01-23 09:11:48 UTC (rev 220)
@@ -1,135 +0,0 @@
-/* /\* Copyright 2000, 2001, 2005 William McClain, Mike McGavin */
-
-/* This file is part of Ephemeritis. */
-
-/* Ephemeritis is free software; you can redistribute it and/or modify */
-/* it under the terms of the GNU General Public License as published by */
-/* the Free Software Foundation; either version 2 of the License, or */
-/* (at your option) any later version. */
-
-/* Ephemeritis is distributed in the hope that it will be useful, */
-/* but WITHOUT ANY WARRANTY; without even the implied warranty of */
-/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the */
-/* GNU General Public License for more details. */
-
-/* You should have received a copy of the GNU General Public License */
-/* along with Ephemeritis; if not, write to the Free Software */
-/* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */
-/* *\/ */
-
-/* #ifndef _ephemeritis_vsop_data_h_ */
-/* #define _ephemeritis_vsop_data_h_ */
-
-/* /\*! @file ephemeritis_vsop_data.h */
-/*  * */
-/*  * Definitions for VSOP data and related functions.  This list is */
-/*  * included by various parts of the code and utilities to allow them */
-/*  * to share commonly understood data structures. */
-/*  * */
-/*  * @todo Document the structures. */
-/*  * @todo Figure out which parts of this should be available everywhere, and which parts should be internal to the data-handling code (in a separate header file). */
-/*  * @todo Update EPHEMERITIS_VSOP_DATA_PATH to make it configurable by the user at installation time. */
-/*  * */
-/*  * @author Mike McGavin. */
-/*  *\/ */
-
-/* #include "ephemeritis.h" */
-
-/* /\*! @brief A list of bodies recognised by the VSOP model. */
-/*  *\/ */
-/* typedef enum { */
-/*   vsop_mercury,			/\*!< @brief Mercury *\/ */
-/*   vsop_venus,			/\*!< @brief Venus   *\/ */
-/*   vsop_earth,			/\*!< @brief Earth   *\/ */
-/*   vsop_mars,			/\*!< @brief Mars    *\/ */
-/*   vsop_jupiter,			/\*!< @brief Jupiter *\/ */
-/*   vsop_saturn,			/\*!< @brief Saturn  *\/ */
-/*   vsop_uranus,			/\*!< @brief Uranus  *\/ */
-/*   vsop_neptune,			/\*!< @brief Neptune *\/ */
-  
-/*   vsop_sun,                     /\*!< @brief Sun                   *\/ */
-/*   vsop_EMB                      /\*!< @brief Earth-Moon barycentre *\/ */
-/* } vsop_body; */
-
-/* /\*! @brief A list of versions available for the VSOP model. */
-/*  *\/ */
-/* typedef enum { */
-/*     hel_ell_j2,			/\*!< @brief Heliocentric Elliptic Elements J2000       *\/ */
-/*     hel_rec_j2,			/\*!< @brief Heliocentric Rectangular Variables J2000   *\/ */
-/*     hel_sph_j2,			/\*!< @brief Heliocentric Spherical Variables J2000     *\/ */
-/*     hel_rec_date,		/\*!< @brief Heliocentric Rectangular Variables of date *\/ */
-/*     hel_sph_date,		/\*!< @brief Heliocentric Spherical Variables of date   *\/ */
-/*     bar_rec_j2                  /\*!< @brief Barycentric Rectangular Variables J2000    *\/ */
-/* } vsop_version; */
-
-
-/* /\*! @brief A user-available structure to refer to VSOP data. */
-/*  *\/ */
-/* typedef struct { */
-/*   vsop_body planet;     /\*!< @brief The planet to which this data relates.  *\/ */
-/*   vsop_version version; /\*!< @brief The series which this data is for.      *\/ */
-
-/*   int data_id;          /\*!< @brief An internally recognised data identifier to identify where the data is held. *\/ */
-/* } vsop_handle; */
-
-/* /\*! @brief A struct to hold rectangular coordinates from a particular */
-/*  *  calculation, including meta information about their calculation. */
-/*  *\/ */
-/* typedef struct { */
-/*   vsop_handle vh;       /\*!< @brief The VSOP handle representing the data these coordinates were calculated from. *\/ */
-/*   double jd;            /\*!< @brief The Julian Date of these coordinates, in dynamical time.                      *\/ */
-/*   rec_coords rc;        /\*!< @brief The XYZ coordinates.                                                          *\/ */
-/*   int is_inverted;      /\*!< @brief Set to 1 if these coordinates are inverted (eg. for Solar coordinates), 0 otherwise. *\/ */
-/*   int error_state;      /\*!< @brief The state of these coordinates, */
-/*                                     indicating if they're okay to use. */
-/*                                     Note that this field is only valid */
-/*                                     once the struct values have been */
-/*                                     calculated at least once. */
-
-/* 				    0 indicates no error. */
-/* 				    -1 (vsop_get_rectangular) indicates a vsop_handle error.  (Data referenced by this handle wasn't found - perhaps it was unloaded.) */
-/* 				    -2 (vsop_get_rectangular) indicates that a vsop_handle referenced data that wasn't rectangular, or otherwise not suitable for providing rectangular coordinates. */
-/* 				    -3 (vsop_rec_vsop_to_fk5) indicates that supplied coordinates were unsuitable for converting to FK5. */
-/* 			*\/ */
-/* } vsop_rec_coords; */
-
-/* /\*! @brief Struct for holding spherical coordinates. */
-/*  *\/ */
-/* typedef struct { */
-/*   double L;             /\*!< @brief Heliocentric ecliptical longitude. *\/ */
-/*   double B;             /\*!< @brief Heliocentric ecliptical latitude.  *\/ */
-/*   double R;             /\*!< @brief The radius vector (distance to the Sun). *\/ */
-/* } sph_coords; */
-
-/* /\*! @brief A struct to hold spherical coordinates from a particular */
-/*  *  calculation, including meta information about their calculation. */
-/*  *\/ */
-/* typedef struct { */
-/*   vsop_handle vh;       /\*!< @brief The VSOP handle representing the data these coordinates were calculated from. *\/ */
-/*   double jd;            /\*!< @brief The Julian Date of these coordinates, in dynamical time.                      *\/ */
-/*   sph_coords sc;        /\*!< @brief The spherical coordinates.                                                   *\/ */
-/*   int is_inverted;      /\*!< @brief Set to 1 if these coordinates are inverted (eg. for Solar coordinates), 0 otherwise. *\/ */
-/*   int error_state;      /\*!< @brief The state of these coordinates, */
-/*                                     indicating if they're okay to use. */
-/*                                     Note that this field is only valid */
-/*                                     once the struct values have been */
-/*                                     calculated at least once. */
-
-/* 				    0 indicates no error. */
-/* 				    -1 (vsop_get_spherical) indicates a vsop_handle error.  (Data referenced by this handle wasn't found - perhaps it was unloaded.) */
-/* 				    -2 (vsop_get_spherical) indicates that a vsop_handle referenced data that wasn't spherical, or otherwise not suitable for providing spherical coordinates.  (This should really only happen if the data in the struct has been corrupted somehow.) */
-/* 				    -3 (vsop_rec_vsop_to_fk5) indicates that supplied coordinates were unsuitable for converting to FK5. */
-/* 			*\/ */
-/* } vsop_sph_coords; */
-
-/* void vsop_data_init(); */
-/* void vsop_data_cleanup(); */
-/* int get_vsop_data_handle(const vsop_body planet, const vsop_version version, vsop_handle *vh); */
-/* vsop_rec_coords vsop_get_rectangular(const vsop_handle vh, const double jd); */
-/* vsop_rec_coords vsop_rec_vsop_to_fk5(const vsop_rec_coords vrc); */
-/* vsop_rec_coords vsop_rec_invert(const vsop_rec_coords vrc); */
-/* vsop_sph_coords vsop_get_spherical(const vsop_handle vh, const double jd); */
-/* vsop_sph_coords vsop_sph_vsop_to_fk5(const vsop_sph_coords vsc); */
-/* vsop_sph_coords vsop_sph_invert(const vsop_sph_coords vsc); */
-
-/* #endif */

Copied: branches/new-vsop-prepare/src/c/libephemeritis/vsop_data_handling.c (from rev 219, branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.c)
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_data.c	2006-01-23 08:47:17 UTC (rev 219)
+++ branches/new-vsop-prepare/src/c/libephemeritis/vsop_data_handling.c	2006-01-23 09:11:48 UTC (rev 220)
@@ -0,0 +1,415 @@
+/* Copyright 2000, 2001, 2005 William McClain, Mike McGavin
+
+This file is part of Ephemeritis.
+
+Ephemeritis is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+Ephemeritis is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Ephemeritis; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+/*! @file ephemeritis_vsop_data.c
+ *
+ * @brief Management of VSOP data files, and in-memory structures.
+ *
+ * @author Mike McGavin.
+ */
+
+#include "ephemeritis_vsop_internal.h"
+#include "ephemeritis.h"
+
+#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+
+/*! @brief De-allocates the space that was allocated for a series
+ *  structure in memory.
+ *
+ *  @param[in] s The series struct.
+ */
+static void destroy_series(series s)
+{
+  free(s.terms);
+}
+
+/*! @brief De-allocates the space that was allocated for a
+ *  body_elements structure in memory.
+ *
+ *  @param[in] b A pointer to a body_elements object.  This will be
+ *  free()'d, as will the entire strucutre underneath it.  Ensure that
+ *  nothing inside is referenced from elsewhere.
+ */
+void free_body_elements(body_elements *b)
+{
+  int n;
+  for(n = 0; n < b->meta.num_variables; n++) {
+    int o;
+    for(o = 0; o < b->variable_list[n].meta.series_count; o++) {
+      /* Destroy each series. */
+      destroy_series(b->variable_list[n].series_list[o]);
+    }
+
+    /* Free the list of series for the variable. */
+    free(b->variable_list[n].series_list);
+  }
+  
+  free(b);
+}
+
+/*! @brief Prints details about the body elements in a human readable
+ *  form.
+ *
+ *  @param[in] ostream A stream pointer to which the text should be printed.  (eg. stdin, stderr, or an open file.)
+ *  @param[in] b       Pointer to the body elements.
+ */
+void print_body_statistics(FILE *ostream, body_elements *b)
+{
+  fprintf(ostream, "Ephemeritis Version String: %s.\n", b->meta.eph_header_text);
+  fprintf(ostream, "Data for \"%s\".\n", b->meta.body_name);
+  fprintf(ostream, "%d variables overall.\n", b->meta.num_variables);
+
+  int v;
+  for(v=0; v<b->meta.num_variables; v++) {
+    fprintf(ostream, "\nVariable %d contains %d series':\n\n", v, b->variable_list[v].meta.series_count);
+
+    int s;
+    for(s=0; s<b->variable_list[v].meta.series_count; s++) {
+      series *ser = &(b->variable_list[v].series_list[s]);
+      fprintf(ostream, "  Series %d has alpha %d and contains %d terms.\n", s, ser->meta.alpha, (ser->meta.num_terms));
+    }
+  }
+}
+
+/*! @brief Given an open output file and a body_elements structure,
+ *  output the body elements in binary format.
+ *
+ *  @param[in] outfile An open file to which the data should be written. The file is not closed after the operation.
+ *  @param[in] b       Pointer to the body elements.
+ */
+void write_body_elements(FILE *outfile, body_elements *b)
+{
+  /* Write the header data. */
+  fwrite(&b->meta, sizeof(b->meta), 1, outfile);
+
+  /* Loop through the variables, writing data of each one. */
+  int v;
+  for(v = 0; v < b->meta.num_variables; v++) {
+    fwrite(&b->variable_list[v].meta, sizeof(b->variable_list[v].meta), 1, outfile);
+
+    /* Loop through the series variables, writing data of each one. */
+    int s;
+    for(s = 0; s < b->variable_list[v].meta.series_count; s++) {
+      series *ser = &b->variable_list[v].series_list[s];
+      fwrite(&ser->meta, sizeof(ser->meta), 1, outfile);
+
+      /* Write the list of terms. */
+      fwrite(ser->terms, sizeof(*(ser->terms)), ser->meta.num_terms, outfile);
+    }
+  }
+}
+
+
+/*! @brief Given an open input file and a body_elements structure,
+ *  read the body elements from binary format.
+ *
+ *  @param[in] infile  An open file from which the data should be
+ *                     read. The file should be set to the beginning of its data, and is
+ *                     not closed after the operation.
+ *
+ *  @return            Pointer to the body elements that have been read.
+ *
+ *  @bug Doesn't indicate if there was an error, such as corrupted
+ *  data or lack of memory.  What should properly happen is that the
+ *  function should clean up whatever memory mess it's caused, and
+ *  return NULL.
+ */
+body_elements *read_body_elements(FILE *infile)
+{
+  body_elements *b;
+
+  /* Allocate memory for the body_elements. */
+  b = (body_elements *)malloc(sizeof(body_elements));
+
+  /* Read the header data. */
+  fread(&b->meta, sizeof(b->meta), 1, infile);
+
+  /* Loop through the variables, reading data for each one. */
+  int v;
+  for(v = 0; v < b->meta.num_variables; v++) {
+    fread(&b->variable_list[v].meta, sizeof(b->variable_list[v].meta), 1, infile);
+
+    /* Allocate memory to hold the list of series' for this variable. */
+    b->variable_list[v].series_list = (series *)calloc(b->variable_list[v].meta.series_count, sizeof(series));
+
+    /* Loop through the series variables, reading data from each one. */
+    int s;
+    for(s = 0; s < b->variable_list[v].meta.series_count; s++) {
+      /* Read meta data for this series. */
+      series *ser = &b->variable_list[v].series_list[s];
+      fread(&ser->meta, sizeof(ser->meta), 1, infile);
+
+      /* Allocate memory for the terms. */
+      ser->terms = (term_bin *)calloc(ser->meta.num_terms, sizeof(term_bin));
+
+      /* Read the list of terms. */
+      fread(ser->terms, sizeof(*(ser->terms)), ser->meta.num_terms, infile);
+    }
+  }
+
+  return b;
+}
+
+
+
+
+
+/*! @brief Internal struct to hold id data about a vsop_handle.
+ */
+typedef struct {
+  vsop_handle h;
+  body_elements *be;
+} vsop_handle_wrapper;
+
+static vsop_handle_wrapper *vhw_list = NULL;
+static int vhw_list_size = 0;
+static int next_data_id = 1;
+
+/*! @brief Initialise the VSOP data handling functionality.  This
+    should be called before using any VSOP data handling routines.
+ *
+ *  Calling this function initialises all the internal memory handling
+ *  overheads, and so on.
+ */
+void vsop_data_init()
+{
+  vhw_list = NULL;
+  vhw_list_size = 0;
+}
+
+/*! @brief Cleans up the VSOP data handling functionality.  This
+ *  should be called after using any VSOP data handling routines.
+ *
+ *  Calling this function cleans up all the internal memory handling
+ *  overheads, and so on.
+ */
+void vsop_data_cleanup()
+{
+  /* Loop through every loaded data set, and release it. */
+
+  /* Release the list, and re-initialise the meta variables. */
+  free(vhw_list);
+  vhw_list = NULL;
+  vhw_list_size = 0;
+}
+
+
+/*! @brief Check to see if data matching that requested is already in
+ *  memory.  If so, copy it to an output variable, and return true.
+ *
+ *  @param[in] planet  The planet being requested.
+ *  @param[in] version The version of the VSOP data being requested.
+ *
+ *  @param[out] h      A location where the vsop_handle data for the requested planet and version will be copied.
+ *
+ *  @return true if the data was loaded and returned, otherwise false.
+ */
+static bool get_vsop_handle(const vsop_body planet, const vsop_version version, vsop_handle *h)
+{
+  int n;
+  for(n = 0; n < vhw_list_size; n++) {
+    if(planet == vhw_list[n].h.planet && version == vhw_list[n].h.version) {
+      *h = vhw_list[n].h;
+      return true;
+    }
+  }
+  return false;
+}
+
+
+typedef struct {
+  vsop_version v;
+  char *str;
+} version_str_map_type;
+
+
+typedef struct {
+  vsop_body p;
+  char *str;
+} body_str_map_type;
+
+static version_str_map_type version_str_map[] = {
+  {hel_ell_j2,   EPH_VSOP_HEJ2},
+  {hel_rec_j2,   EPH_VSOP_HRJ2},
+  {hel_sph_j2,   EPH_VSOP_HSJ2},
+  {hel_rec_date, EPH_VSOP_HRD },
+  {hel_sph_date, EPH_VSOP_HSD },
+  {bar_rec_j2,   EPH_VSOP_BRJ2}
+};
+
+static char *version_map_lookup(vsop_version v)
+{
+  int n;
+  for(n = 0; n < sizeof(version_str_map) / sizeof(*version_str_map); n++) {
+    if(v == version_str_map[n].v) {
+      return version_str_map[n].str;
+    }
+  }
+  return NULL;
+}
+
+static body_str_map_type body_str_map[] = {
+  {vsop_mercury, EPH_MER},
+  {vsop_venus,   EPH_VEN},
+  {vsop_earth,   EPH_EAR},
+  {vsop_mars,    EPH_MAR},
+  {vsop_jupiter, EPH_JUP},
+  {vsop_saturn,  EPH_SAT},
+  {vsop_uranus,  EPH_URA},
+  {vsop_neptune, EPH_NEP},
+  {vsop_sun,     EPH_SOL},
+  {vsop_EMB,     EPH_EMB}
+};
+
+static char *planet_map_lookup(vsop_body p)
+{
+  int n;
+  for(n = 0; n < sizeof(body_str_map) / sizeof(*body_str_map); n++) {
+    if(p == body_str_map[n].p) {
+      return body_str_map[n].str;
+    }
+  }
+  return NULL;
+}
+
+/* Assumes that the handle isn't already loaded, and that the data in
+   the file isn't corrupt, so use with care. */
+static int load_vsop_handle(const vsop_body planet, const vsop_version version, vsop_handle *vh)
+{
+  /* Construct the filename. */
+  char filename[512];
+  strncpy(filename, EPH_VSOP_DATA_PATH, 512);
+  strncat(filename, EPH_VSOP_PREFIX, 512);
+  strncat(filename, version_map_lookup(version), 512);
+  strncat(filename, ".", 512);
+  strncat(filename, planet_map_lookup(planet), 512);
+  strncat(filename, EPH_VSOP_SUFFIX, 512);
+  filename[511] = '\0';
+
+  /* Try to open the file. */
+  FILE *f;
+  errno = 0;
+  if(NULL == (f = fopen(filename, "rb"))) {
+    /* File didn't open for some reason.  Probably not there. */
+    return errno;
+  }
+
+  /* Attempt to read data from the file. */
+  body_elements *be = read_body_elements(f);
+
+
+  /* Note that there's no checking to make sure the file was loaded successfully.  This is bad. */
+
+
+  /* Close the file. */
+  errno = 0;
+  if(0 != fclose(f)) {
+    return errno;
+  }
+  
+  /* Allocate more space in the list of vsop handle wrappers. */
+  vsop_handle_wrapper *realloc_result;
+  realloc_result = (vsop_handle_wrapper *)realloc(vhw_list, ++vhw_list_size * sizeof(vsop_handle_wrapper));
+
+  /* Check to make sure that realloc() found more memory successfully. */
+  if(NULL == realloc_result) {
+    /* Oops, not enough memory, or some other error. */
+
+    /* Free up those elements that were just read, since there's nowhere to put them. */
+    free_body_elements(be);
+
+    /* Return the error value. */
+    return errno;
+  } else {
+    /* Memory was re-allocated fine, so assign the list's address to wherever it's been placed. */
+    vhw_list = realloc_result;
+  }
+
+  vhw_list[vhw_list_size-1].be = be;
+  vhw_list[vhw_list_size-1].h.data_id = next_data_id++;
+  vhw_list[vhw_list_size-1].h.planet = planet;
+  vhw_list[vhw_list_size-1].h.version = version;
+
+  *vh = vhw_list[vhw_list_size-1].h;
+  return 0;
+}
+
+/*! @brief Returns a handle for accessing available VSOP data.
+ *
+ *  Data is stored in files on disk, with each file containing data
+ *  for a particular planet and a version.  Ephemeritis keeps an
+ *  internal cache of data that's already been loaded, and the cache
+ *  will be checked first to see if a handle for the data is already
+ *  available.  If it's not loaded already, the function will attempt
+ *  to load the data from the file.
+ *
+ *  Note that data may not always be available.  It might not be
+ *  installed (with the data file not being available), or the
+ *  combination of planet and version might not make sense.
+ *
+ *  @param[in] planet  The planet for which the data is being requested.
+ *  @param[in] version The version of VSOP data being requested.
+ *
+ *  @param[out] vh  A location to place the vsop_handle, if it's available.
+ *
+ *  @return 0 if the requested data was available (and returned),
+ *  otherwise an errno value that could have been set by fopen(),
+ *  fclose(), or realloc() is returned.
+ */
+int get_vsop_data_handle(const vsop_body planet, const vsop_version version, vsop_handle *vh)
+{
+  /* Check to see if the data for this planet/series is already loaded. */
+  if(get_vsop_handle(planet, version, vh)) {
+    /* If so, return the handle.       */
+    return 0;
+  } else {
+    /* If not, load it, then return it. */
+    return load_vsop_handle(planet, version, vh);
+  }
+}
+
+/*! @brief Maps a specified vsop_handle to the loaded body elements that it represents.
+ *
+ *  Given a vsop_handle (which is abstract from the loaded data), this
+ *  function locates the body_elements structure to which the handle
+ *  maps.
+ *
+ *  @param[in] vh The handle that represents the elements to search for.
+ *
+ *  @return A pointer to a structure containing the elements
+ *  associated with the specified vsop_handle, if it exists.
+ *  Otherwise NULL.
+ *
+ */
+body_elements *get_body_elements_for_handle(const vsop_handle vh)
+{
+  int n;
+  for(n = 0; n < vhw_list_size; n++) {
+    if(vh.data_id == vhw_list[n].h.data_id) {
+      /* Found the handle, so return its associated body_elements structure. */
+      return vhw_list[n].be;
+    }
+  }
+
+  /* The handle wasn't found in the list of loaded data, so return NULL. */
+  return NULL;
+}

Modified: branches/new-vsop-prepare/src/c/tests/validate_meeus.c
===================================================================
--- branches/new-vsop-prepare/src/c/tests/validate_meeus.c	2006-01-23 08:47:17 UTC (rev 219)
+++ branches/new-vsop-prepare/src/c/tests/validate_meeus.c	2006-01-23 09:11:48 UTC (rev 220)
@@ -53,7 +53,6 @@
  */
 
 #include <ephemeritis.h>
-#include <ephemeritis_vsop_data.h>
 
 #include <stdio.h>
 #include <math.h>

Modified: branches/new-vsop-prepare/src/c/utils/build_vsop_data.c
===================================================================
--- branches/new-vsop-prepare/src/c/utils/build_vsop_data.c	2006-01-23 08:47:17 UTC (rev 219)
+++ branches/new-vsop-prepare/src/c/utils/build_vsop_data.c	2006-01-23 09:11:48 UTC (rev 220)
@@ -31,7 +31,7 @@
  */
 
 #include "config.h"
-#include <ephemeritis_vsop_data.h>
+#include <ephemeritis.h>
 #include <ephemeritis_vsop_internal.h>
 #include <stdio.h>
 #include <stdlib.h>



From izogi at berlios.de  Mon Jan 23 19:38:11 2006
From: izogi at berlios.de (izogi at BerliOS)
Date: Mon, 23 Jan 2006 19:38:11 +0100
Subject: [Ephemeritis-svn] r221 - in branches/new-vsop-prepare/src/c: libephemeritis utils
Message-ID: <200601231838.k0NIcBUw022855@sheep.berlios.de>

Author: izogi
Date: 2006-01-23 19:37:54 +0100 (Mon, 23 Jan 2006)
New Revision: 221

Modified:
   branches/new-vsop-prepare/src/c/libephemeritis/Makefile.am
   branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis.h
   branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_internal.h
   branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c
   branches/new-vsop-prepare/src/c/libephemeritis/vsop_data_handling.c
   branches/new-vsop-prepare/src/c/utils/Makefile.am
   branches/new-vsop-prepare/src/c/utils/build_vsop_data.c
Log:
More work on install hook for converting data files at install time (still breaks).
Mangling names of certain internal functions.


Modified: branches/new-vsop-prepare/src/c/libephemeritis/Makefile.am
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/Makefile.am	2006-01-23 09:11:48 UTC (rev 220)
+++ branches/new-vsop-prepare/src/c/libephemeritis/Makefile.am	2006-01-23 18:37:54 UTC (rev 221)
@@ -1,6 +1,6 @@
 AUTOMAKE_OPTIONS = gnu
 
-AM_CFLAGS = -ansi -Wall -DVSOP_DATA_FILE="$(pkgdatadir)/vsop87d.txt"
+AM_CFLAGS = -ansi -Wall -DVSOP_DATA_PATH="$(pkgdatadir)/"
 
 lib_LTLIBRARIES = libephemeritis.la
 

Modified: branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis.h
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis.h	2006-01-23 09:11:48 UTC (rev 220)
+++ branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis.h	2006-01-23 18:37:54 UTC (rev 221)
@@ -438,21 +438,6 @@
 
 
 
-/* /\*! @file ephemeritis_vsop_data.h */
-/*  * */
-/*  * Definitions for VSOP data and related functions.  This list is */
-/*  * included by various parts of the code and utilities to allow them */
-/*  * to share commonly understood data structures. */
-/*  * */
-/*  * @todo Document the structures. */
-/*  * @todo Figure out which parts of this should be available everywhere, and which parts should be internal to the data-handling code (in a separate header file). */
-/*  * @todo Update EPHEMERITIS_VSOP_DATA_PATH to make it configurable by the user at installation time. */
-/*  * */
-/*  * @author Mike McGavin. */
-/*  *\/ */
-
-#include "ephemeritis.h"
-
 /*! @brief A list of bodies recognised by the VSOP model.
  */
 typedef enum {
@@ -540,9 +525,12 @@
 			*/
 } vsop_sph_coords;
 
+/* vsop_data_handling.c */
 void vsop_data_init();
 void vsop_data_cleanup();
 int get_vsop_data_handle(const vsop_body planet, const vsop_version version, vsop_handle *vh);
+
+/* vsop_calculate.c */
 vsop_rec_coords vsop_get_rectangular(const vsop_handle vh, const double jd);
 vsop_rec_coords vsop_rec_vsop_to_fk5(const vsop_rec_coords vrc);
 vsop_rec_coords vsop_rec_invert(const vsop_rec_coords vrc);

Modified: branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_internal.h
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_internal.h	2006-01-23 09:11:48 UTC (rev 220)
+++ branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_internal.h	2006-01-23 18:37:54 UTC (rev 221)
@@ -39,9 +39,14 @@
 
 #define EPHEMERITIS_BIN_HEADER_TEXT_FORMAT "EphB v=%s"
 
-/* Define data path -- this should be updated to something configurable. */
+/* Define data path -- this should be updated to something more elegantly configurable. */
+#ifdef VSOP_DATA_PATH
+#define EPH_VSOP_DATA_PATH VSOP_DATA_PATH "/"
+#else
 #define EPH_VSOP_DATA_PATH "/home/izogi/misc/ephemeritis/branches/new-vsop-prepare/data/vsop/"
+#endif
 
+
 /* Start with... */
 #define EPH_VSOP_PREFIX    "VSOP87"
 
@@ -108,11 +113,12 @@
 } body_elements;
 
 
-void print_body_statistics(FILE *ostream, body_elements *b);
-void write_body_elements(FILE *outfile, body_elements *b);
-body_elements *read_body_elements(FILE *infile);
-void free_body_elements(body_elements *b);
-body_elements *get_body_elements_for_handle(const vsop_handle vh);
+body_elements *ephint_get_body_elements_for_handle(const vsop_handle vh);
+void ephint_free_body_elements(body_elements *b);
+void ephint_write_body_elements(FILE *outfile, body_elements *b);
+/*
+void ephint_print_body_statistics(FILE *ostream, body_elements *b);
+body_elements *ephint_read_body_elements(FILE *infile);
+*/
 
-
 #endif

Modified: branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c	2006-01-23 09:11:48 UTC (rev 220)
+++ branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c	2006-01-23 18:37:54 UTC (rev 221)
@@ -129,7 +129,7 @@
 
   /* Get a reference to the body_elements structure for this handle. */
   body_elements *be;
-  if(NULL == (be = get_body_elements_for_handle(vh))) {
+  if(NULL == (be = ephint_get_body_elements_for_handle(vh))) {
     vrc.error_state = -1;
     return vrc;
   }
@@ -255,7 +255,7 @@
 
   /* Get a reference to the body_elements structure for this handle. */
   body_elements *be;
-  if(NULL == (be = get_body_elements_for_handle(vh))) {
+  if(NULL == (be = ephint_get_body_elements_for_handle(vh))) {
     vsc.error_state = -1;
     return vsc;
   }

Modified: branches/new-vsop-prepare/src/c/libephemeritis/vsop_data_handling.c
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/vsop_data_handling.c	2006-01-23 09:11:48 UTC (rev 220)
+++ branches/new-vsop-prepare/src/c/libephemeritis/vsop_data_handling.c	2006-01-23 18:37:54 UTC (rev 221)
@@ -49,7 +49,7 @@
  *  free()'d, as will the entire strucutre underneath it.  Ensure that
  *  nothing inside is referenced from elsewhere.
  */
-void free_body_elements(body_elements *b)
+void ephint_free_body_elements(body_elements *b)
 {
   int n;
   for(n = 0; n < b->meta.num_variables; n++) {
@@ -72,7 +72,7 @@
  *  @param[in] ostream A stream pointer to which the text should be printed.  (eg. stdin, stderr, or an open file.)
  *  @param[in] b       Pointer to the body elements.
  */
-void print_body_statistics(FILE *ostream, body_elements *b)
+void ephint_print_body_statistics(FILE *ostream, body_elements *b)
 {
   fprintf(ostream, "Ephemeritis Version String: %s.\n", b->meta.eph_header_text);
   fprintf(ostream, "Data for \"%s\".\n", b->meta.body_name);
@@ -96,7 +96,7 @@
  *  @param[in] outfile An open file to which the data should be written. The file is not closed after the operation.
  *  @param[in] b       Pointer to the body elements.
  */
-void write_body_elements(FILE *outfile, body_elements *b)
+void ephint_write_body_elements(FILE *outfile, body_elements *b)
 {
   /* Write the header data. */
   fwrite(&b->meta, sizeof(b->meta), 1, outfile);
@@ -133,7 +133,7 @@
  *  function should clean up whatever memory mess it's caused, and
  *  return NULL.
  */
-body_elements *read_body_elements(FILE *infile)
+static body_elements *ephint_read_body_elements(FILE *infile)
 {
   body_elements *b;
 
@@ -314,7 +314,7 @@
   }
 
   /* Attempt to read data from the file. */
-  body_elements *be = read_body_elements(f);
+  body_elements *be = ephint_read_body_elements(f);
 
 
   /* Note that there's no checking to make sure the file was loaded successfully.  This is bad. */
@@ -335,7 +335,7 @@
     /* Oops, not enough memory, or some other error. */
 
     /* Free up those elements that were just read, since there's nowhere to put them. */
-    free_body_elements(be);
+    ephint_free_body_elements(be);
 
     /* Return the error value. */
     return errno;
@@ -400,7 +400,7 @@
  *  Otherwise NULL.
  *
  */
-body_elements *get_body_elements_for_handle(const vsop_handle vh)
+body_elements *ephint_get_body_elements_for_handle(const vsop_handle vh)
 {
   int n;
   for(n = 0; n < vhw_list_size; n++) {

Modified: branches/new-vsop-prepare/src/c/utils/Makefile.am
===================================================================
--- branches/new-vsop-prepare/src/c/utils/Makefile.am	2006-01-23 09:11:48 UTC (rev 220)
+++ branches/new-vsop-prepare/src/c/utils/Makefile.am	2006-01-23 18:37:54 UTC (rev 221)
@@ -5,7 +5,7 @@
 
 AM_CFLAGS = -ansi -Wall
 
-bin_PROGRAMS = \
+noinst_PROGRAMS = \
 	build_vsop_data
 
 build_vsop_data_SOURCES		= build_vsop_data.c
@@ -15,11 +15,22 @@
 INCLUDES = -I../libephemeritis/
 
 # This install hook doesn't seem to work properly yet.
+
+VSOPFILES = VSOP87A.ear  VSOP87A.nep  VSOP87B.jup  VSOP87B.ura  VSOP87C.mer  VSOP87D.ear  VSOP87D.sat  VSOP87E.mar  VSOP87E.ura \
+            VSOP87A.emb  VSOP87A.sat  VSOP87B.mar  VSOP87B.ven  VSOP87C.nep  VSOP87D.jup  VSOP87D.ura  VSOP87E.mer  VSOP87E.ven \
+            VSOP87A.jup  VSOP87A.ura  VSOP87B.mer  VSOP87C.ear  VSOP87C.sat  VSOP87D.mar  VSOP87D.ven  VSOP87E.nep \
+            VSOP87A.mar  VSOP87A.ven  VSOP87B.nep  VSOP87C.jup  VSOP87C.ura  VSOP87D.mer  VSOP87E.ear  VSOP87E.sat \
+            VSOP87A.mer  VSOP87B.ear  VSOP87B.sat  VSOP87C.mar  VSOP87C.ven  VSOP87D.nep  VSOP87E.jup  VSOP87E.sun
+
 install-exec-hook:
 	echo The output data dir is: $(srcdir)  $(distdir)  % $(top_srcdir)
-	find ../../../data/vsop -name "VSOP87*" -execdir ../../src/c/utils/build_vsop_data {} $(pkgdatadir)/$(basename {}).eph.bin \;
+	for vf in $(VSOPFILES); do \
+		( ./build_vsop_data ../../../data/vsop/$$vf $(pkgdatadir)/$$vf.eph.bin ; ) \
+	done
 
+##	find ../../../data/vsop -name "VSOP87*" -execdir ../../src/c/utils/build_vsop_data {} $(pkgdatadir)/$(basename {}).eph.bin \;
 
+
 ## if DEBUG
 ## 	DBG = debug
 ## else

Modified: branches/new-vsop-prepare/src/c/utils/build_vsop_data.c
===================================================================
--- branches/new-vsop-prepare/src/c/utils/build_vsop_data.c	2006-01-23 09:11:48 UTC (rev 220)
+++ branches/new-vsop-prepare/src/c/utils/build_vsop_data.c	2006-01-23 18:37:54 UTC (rev 221)
@@ -184,9 +184,9 @@
   /*
   print_body_elements(stdout, body_el);
   */
-  write_body_elements(outfile, body_el);
+  ephint_write_body_elements(outfile, body_el);
 
-  free_body_elements(body_el);
+  ephint_free_body_elements(body_el);
 
   /* Close files. */
   if(infile != stdin) {



From izogi at berlios.de  Tue Jan 24 10:21:13 2006
From: izogi at berlios.de (izogi at BerliOS)
Date: Tue, 24 Jan 2006 10:21:13 +0100
Subject: [Ephemeritis-svn] r222 - in branches/new-vsop-prepare: . src/c/libephemeritis src/c/utils
Message-ID: <200601240921.k0O9LDmM010027@sheep.berlios.de>

Author: izogi
Date: 2006-01-24 10:21:11 +0100 (Tue, 24 Jan 2006)
New Revision: 222

Modified:
   branches/new-vsop-prepare/configure.ac
   branches/new-vsop-prepare/src/c/libephemeritis/Makefile.am
   branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_internal.h
   branches/new-vsop-prepare/src/c/utils/Makefile.am
Log:
Further attempts to get the installation hook to work.


Modified: branches/new-vsop-prepare/configure.ac
===================================================================
--- branches/new-vsop-prepare/configure.ac	2006-01-23 18:37:54 UTC (rev 221)
+++ branches/new-vsop-prepare/configure.ac	2006-01-24 09:21:11 UTC (rev 222)
@@ -34,7 +34,7 @@
 		vsop_data_dir=$datadir
 		)
 
-AC_DEFINE_UNQUOTED(VSOPPATH, "$vsop_data_dir", [The directory where the incoming VSOP text data is available.])
+AC_DEFINE_UNQUOTED(VSOPPATH, "abcde $vsop_data_dir", [The directory where the incoming VSOP text data is available.])
 
 AM_PROG_LIBTOOL
 

Modified: branches/new-vsop-prepare/src/c/libephemeritis/Makefile.am
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/Makefile.am	2006-01-23 18:37:54 UTC (rev 221)
+++ branches/new-vsop-prepare/src/c/libephemeritis/Makefile.am	2006-01-24 09:21:11 UTC (rev 222)
@@ -1,6 +1,6 @@
 AUTOMAKE_OPTIONS = gnu
 
-AM_CFLAGS = -ansi -Wall -DVSOP_DATA_PATH="$(pkgdatadir)/"
+AM_CFLAGS = -ansi -Wall -DVSOP_DATA_PATH=\"$(pkgdatadir)\"
 
 lib_LTLIBRARIES = libephemeritis.la
 

Modified: branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_internal.h
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_internal.h	2006-01-23 18:37:54 UTC (rev 221)
+++ branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_internal.h	2006-01-24 09:21:11 UTC (rev 222)
@@ -41,9 +41,9 @@
 
 /* Define data path -- this should be updated to something more elegantly configurable. */
 #ifdef VSOP_DATA_PATH
-#define EPH_VSOP_DATA_PATH VSOP_DATA_PATH "/"
+  #define EPH_VSOP_DATA_PATH VSOP_DATA_PATH
 #else
-#define EPH_VSOP_DATA_PATH "/home/izogi/misc/ephemeritis/branches/new-vsop-prepare/data/vsop/"
+  #define EPH_VSOP_DATA_PATH ""
 #endif
 
 

Modified: branches/new-vsop-prepare/src/c/utils/Makefile.am
===================================================================
--- branches/new-vsop-prepare/src/c/utils/Makefile.am	2006-01-23 18:37:54 UTC (rev 221)
+++ branches/new-vsop-prepare/src/c/utils/Makefile.am	2006-01-24 09:21:11 UTC (rev 222)
@@ -23,11 +23,23 @@
             VSOP87A.mer  VSOP87B.ear  VSOP87B.sat  VSOP87C.mar  VSOP87C.ven  VSOP87D.nep  VSOP87E.jup  VSOP87E.sun
 
 install-exec-hook:
-	echo The output data dir is: $(srcdir)  $(distdir)  % $(top_srcdir)
+
+# Make sure the package directory exists.
+	echo vsop data dir = $(vsop_data_dir)
+	echo the other data dir = $(VSOPPATH)
+
+	mkdir -p $(pkgdatadir)
+
+# Build each VSOP data file, placing the output into the package directory.
 	for vf in $(VSOPFILES); do \
-		( ./build_vsop_data ../../../data/vsop/$$vf $(pkgdatadir)/$$vf.eph.bin ; ) \
+		( echo `pwd`; ./build_vsop_data ../../../data/vsop/$$vf $(pkgdatadir)/$$vf.eph.bin ); \
 	done
 
+#        for d in $(SUBDIRS); do         \
+#        	(cd $$d; ${MAKE} all);  \
+#        done
+                                
+
 ##	find ../../../data/vsop -name "VSOP87*" -execdir ../../src/c/utils/build_vsop_data {} $(pkgdatadir)/$(basename {}).eph.bin \;
 
 



From izogi at berlios.de  Wed Jan 25 11:24:11 2006
From: izogi at berlios.de (izogi at BerliOS)
Date: Wed, 25 Jan 2006 11:24:11 +0100
Subject: [Ephemeritis-svn] r223 - in branches/new-vsop-prepare/src/c: libephemeritis tests
Message-ID: <200601251024.k0PAOBR4007569@sheep.berlios.de>

Author: izogi
Date: 2006-01-25 11:24:10 +0100 (Wed, 25 Jan 2006)
New Revision: 223

Modified:
   branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis.h
   branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_internal.h
   branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c
   branches/new-vsop-prepare/src/c/tests/validate_meeus.c
Log:
More conversion of validate_meeus towards the new vsop methods.
Bug-fix to add "/" to the end of VSOP data path #define.


Modified: branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis.h
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis.h	2006-01-24 09:21:11 UTC (rev 222)
+++ branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis.h	2006-01-25 10:24:10 UTC (rev 223)
@@ -357,6 +357,7 @@
 } element_constants;
 
 double eccentricity_anomoly(double M, double e, int iterations);
+
 int geocentric_planet(double jd,
 		      enum vPlanets basePlanet,
 		      enum vPlanets targetPlanet,
@@ -365,6 +366,7 @@
 		      double n_in_l, double epsilon, double delta,
 		      double *ra, double *dec);
 
+
 element_constants get_element_constants(const double obl,
 					const orbital_elements elements,
 					const int iterations);

Modified: branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_internal.h
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_internal.h	2006-01-24 09:21:11 UTC (rev 222)
+++ branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_internal.h	2006-01-25 10:24:10 UTC (rev 223)
@@ -41,7 +41,7 @@
 
 /* Define data path -- this should be updated to something more elegantly configurable. */
 #ifdef VSOP_DATA_PATH
-  #define EPH_VSOP_DATA_PATH VSOP_DATA_PATH
+  #define EPH_VSOP_DATA_PATH VSOP_DATA_PATH "/"
 #else
   #define EPH_VSOP_DATA_PATH ""
 #endif

Modified: branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c	2006-01-24 09:21:11 UTC (rev 222)
+++ branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c	2006-01-25 10:24:10 UTC (rev 223)
@@ -164,7 +164,7 @@
  *  This algorithm is adapted from that provided by Bretagnon P.,
  *  Francou G., : 1988, Astron. Astrophys.  It's also explained in
  *  [Meeus-1998: equation 26.3.]
-
+ *
  *  @param vrc[in] The incoming coordinates to be rotated.
  *
  *  @return The rotated coordinates.

Modified: branches/new-vsop-prepare/src/c/tests/validate_meeus.c
===================================================================
--- branches/new-vsop-prepare/src/c/tests/validate_meeus.c	2006-01-24 09:21:11 UTC (rev 222)
+++ branches/new-vsop-prepare/src/c/tests/validate_meeus.c	2006-01-25 10:24:10 UTC (rev 223)
@@ -83,6 +83,50 @@
 	   units);
 }
 
+int vsop_dimension3_vsop_new(double jd,
+			     vsop_body planet,
+			     double *longitude, double *latitude,
+			     double *radius)
+{
+  vsop_handle vh;
+  if(0 == get_vsop_data_handle(planet, hel_sph_date, &vh)) {
+    vsop_sph_coords vsc = vsop_get_spherical(vh, jd);
+    if(vsc.error_state != 0) {
+      printf("Error calculating spherical coordinates: %d\n", vsc.error_state);
+      return 0;
+    }
+    *longitude = vsc.sc.L;
+    *latitude = vsc.sc.B;
+    *radius = vsc.sc.R;
+    return 1;
+  } else {
+    printf("Unable to allocate the VSOP handle.\n");
+    return 0;
+  }
+}
+
+int vsop_dimension3_fk5_new(double jd,
+			    vsop_body planet,
+			    double *longitude, double *latitude,
+			    double *radius)
+{
+  vsop_handle vh;
+  if(0 == get_vsop_data_handle(planet, hel_sph_date, &vh)) {
+    vsop_sph_coords vsc = vsop_sph_vsop_to_fk5(vsop_get_spherical(vh, jd));
+    if(vsc.error_state != 0) {
+      printf("Error calculating spherical coordinates: %d\n", vsc.error_state);
+      return 0;
+    }
+    *longitude = vsc.sc.L;
+    *latitude = vsc.sc.B;
+    *radius = vsc.sc.R;
+    return 1;
+  } else {
+    printf("Unable to allocate the VSOP handle.\n");
+    return 0;
+  }
+}
+
 /*
  * One of the more unfortunate features of C++ is that template arguments cannot be local types.
  * All must be declared at the module level. This is inconvenient when using STL containers.
@@ -899,26 +943,30 @@
     printf("32.a Planet position\n");
     {
 	double L, B, R;
+	/*
 	vsop_dimension3_vsop(2448976.5, vVenus, &L, &B, &R);
-	/*
-	report_diff("longitude", r_to_d(L) * 3600, 26.11428 * 3600,
-		    "arc-seconds");
-	report_diff("latitude", r_to_d(B) * 3600, -2.62070 * 3600,
-		    "arc-seconds");
-	report_diff("radius", R * km_per_au, 0.724603 * km_per_au, "km");
 	*/
-	report("longitude", r_to_d(L) * 3600, 26.11428 * 3600, 1.0, "arc-seconds");
-	report("latitude", r_to_d(B) * 3600, -2.62070 * 3600, 1.0, "arc-seconds");
-	report("radius", R * km_per_au, 0.724603 * km_per_au, 200.0, "km");
-	printf("%.12f : %.12f : %.12f\n", L, B, R);
+	if(vsop_dimension3_vsop_new(2448976.5, vsop_venus, &L, &B, &R)) {
+	  report("longitude", r_to_d(L), 26.11428, 1.0, "deg");
+	  report("latitude", r_to_d(B), -2.62070, 1.0, "deg");
+	  report("radius", R * km_per_au, 0.724603 * km_per_au, 200.0, "km");
+	} else {
+	  printf("There was a problem with the VSOP code or data.\n");
+	}
     }
 
     printf("33.a Apparent position (vsop)\n");
     {
 	double ra, dec;
+	/*
 	geocentric_planet(2448976.5, vEarth, vVenus, vsop_dimension3_fk5,
 			  d_to_r(dms_to_d(0, 0, 16.749)),
 			  d_to_r(23.439669), days_per_second, &ra, &dec);
+	*/
+	geocentric_planet(2448976.5, vsop_earth, vsop_venus, vsop_dimension3_fk5_new,
+			  d_to_r(dms_to_d(0, 0, 16.749)),
+			  d_to_r(23.439669), days_per_second, &ra, &dec);
+
 	report("ra", r_to_d(ra), r_to_d(hms_to_fday(21, 4, 41.454) * pi2),
 	       1e-5, "degrees");
 	report("dec", r_to_d(dec), dms_to_d(-18, 53, 16.84), 1e-5,



From izogi at berlios.de  Fri Jan 27 21:22:45 2006
From: izogi at berlios.de (izogi at BerliOS)
Date: Fri, 27 Jan 2006 21:22:45 +0100
Subject: [Ephemeritis-svn] r224 - branches/new-vsop-prepare/src/c/libephemeritis
Message-ID: <200601272022.k0RKMju9014347@sheep.berlios.de>

Author: izogi
Date: 2006-01-27 21:22:42 +0100 (Fri, 27 Jan 2006)
New Revision: 224

Modified:
   branches/new-vsop-prepare/src/c/libephemeritis/vsop_data_handling.c
Log:
Fixed a memory allocation bug, so that ephint_read_body_elements() should now clean up loose bits of partially allocated memory if it runs out of mem during the process.


Modified: branches/new-vsop-prepare/src/c/libephemeritis/vsop_data_handling.c
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/vsop_data_handling.c	2006-01-25 10:24:10 UTC (rev 223)
+++ branches/new-vsop-prepare/src/c/libephemeritis/vsop_data_handling.c	2006-01-27 20:22:42 UTC (rev 224)
@@ -39,7 +39,9 @@
  */
 static void destroy_series(series s)
 {
-  free(s.terms);
+  if(NULL != s.terms) {
+    free(s.terms);
+  }
 }
 
 /*! @brief De-allocates the space that was allocated for a
@@ -48,15 +50,30 @@
  *  @param[in] b A pointer to a body_elements object.  This will be
  *  free()'d, as will the entire strucutre underneath it.  Ensure that
  *  nothing inside is referenced from elsewhere.
+ *
+ *  @note This function should also be capable of cleaning up a
+ *  malformed body_elements structure, such as one that was only
+ *  partly loaded due to running out of memory, for instance, but only
+ *  if the various allocated structures were zero'd before assigning
+ *  data and other pointers to them.
  */
 void ephint_free_body_elements(body_elements *b)
 {
+  if(NULL == b) {
+    /* Ignore, because it's null. */
+    return;
+  }
+
   int n;
   for(n = 0; n < b->meta.num_variables; n++) {
-    int o;
-    for(o = 0; o < b->variable_list[n].meta.series_count; o++) {
-      /* Destroy each series. */
-      destroy_series(b->variable_list[n].series_list[o]);
+    /* Make sure the series_list was successfully allocated before
+       trying to dig into each of its series' collections. */
+    if(NULL != b->variable_list[n].series_list) {
+      int o;
+      for(o = 0; o < b->variable_list[n].meta.series_count; o++) {
+	/* Destroy each series. */
+ 	destroy_series(b->variable_list[n].series_list[o]);
+      }
     }
 
     /* Free the list of series for the variable. */
@@ -126,20 +143,32 @@
  *                     read. The file should be set to the beginning of its data, and is
  *                     not closed after the operation.
  *
- *  @return            Pointer to the body elements that have been read.
+ *  @return Pointer to the body elements that have been read.  In case
+ *          of memory allocation failure, all the bits and pieces allocated up
+ *          to that point will be released, an NULL is returned.
  *
- *  @bug Doesn't indicate if there was an error, such as corrupted
- *  data or lack of memory.  What should properly happen is that the
- *  function should clean up whatever memory mess it's caused, and
- *  return NULL.
+ *  @bug Doesn't indicate if there was corrupted data.  What should
+ *  properly happen is that the function should clean up whatever
+ *  memory mess it's caused, and return NULL.
  */
 static body_elements *ephint_read_body_elements(FILE *infile)
 {
-  body_elements *b;
+  /* Note -- there's a goto label at the end of the function to
+     collect any memory allocation problems.  It'll deallocate
+     whatever's been created so far, and return NULL. */
 
+  body_elements *b = NULL;
+
   /* Allocate memory for the body_elements. */
   b = (body_elements *)malloc(sizeof(body_elements));
+  if(NULL == b) {
+    /* Oops, there wasn't enough memory. */
+    goto mem_cleanup;
+  }
+  /* Fill it with 0's, to make it safer to clean up if things fail later. */
+  memset(b, '\0', sizeof(*b));
 
+
   /* Read the header data. */
   fread(&b->meta, sizeof(b->meta), 1, infile);
 
@@ -150,7 +179,15 @@
 
     /* Allocate memory to hold the list of series' for this variable. */
     b->variable_list[v].series_list = (series *)calloc(b->variable_list[v].meta.series_count, sizeof(series));
-
+    if(NULL == b->variable_list[v].series_list) {
+      /* Oops, there wasn't enough memory. */
+      goto mem_cleanup;
+    }
+    /* Fill it with 0's, to make it safer to clean up if things fail later. */
+    /* Note that calloc() sets memory to 0 anyway (but malloc()
+       doesn't!), so the following line is more of a safety thing. */
+    memset(b->variable_list[v].series_list, '\0', b->variable_list[v].meta.series_count * sizeof(series));
+ 
     /* Loop through the series variables, reading data from each one. */
     int s;
     for(s = 0; s < b->variable_list[v].meta.series_count; s++) {
@@ -160,6 +197,12 @@
 
       /* Allocate memory for the terms. */
       ser->terms = (term_bin *)calloc(ser->meta.num_terms, sizeof(term_bin));
+      if(NULL == ser->terms) {
+	/* Oops, there wasn't enough memory. */
+	goto mem_cleanup;
+      }
+      /* Set the memory to 0's.  (Safety thing again, as above.) */
+      memset(ser->terms, '\0', ser->meta.num_terms * sizeof(term_bin));
 
       /* Read the list of terms. */
       fread(ser->terms, sizeof(*(ser->terms)), ser->meta.num_terms, infile);
@@ -167,6 +210,10 @@
   }
 
   return b;
+
+ mem_cleanup:
+  ephint_free_body_elements(b);
+  return NULL;
 }
 
 



From izogi at berlios.de  Sat Jan 28 03:00:28 2006
From: izogi at berlios.de (izogi at BerliOS)
Date: Sat, 28 Jan 2006 03:00:28 +0100
Subject: [Ephemeritis-svn] r225 - branches/new-vsop-prepare/src/c/libephemeritis
Message-ID: <200601280200.k0S20S79026178@sheep.berlios.de>

Author: izogi
Date: 2006-01-28 03:00:16 +0100 (Sat, 28 Jan 2006)
New Revision: 225

Modified:
   branches/new-vsop-prepare/src/c/libephemeritis/vsop_data_handling.c
Log:
Added error checking for the possibility of reading from a corrupted file. 
If the file ends early, or some-such error, EIO will be returned by
get_vsop_data_handle.


Modified: branches/new-vsop-prepare/src/c/libephemeritis/vsop_data_handling.c
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/vsop_data_handling.c	2006-01-27 20:22:42 UTC (rev 224)
+++ branches/new-vsop-prepare/src/c/libephemeritis/vsop_data_handling.c	2006-01-28 02:00:16 UTC (rev 225)
@@ -143,45 +143,61 @@
  *                     read. The file should be set to the beginning of its data, and is
  *                     not closed after the operation.
  *
+ *  @param[out] error_ret An integer space to collect a value
+ *                        indicating if there was an error.  On
+ *                        success, this will be set to 0 and the
+ *                        function's return value will be non-NULL.
+ *                        This will be set to either ENOMEM (for a
+ *                        memory allocation error from malloc or
+ *                        calloc), or EIO (for a file read error, such
+ *                        as the file's data being corrupted or
+ *                        otherwise ending unexpectedly).
+ *
  *  @return Pointer to the body elements that have been read.  In case
- *          of memory allocation failure, all the bits and pieces allocated up
+ *          of memory allocation failure or file reading error (such
+ *          as corrupted data), all the bits and pieces allocated up
  *          to that point will be released, an NULL is returned.
- *
- *  @bug Doesn't indicate if there was corrupted data.  What should
- *  properly happen is that the function should clean up whatever
- *  memory mess it's caused, and return NULL.
  */
-static body_elements *ephint_read_body_elements(FILE *infile)
+static body_elements *ephint_read_body_elements(FILE *infile, int *error_ret)
 {
   /* Note -- there's a goto label at the end of the function to
-     collect any memory allocation problems.  It'll deallocate
-     whatever's been created so far, and return NULL. */
+     collect any memory allocation problems.  (Traditionally yucky,
+     but I think it's slightly clearer in this case.)  It'll
+     deallocate whatever's been created so far, and return NULL. */
 
   body_elements *b = NULL;
+  size_t numread = 0;
+  *error_ret = 0;
 
   /* Allocate memory for the body_elements. */
   b = (body_elements *)malloc(sizeof(body_elements));
   if(NULL == b) {
     /* Oops, there wasn't enough memory. */
-    goto mem_cleanup;
+    goto mem_screwup;
   }
   /* Fill it with 0's, to make it safer to clean up if things fail later. */
   memset(b, '\0', sizeof(*b));
 
 
   /* Read the header data. */
-  fread(&b->meta, sizeof(b->meta), 1, infile);
+  numread = fread(&b->meta, sizeof(b->meta), 1, infile);
+  if(1 != numread) {
+    goto file_screwup;
+  }
 
   /* Loop through the variables, reading data for each one. */
   int v;
   for(v = 0; v < b->meta.num_variables; v++) {
-    fread(&b->variable_list[v].meta, sizeof(b->variable_list[v].meta), 1, infile);
+    numread = fread(&b->variable_list[v].meta, sizeof(b->variable_list[v].meta), 1, infile);
+    if(1 != numread) {
+      goto file_screwup;
+    }
 
     /* Allocate memory to hold the list of series' for this variable. */
     b->variable_list[v].series_list = (series *)calloc(b->variable_list[v].meta.series_count, sizeof(series));
     if(NULL == b->variable_list[v].series_list) {
       /* Oops, there wasn't enough memory. */
-      goto mem_cleanup;
+      goto mem_screwup;
     }
     /* Fill it with 0's, to make it safer to clean up if things fail later. */
     /* Note that calloc() sets memory to 0 anyway (but malloc()
@@ -193,24 +209,39 @@
     for(s = 0; s < b->variable_list[v].meta.series_count; s++) {
       /* Read meta data for this series. */
       series *ser = &b->variable_list[v].series_list[s];
-      fread(&ser->meta, sizeof(ser->meta), 1, infile);
+      numread = fread(&ser->meta, sizeof(ser->meta), 1, infile);
+      if(1 != numread) {
+	goto file_screwup;
+      }
 
       /* Allocate memory for the terms. */
       ser->terms = (term_bin *)calloc(ser->meta.num_terms, sizeof(term_bin));
       if(NULL == ser->terms) {
 	/* Oops, there wasn't enough memory. */
-	goto mem_cleanup;
+	goto mem_screwup;
       }
       /* Set the memory to 0's.  (Safety thing again, as above.) */
       memset(ser->terms, '\0', ser->meta.num_terms * sizeof(term_bin));
 
       /* Read the list of terms. */
-      fread(ser->terms, sizeof(*(ser->terms)), ser->meta.num_terms, infile);
+      numread = fread(ser->terms, sizeof(*(ser->terms)), ser->meta.num_terms, infile);
+      if(ser->meta.num_terms != numread) {
+	goto file_screwup;
+      }
     }
   }
 
   return b;
 
+  /* If things fail, we'll end up somewhere near here. */
+ mem_screwup:
+  *error_ret = errno;
+  goto mem_cleanup;
+
+ file_screwup:
+  *error_ret = EIO;
+  goto mem_cleanup;
+
  mem_cleanup:
   ephint_free_body_elements(b);
   return NULL;
@@ -361,9 +392,15 @@
   }
 
   /* Attempt to read data from the file. */
-  body_elements *be = ephint_read_body_elements(f);
+  int error_ret;
+  body_elements *be = ephint_read_body_elements(f, &error_ret);
+  if(NULL == be) {
+    /* Oops, there was some problem loading data from the file.
+       error_ret should have been set to either a malloc or calloc
+       error, or to EIO. */
+    return error_ret;
+  }
 
-
   /* Note that there's no checking to make sure the file was loaded successfully.  This is bad. */
 
 
@@ -420,7 +457,8 @@
  *
  *  @return 0 if the requested data was available (and returned),
  *  otherwise an errno value that could have been set by fopen(),
- *  fclose(), or realloc() is returned.
+ *  fclose(), realloc(), malloc() or calloc() is usually returned.
+ *  EIO is returned if there was a problem loading some file data.
  */
 int get_vsop_data_handle(const vsop_body planet, const vsop_version version, vsop_handle *vh)
 {



From izogi at berlios.de  Sat Jan 28 03:04:27 2006
From: izogi at berlios.de (izogi at BerliOS)
Date: Sat, 28 Jan 2006 03:04:27 +0100
Subject: [Ephemeritis-svn] r226 - branches/new-vsop-prepare/src/c/libephemeritis
Message-ID: <200601280204.k0S24RgV027031@sheep.berlios.de>

Author: izogi
Date: 2006-01-28 03:04:08 +0100 (Sat, 28 Jan 2006)
New Revision: 226

Modified:
   branches/new-vsop-prepare/src/c/libephemeritis/vsop_data_handling.c
Log:
Removed a minor comment indicating that error checking hadn't been coded.


Modified: branches/new-vsop-prepare/src/c/libephemeritis/vsop_data_handling.c
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/vsop_data_handling.c	2006-01-28 02:00:16 UTC (rev 225)
+++ branches/new-vsop-prepare/src/c/libephemeritis/vsop_data_handling.c	2006-01-28 02:04:08 UTC (rev 226)
@@ -401,9 +401,6 @@
     return error_ret;
   }
 
-  /* Note that there's no checking to make sure the file was loaded successfully.  This is bad. */
-
-
   /* Close the file. */
   errno = 0;
   if(0 != fclose(f)) {



From izogi at berlios.de  Sat Jan 28 03:12:31 2006
From: izogi at berlios.de (izogi at BerliOS)
Date: Sat, 28 Jan 2006 03:12:31 +0100
Subject: [Ephemeritis-svn] r228 - in branches/new-vsop-prepare/src/c: tests utils
Message-ID: <200601280212.k0S2CVr6029727@sheep.berlios.de>

Author: izogi
Date: 2006-01-28 03:12:11 +0100 (Sat, 28 Jan 2006)
New Revision: 228

Modified:
   branches/new-vsop-prepare/src/c/tests/validate_meeus.c
   branches/new-vsop-prepare/src/c/utils/build_vsop_data.c
Log:
Ran 'indent -kr' on utils/ and tests/ files.


Modified: branches/new-vsop-prepare/src/c/tests/validate_meeus.c
===================================================================
--- branches/new-vsop-prepare/src/c/tests/validate_meeus.c	2006-01-28 02:10:20 UTC (rev 227)
+++ branches/new-vsop-prepare/src/c/tests/validate_meeus.c	2006-01-28 02:12:11 UTC (rev 228)
@@ -70,7 +70,8 @@
 	printf("%s%sERROR:\n", tab, tab);
 	printf("%s%s%scomputed   = %.10f\n", tab, tab, tab, computed);
 	printf("%s%s%sreference  = %.10f\n", tab, tab, tab, reference);
-	printf("%s%s%sdifference = %.10f %s\n", tab, tab, tab, diff, units);
+	printf("%s%s%sdifference = %.10f %s\n", tab, tab, tab, diff,
+	       units);
     } else {
     }
 }
@@ -88,21 +89,22 @@
 			     double *longitude, double *latitude,
 			     double *radius)
 {
-  vsop_handle vh;
-  if(0 == get_vsop_data_handle(planet, hel_sph_date, &vh)) {
-    vsop_sph_coords vsc = vsop_get_spherical(vh, jd);
-    if(vsc.error_state != 0) {
-      printf("Error calculating spherical coordinates: %d\n", vsc.error_state);
-      return 0;
+    vsop_handle vh;
+    if (0 == get_vsop_data_handle(planet, hel_sph_date, &vh)) {
+	vsop_sph_coords vsc = vsop_get_spherical(vh, jd);
+	if (vsc.error_state != 0) {
+	    printf("Error calculating spherical coordinates: %d\n",
+		   vsc.error_state);
+	    return 0;
+	}
+	*longitude = vsc.sc.L;
+	*latitude = vsc.sc.B;
+	*radius = vsc.sc.R;
+	return 1;
+    } else {
+	printf("Unable to allocate the VSOP handle.\n");
+	return 0;
     }
-    *longitude = vsc.sc.L;
-    *latitude = vsc.sc.B;
-    *radius = vsc.sc.R;
-    return 1;
-  } else {
-    printf("Unable to allocate the VSOP handle.\n");
-    return 0;
-  }
 }
 
 int vsop_dimension3_fk5_new(double jd,
@@ -110,21 +112,23 @@
 			    double *longitude, double *latitude,
 			    double *radius)
 {
-  vsop_handle vh;
-  if(0 == get_vsop_data_handle(planet, hel_sph_date, &vh)) {
-    vsop_sph_coords vsc = vsop_sph_vsop_to_fk5(vsop_get_spherical(vh, jd));
-    if(vsc.error_state != 0) {
-      printf("Error calculating spherical coordinates: %d\n", vsc.error_state);
-      return 0;
+    vsop_handle vh;
+    if (0 == get_vsop_data_handle(planet, hel_sph_date, &vh)) {
+	vsop_sph_coords vsc =
+	    vsop_sph_vsop_to_fk5(vsop_get_spherical(vh, jd));
+	if (vsc.error_state != 0) {
+	    printf("Error calculating spherical coordinates: %d\n",
+		   vsc.error_state);
+	    return 0;
+	}
+	*longitude = vsc.sc.L;
+	*latitude = vsc.sc.B;
+	*radius = vsc.sc.R;
+	return 1;
+    } else {
+	printf("Unable to allocate the VSOP handle.\n");
+	return 0;
     }
-    *longitude = vsc.sc.L;
-    *latitude = vsc.sc.B;
-    *radius = vsc.sc.R;
-    return 1;
-  } else {
-    printf("Unable to allocate the VSOP handle.\n");
-    return 0;
-  }
 }
 
 /*
@@ -596,7 +600,8 @@
 		   dms_to_d(0.0, 0.0, 0.0895) * 28.86705);
 	double a1;
 	double d1;
-	precession_eq(precession_get_elements_eq(2451545.0, 2462088.69), a0, d0, &a1, &d1);
+	precession_eq(precession_get_elements_eq(2451545.0, 2462088.69),
+		      a0, d0, &a1, &d1);
 
 	report("RA", a1, fday_to_r(hms_to_fday(2, 46, 11.331)), 0.00001,
 	       "radians");
@@ -609,7 +614,9 @@
 	double lat = d_to_r(1.76549);
 	double lon1;
 	double lat1;
-	precession_ecl(precession_get_elements_ecl(je_to_jd(2000.0), 1643074.5), lon, lat, &lon1, &lat1);
+	precession_ecl(precession_get_elements_ecl
+		       (je_to_jd(2000.0), 1643074.5), lon, lat, &lon1,
+		       &lat1);
 	report("Longitude", lon1, d_to_r(118.704), 0.00001, "radians");
 	report("Latitude", lat1, d_to_r(1.615), 0.0001, "radians");
     }
@@ -658,59 +665,68 @@
 
     printf("23.a Apparent place of a star\n");
     {
-      double jd = ut_to_dt(cal_to_jd(2028, 11, 13.19, true));
-      double ra = hms_to_r(2,46,11.331);
-      double dec = d_to_r(dms_to_d(49,20,54.54));
+	double jd = ut_to_dt(cal_to_jd(2028, 11, 13.19, true));
+	double ra = hms_to_r(2, 46, 11.331);
+	double dec = d_to_r(dms_to_d(49, 20, 54.54));
 
-      double n_in_l = nut_in_lon(jd);
-      /*
-	d_to_r(dms_to_d(0,0,14.861));
-      */
+	double n_in_l = nut_in_lon(jd);
+	/*
+	   d_to_r(dms_to_d(0,0,14.861));
+	 */
 
-      double n_in_o = nut_in_obl(jd);
-      /*
-	d_to_r(dms_to_d(0,0,2.705));
-      */
+	double n_in_o = nut_in_obl(jd);
+	/*
+	   d_to_r(dms_to_d(0,0,2.705));
+	 */
 
-      double obl = obliquity_hi(jd);
-      /*
-	d_to_r(23.436);
-      */
+	double obl = obliquity_hi(jd);
+	/*
+	   d_to_r(23.436);
+	 */
 
-      double sol_lon, sol_rad;
-      longitude_radius_low(jd, &sol_lon, &sol_rad);
-      /*
-      sol_lon = d_to_r(231.328);
-      */
+	double sol_lon, sol_rad;
+	longitude_radius_low(jd, &sol_lon, &sol_rad);
+	/*
+	   sol_lon = d_to_r(231.328);
+	 */
 
-      double n_in_ra, n_in_dec;
-      nut_in_ra_dec(ra, dec, obl, n_in_l, n_in_o, &n_in_ra, &n_in_dec);
+	double n_in_ra, n_in_dec;
+	nut_in_ra_dec(ra, dec, obl, n_in_l, n_in_o, &n_in_ra, &n_in_dec);
 
-      double a_in_ra, a_in_dec;
-      aberration_in_ra_dec_low(jd, ra, dec, obl, sol_lon, &a_in_ra, &a_in_dec);
+	double a_in_ra, a_in_dec;
+	aberration_in_ra_dec_low(jd, ra, dec, obl, sol_lon, &a_in_ra,
+				 &a_in_dec);
 
-      /*
-      int d1, m1, d2, m2;
-      double s1, s2;
-      d_to_dms(r_to_d(n_in_ra), &d1, &m1, &s1);
-      d_to_dms(r_to_d(n_in_dec), &d2, &m2, &s2);
-      printf("%d:%d:%.10f$$$%d:%d:%.10f\n", d1,m1,s1,d2,m2,s2);
-      */
+	/*
+	   int d1, m1, d2, m2;
+	   double s1, s2;
+	   d_to_dms(r_to_d(n_in_ra), &d1, &m1, &s1);
+	   d_to_dms(r_to_d(n_in_dec), &d2, &m2, &s2);
+	   printf("%d:%d:%.10f$$$%d:%d:%.10f\n", d1,m1,s1,d2,m2,s2);
+	 */
 
-      report("nutation in longitude", n_in_l, d_to_r(dms_to_d(0,0,14.861)), 0.000001, "radians");
-      report("nutation in obliquity", n_in_o, d_to_r(dms_to_d(0,0,2.705)), 0.000001, "radians");
-      report("obliquity", obl, d_to_r(23.436), 0.0001, "radians");
-      report("sun's true longitude", sol_lon, d_to_r(231.328), 0.0001, "radians");
-      report("nutation in ra", n_in_ra, d_to_r(dms_to_d(0,0,15.843)), 0.000001, "radians");
-      report("nutation in dec", n_in_dec, d_to_r(dms_to_d(0,0,6.218)), 0.000001, "radians");
-      report("aberration in ra", a_in_ra, d_to_r(dms_to_d(0,0,30.045)), 0.000001, "radians");
-      report("aberration in dec", a_in_dec, d_to_r(dms_to_d(0,0,6.697)), 0.000001, "radians");
+	report("nutation in longitude", n_in_l,
+	       d_to_r(dms_to_d(0, 0, 14.861)), 0.000001, "radians");
+	report("nutation in obliquity", n_in_o,
+	       d_to_r(dms_to_d(0, 0, 2.705)), 0.000001, "radians");
+	report("obliquity", obl, d_to_r(23.436), 0.0001, "radians");
+	report("sun's true longitude", sol_lon, d_to_r(231.328), 0.0001,
+	       "radians");
+	report("nutation in ra", n_in_ra, d_to_r(dms_to_d(0, 0, 15.843)),
+	       0.000001, "radians");
+	report("nutation in dec", n_in_dec, d_to_r(dms_to_d(0, 0, 6.218)),
+	       0.000001, "radians");
+	report("aberration in ra", a_in_ra, d_to_r(dms_to_d(0, 0, 30.045)),
+	       0.000001, "radians");
+	report("aberration in dec", a_in_dec,
+	       d_to_r(dms_to_d(0, 0, 6.697)), 0.000001, "radians");
 
-      double new_ra = ra + n_in_ra + a_in_ra;
-      double new_dec = dec + n_in_dec + a_in_dec;
+	double new_ra = ra + n_in_ra + a_in_ra;
+	double new_dec = dec + n_in_dec + a_in_dec;
 
-      report("ra", new_ra, hms_to_r(2, 46, 14.390), 0.000001, "radians");
-      report("dec", new_dec, d_to_r(dms_to_d(49, 21, 07.45)), 0.000001, "radians");
+	report("ra", new_ra, hms_to_r(2, 46, 14.390), 0.000001, "radians");
+	report("dec", new_dec, d_to_r(dms_to_d(49, 21, 07.45)), 0.000001,
+	       "radians");
 
     }
 
@@ -726,33 +742,37 @@
 
     printf("25.b Sun position, high precision\n");
     {
-        double jd = 2448908.5;
+	double jd = 2448908.5;
 	double L, B, R;
 	sol_dimension3_vsop(jd, &L, &B, &R);
 	/*
-	report_diff("longitude", r_to_d(L) * 3600, 199.907372 * 3600,
-		    "arc-seconds");
-	report_diff("latitude", r_to_d(B) * 3600, 0.644, "arc-seconds");
-	report_diff("radius", R * km_per_au, 0.99760775 * km_per_au, "km");
-	*/
+	   report_diff("longitude", r_to_d(L) * 3600, 199.907372 * 3600,
+	   "arc-seconds");
+	   report_diff("latitude", r_to_d(B) * 3600, 0.644, "arc-seconds");
+	   report_diff("radius", R * km_per_au, 0.99760775 * km_per_au, "km");
+	 */
 
-	report("longitude", r_to_d(L) * 3600, 199.907372 * 3600, 1.0, "arc-seconds");
+	report("longitude", r_to_d(L) * 3600, 199.907372 * 3600, 1.0,
+	       "arc-seconds");
 	report("latitude", r_to_d(B) * 3600, 0.644, 1.0, "arc-seconds");
-	report("radius", R * km_per_au, 0.99760775 * km_per_au, 200.0, "km");
+	report("radius", R * km_per_au, 0.99760775 * km_per_au, 200.0,
+	       "km");
 
 	vsop_to_fk5(2448908.5, &L, &B);
 
 	/*
-	report_diff("corrected longitude", r_to_d(L) * 3600,
-		    199.907347 * 3600, "arc-seconds");
-	report_diff("corrected latitude", r_to_d(B) * 3600, 0.62,
-		    "arc-seconds");
-	*/
-	report("corrected fk5 longitude", r_to_d(L) * 3600, 199.907347 * 3600, 1.0, "arc-seconds");
-	report("corrected fk5 latitude", r_to_d(B) * 3600, 0.644 - 0.023, 0.1, "arc-seconds");
+	   report_diff("corrected longitude", r_to_d(L) * 3600,
+	   199.907347 * 3600, "arc-seconds");
+	   report_diff("corrected latitude", r_to_d(B) * 3600, 0.62,
+	   "arc-seconds");
+	 */
+	report("corrected fk5 longitude", r_to_d(L) * 3600,
+	       199.907347 * 3600, 1.0, "arc-seconds");
+	report("corrected fk5 latitude", r_to_d(B) * 3600, 0.644 - 0.023,
+	       0.1, "arc-seconds");
 	/*
-	report("corrected fk5 latitude", r_to_d(B) * 3600, 0.62, 0.1, "arc-seconds");
-	*/
+	   report("corrected fk5 latitude", r_to_d(B) * 3600, 0.62, 0.1, "arc-seconds");
+	 */
 
 	printf
 	    ("25.b Sun position, high precision (complete theory pg 165)\n");
@@ -762,15 +782,17 @@
 	const double obl = obliquity_hi(jd) + n_in_o;
 	const double aberration = aberration_low(R);
 
-	report("nutation in lon", r_to_d(n_in_l) * 3600, 15.908, 0.001, "arc-seconds");
-	report("nutation in obliquity", r_to_d(n_in_o) * 3600, -0.308, 0.001, "arc-seconds");
+	report("nutation in lon", r_to_d(n_in_l) * 3600, 15.908, 0.001,
+	       "arc-seconds");
+	report("nutation in obliquity", r_to_d(n_in_o) * 3600, -0.308,
+	       0.001, "arc-seconds");
 	report("obliquity", r_to_d(obl), 23.4401443, 0.0000001, "degrees");
-	report("aberration", r_to_d(aberration) * 3600, -20.539, 0.001, "arc-seconds");
+	report("aberration", r_to_d(aberration) * 3600, -20.539, 0.001,
+	       "arc-seconds");
 
 	double app_lon = L + n_in_l + aberration;
 	report("apparent longitude", r_to_d(app_lon) * 3600.0,
-	       dms_to_d(199, 54, 21.818) * 3600.0, 1,
-	       "arc-seconds");
+	       dms_to_d(199, 54, 21.818) * 3600.0, 1, "arc-seconds");
 
 	report("longitude", r_to_d(L) * 3600 * 100,
 	       dms_to_d(199, 54, 26.18) * 3600 * 100, 1,
@@ -805,16 +827,23 @@
 
 	vsop_handle vh;
 	int result;
-	if(0 != (result = get_vsop_data_handle(vsop_earth, hel_sph_date, &vh))) {
-	  printf("Problem opening file: %s", strerror(result));
+	if (0 !=
+	    (result =
+	     get_vsop_data_handle(vsop_earth, hel_sph_date, &vh))) {
+	    printf("Problem opening file: %s", strerror(result));
 	} else {
-	  vsop_sph_coords vsc = vsop_sph_vsop_to_fk5(vsop_get_spherical(vh, jd));
+	    vsop_sph_coords vsc =
+		vsop_sph_vsop_to_fk5(vsop_get_spherical(vh, jd));
 
-	  double E = obliquity_hi(jd);
-	  rec_coords rc = sol_rectangular(vsc.sc.L, vsc.sc.B, vsc.sc.R, E);
-	  report("X", -rc.x * km_per_au, -0.9379952 * km_per_au, 5.0, "km");
-	  report("Y", -rc.y * km_per_au, -0.3116544 * km_per_au, 5.0, "km");
-	  report("Z", -rc.z * km_per_au, -0.1351215 * km_per_au, 5.0, "km");
+	    double E = obliquity_hi(jd);
+	    rec_coords rc =
+		sol_rectangular(vsc.sc.L, vsc.sc.B, vsc.sc.R, E);
+	    report("X", -rc.x * km_per_au, -0.9379952 * km_per_au, 5.0,
+		   "km");
+	    report("Y", -rc.y * km_per_au, -0.3116544 * km_per_au, 5.0,
+		   "km");
+	    report("Z", -rc.z * km_per_au, -0.1351215 * km_per_au, 5.0,
+		   "km");
 
 	}
 
@@ -828,9 +857,9 @@
 /* 	  report("X", -vrc.rc.x * km_per_au, -0.9379952 * km_per_au, 5.0, "km"); */
 /* 	  report("Y", -vrc.rc.y * km_per_au, -0.3116544 * km_per_au, 5.0, "km"); */
 /* 	  report("Z", -vrc.rc.z * km_per_au, -0.1351215 * km_per_au, 5.0, "km"); */
-	  
+
 /* 	} */
- 
+
     }
 
     printf("27.a Approximate solstice\n");
@@ -924,7 +953,7 @@
 
     printf("28.a Equation of time\n");
     {
-      double jd = 2448908.5;
+	double jd = 2448908.5;
 	double eot_result = equation_of_time(jd);
 	report("Equation of time", eot_result * 3600.0,
 	       fday_to_r(hms_to_fday(0.0, 13.0, 42.6)) * 3600.0, 1,
@@ -944,14 +973,15 @@
     {
 	double L, B, R;
 	/*
-	vsop_dimension3_vsop(2448976.5, vVenus, &L, &B, &R);
-	*/
-	if(vsop_dimension3_vsop_new(2448976.5, vsop_venus, &L, &B, &R)) {
-	  report("longitude", r_to_d(L), 26.11428, 1.0, "deg");
-	  report("latitude", r_to_d(B), -2.62070, 1.0, "deg");
-	  report("radius", R * km_per_au, 0.724603 * km_per_au, 200.0, "km");
+	   vsop_dimension3_vsop(2448976.5, vVenus, &L, &B, &R);
+	 */
+	if (vsop_dimension3_vsop_new(2448976.5, vsop_venus, &L, &B, &R)) {
+	    report("longitude", r_to_d(L), 26.11428, 1.0, "deg");
+	    report("latitude", r_to_d(B), -2.62070, 1.0, "deg");
+	    report("radius", R * km_per_au, 0.724603 * km_per_au, 200.0,
+		   "km");
 	} else {
-	  printf("There was a problem with the VSOP code or data.\n");
+	    printf("There was a problem with the VSOP code or data.\n");
 	}
     }
 
@@ -959,13 +989,14 @@
     {
 	double ra, dec;
 	/*
-	geocentric_planet(2448976.5, vEarth, vVenus, vsop_dimension3_fk5,
+	   geocentric_planet(2448976.5, vEarth, vVenus, vsop_dimension3_fk5,
+	   d_to_r(dms_to_d(0, 0, 16.749)),
+	   d_to_r(23.439669), days_per_second, &ra, &dec);
+	 */
+	geocentric_planet(2448976.5, vsop_earth, vsop_venus,
+			  vsop_dimension3_fk5_new,
 			  d_to_r(dms_to_d(0, 0, 16.749)),
 			  d_to_r(23.439669), days_per_second, &ra, &dec);
-	*/
-	geocentric_planet(2448976.5, vsop_earth, vsop_venus, vsop_dimension3_fk5_new,
-			  d_to_r(dms_to_d(0, 0, 16.749)),
-			  d_to_r(23.439669), days_per_second, &ra, &dec);
 
 	report("ra", r_to_d(ra), r_to_d(hms_to_fday(21, 4, 41.454) * pi2),
 	       1e-5, "degrees");
@@ -999,51 +1030,63 @@
 
 	vsop_handle vh;
 	int result;
-	if(0 != (result = get_vsop_data_handle(vsop_earth, hel_sph_j2, &vh))) {
-	  printf("Problem opening file: %s", strerror(result));
+	if (0 !=
+	    (result = get_vsop_data_handle(vsop_earth, hel_sph_j2, &vh))) {
+	    printf("Problem opening file: %s", strerror(result));
 	} else {
-	  vsop_sph_coords vsc = vsop_sph_vsop_to_fk5(vsop_get_spherical(vh, jd));
+	    vsop_sph_coords vsc =
+		vsop_sph_vsop_to_fk5(vsop_get_spherical(vh, jd));
 
-	  double E = obliquity_hi(jd);
-	  rec_coords src = sol_rectangular(vsc.sc.L, vsc.sc.B, vsc.sc.R, E);
-	  src.x = -src.x;
-	  src.y = -src.y;
-	  src.z = -src.z;
+	    double E = obliquity_hi(jd);
+	    rec_coords src =
+		sol_rectangular(vsc.sc.L, vsc.sc.B, vsc.sc.R, E);
+	    src.x = -src.x;
+	    src.y = -src.y;
+	    src.z = -src.z;
 
 /* 	double L, B, R; */
 /* 	sol_dimension3_fk5(jd, &L, &B, &R); */
 /* 	rec_coords src = sol_rectangular(L, B, R, obl2000); */
-	  report("solar x", src.x * km_per_au, -0.9756732 * km_per_au, 800, "km");
-	  report("solar y", src.y * km_per_au, -0.2003254 * km_per_au, 800, "km");
-	  report("solar z", src.z * km_per_au, -0.0868566 * km_per_au, 800, "km");
+	    report("solar x", src.x * km_per_au, -0.9756732 * km_per_au,
+		   800, "km");
+	    report("solar y", src.y * km_per_au, -0.2003254 * km_per_au,
+		   800, "km");
+	    report("solar z", src.z * km_per_au, -0.0868566 * km_per_au,
+		   800, "km");
 
 /* 	printf("Resetting sol values to those in example (because VSOP isn't calculating them properly as above)\n"); */
 /* 	src.x = -0.9756732; */
 /* 	src.y = -0.2003254; */
 /* 	src.z = -0.0868566; */
 
-	  double ra, dec, elongation, phase_angle, body_r_earth;
-	  elliptical_orbit_ecliptical(src, rc, r_sun, &ra, &dec, &elongation, &phase_angle, &body_r_earth);
+	    double ra, dec, elongation, phase_angle, body_r_earth;
+	    elliptical_orbit_ecliptical(src, rc, r_sun, &ra, &dec,
+					&elongation, &phase_angle,
+					&body_r_earth);
 
-	  report("delta-earth", body_r_earth, 0.8243689, 0.000001, "AU");
+	    report("delta-earth", body_r_earth, 0.8243689, 0.000001, "AU");
 
-	  double tau = 0.0057755183 * body_r_earth;
-	  jd = jd - tau;
-	  el.M = mean_anomoly(jd, T, el.n);
-	  ec = get_element_constants(obl2000, el, 53);
-	  r_sun = get_r_sun(ec);
-	  rc = elliptical_orbit_rectangular(ec, r_sun);
+	    double tau = 0.0057755183 * body_r_earth;
+	    jd = jd - tau;
+	    el.M = mean_anomoly(jd, T, el.n);
+	    ec = get_element_constants(obl2000, el, 53);
+	    r_sun = get_r_sun(ec);
+	    rc = elliptical_orbit_rectangular(ec, r_sun);
 
-	  report("recalc-x", rc.x, 0.2509310, 0.000001, "AU");
-	  report("recalc-y", rc.y, 0.4849477, 0.000001, "AU");
-	  report("recalc-z", rc.z, 0.3573712, 0.000001, "AU");
+	    report("recalc-x", rc.x, 0.2509310, 0.000001, "AU");
+	    report("recalc-y", rc.y, 0.4849477, 0.000001, "AU");
+	    report("recalc-z", rc.z, 0.3573712, 0.000001, "AU");
 
-	  elliptical_orbit_ecliptical(src, rc, r_sun, &ra, &dec, &elongation, &phase_angle, &body_r_earth);
+	    elliptical_orbit_ecliptical(src, rc, r_sun, &ra, &dec,
+					&elongation, &phase_angle,
+					&body_r_earth);
 
-	  report("recalc-delta-earth", body_r_earth, 0.8242811, 0.000001, "AU");
-	  report("ra", ra, d_to_r(158.558965), 0.00001, "radians");
-	  report("dec", dec, d_to_r(19.158496), 0.00001, "radians");
-	  report("elongation", elongation, d_to_r(40.51), 0.00001, "radians");
+	    report("recalc-delta-earth", body_r_earth, 0.8242811, 0.000001,
+		   "AU");
+	    report("ra", ra, d_to_r(158.558965), 0.00001, "radians");
+	    report("dec", dec, d_to_r(19.158496), 0.00001, "radians");
+	    report("elongation", elongation, d_to_r(40.51), 0.00001,
+		   "radians");
 	}
 
     }
@@ -1154,20 +1197,22 @@
 
 	    vsop_handle vh;
 	    get_vsop_data_handle(vsop_earth, hel_sph_j2, &vh);
-	    vsop_sph_coords vsc = vsop_sph_vsop_to_fk5(vsop_get_spherical(vh, test->jd));
+	    vsop_sph_coords vsc =
+		vsop_sph_vsop_to_fk5(vsop_get_spherical(vh, test->jd));
 
 	    double E = obliquity_hi(test->jd);
 	    vsc.sc.L = modpi2(vsc.sc.L + pi);
 	    vsc.sc.B = -vsc.sc.B;
-	    rec_coords sun_rec = sol_rectangular(vsc.sc.L, vsc.sc.B, vsc.sc.R, E);
+	    rec_coords sun_rec =
+		sol_rectangular(vsc.sc.L, vsc.sc.B, vsc.sc.R, E);
 
 
 
 	    /*
-	    double L, B, R;
-	    sol_dimension3_fk5(test->jd, &L, &B, &R);
-	    rec_coords sun_rec = sol_rectangular(L, B, R, obliquity_hi(je_to_jd(2000)));
-	    */
+	       double L, B, R;
+	       sol_dimension3_fk5(test->jd, &L, &B, &R);
+	       rec_coords sun_rec = sol_rectangular(L, B, R, obliquity_hi(je_to_jd(2000)));
+	     */
 
 	    double ra;
 	    double dec;
@@ -1179,22 +1224,26 @@
 
 	    double this_jd = test->jd;
 	    int c;
-	    for(c=0;c<5;c++) {
-	      cd = populate_orbital_elements(or->epoch, or->M, this_jd, or->n,
-					     or->a, or->e, or->i, or->w, or->L,
-					     iau_s, or->H, or->G);
+	    for (c = 0; c < 5; c++) {
+		cd = populate_orbital_elements(or->epoch, or->M, this_jd,
+					       or->n, or->a, or->e, or->i,
+					       or->w, or->L, iau_s, or->H,
+					       or->G);
 
-	      element_constants ec = get_element_constants(obliquity_hi(je_to_jd(2000)), cd, 53);
-	      body_r_sun = get_r_sun(ec);
-	      rec_coords body_rec = elliptical_orbit_rectangular(ec, body_r_sun);
+		element_constants ec =
+		    get_element_constants(obliquity_hi(je_to_jd(2000)), cd,
+					  53);
+		body_r_sun = get_r_sun(ec);
+		rec_coords body_rec =
+		    elliptical_orbit_rectangular(ec, body_r_sun);
 
-	      elliptical_orbit_ecliptical(sun_rec, body_rec, body_r_sun,
-					  &ra, &dec, &elongation,
-					  &phase_angle, &body_r_earth);
+		elliptical_orbit_ecliptical(sun_rec, body_rec, body_r_sun,
+					    &ra, &dec, &elongation,
+					    &phase_angle, &body_r_earth);
 
-	      double tau = 0.0057755183 * body_r_earth;
+		double tau = 0.0057755183 * body_r_earth;
 
-	      this_jd = test->jd - tau;
+		this_jd = test->jd - tau;
 
 	    }
 
@@ -1217,26 +1266,40 @@
 
 	    /* Adjust for nutation. */
 	    double a_in_ra, a_in_dec;
-	    aberration_in_ra_dec_low(test->jd, ra, dec, obliquity_hi(test->jd), vsc.sc.L, &a_in_ra, &a_in_dec);
-	    ra  += a_in_ra;
+	    aberration_in_ra_dec_low(test->jd, ra, dec,
+				     obliquity_hi(test->jd), vsc.sc.L,
+				     &a_in_ra, &a_in_dec);
+	    ra += a_in_ra;
 	    dec += a_in_dec;
 
-	    precession_eq(precession_get_elements_eq(je_to_jd(2000.0), test->jd), ra, dec, &ra, &dec);
+	    precession_eq(precession_get_elements_eq
+			  (je_to_jd(2000.0), test->jd), ra, dec, &ra,
+			  &dec);
 
 	    double n_in_ra, n_in_dec;
-	    nut_in_ra_dec(ra, dec, obliquity_hi(test->jd), nut_in_lon(test->jd), nut_in_obl(test->jd), &n_in_ra, &n_in_dec);
-	    ra  += n_in_ra ;
+	    nut_in_ra_dec(ra, dec, obliquity_hi(test->jd),
+			  nut_in_lon(test->jd), nut_in_obl(test->jd),
+			  &n_in_ra, &n_in_dec);
+	    ra += n_in_ra;
 	    dec += n_in_dec;
 
 
 
-	    printf("$$$$ %f:%f $$$$\n", (n_in_ra * (360.0 * 60.0 * 60.0) / (2*pi)), (n_in_dec * (360.0 * 60.0 * 60.0) / (2*pi)));
-	    printf("$$$$ %f:%f $$$$\n", (a_in_ra * (360.0 * 60.0 * 60.0) / (2*pi)), (a_in_dec * (360.0 * 60.0 * 60.0) / (2*pi)));
+	    printf("$$$$ %f:%f $$$$\n",
+		   (n_in_ra * (360.0 * 60.0 * 60.0) / (2 * pi)),
+		   (n_in_dec * (360.0 * 60.0 * 60.0) / (2 * pi)));
+	    printf("$$$$ %f:%f $$$$\n",
+		   (a_in_ra * (360.0 * 60.0 * 60.0) / (2 * pi)),
+		   (a_in_dec * (360.0 * 60.0 * 60.0) / (2 * pi)));
 
-	    report("RA", (ra * (360.0 * 60.0 * 60.0) / (2*pi)), (test->ra * (360.0 * 60.0 * 60.0) / (2*pi)), 0.00030, "arc-sec");
-	    report("Declination", (dec * (360.0 * 60.0 * 60.0) / (2*pi)), (test->dec * (360.0 * 60.0 * 60.0) / (2*pi)), 0.00030, "arc-sec");
-	    report("Distance (Earth)", body_r_earth, test->r_earth, 0.000001,
-		   "AU");
+	    report("RA", (ra * (360.0 * 60.0 * 60.0) / (2 * pi)),
+		   (test->ra * (360.0 * 60.0 * 60.0) / (2 * pi)), 0.00030,
+		   "arc-sec");
+	    report("Declination", (dec * (360.0 * 60.0 * 60.0) / (2 * pi)),
+		   (test->dec * (360.0 * 60.0 * 60.0) / (2 * pi)), 0.00030,
+		   "arc-sec");
+	    report("Distance (Earth)", body_r_earth, test->r_earth,
+		   0.000001, "AU");
 	    report("Distance (Sun)", body_r_sun, test->r_sun, 0.000001,
 		   "AU");
 	    report("Magnitude", mag, test->mag, 1.0, "");
@@ -1270,19 +1333,22 @@
     {
 	printf("Checking new VSOP routines\n");
 	{
-	  vsop_handle vh;
+	    vsop_handle vh;
 
- 	  if(0 != get_vsop_data_handle(vsop_earth, hel_rec_j2, &vh)) {
-	    printf("\t\tError loading Earth handle.\n");
-	  } else {
-	    double jd = 2448170.5;
-	    vsop_rec_coords vrc = vsop_get_rectangular(vh, jd);
-	    vrc = vsop_rec_invert(vsop_rec_vsop_to_fk5(vrc));
+	    if (0 != get_vsop_data_handle(vsop_earth, hel_rec_j2, &vh)) {
+		printf("\t\tError loading Earth handle.\n");
+	    } else {
+		double jd = 2448170.5;
+		vsop_rec_coords vrc = vsop_get_rectangular(vh, jd);
+		vrc = vsop_rec_invert(vsop_rec_vsop_to_fk5(vrc));
 
-	    report("X", vrc.rc.x * km_per_au, -0.975673220683  * km_per_au, 1.0e-4, "km");
-	    report("Y", vrc.rc.y * km_per_au, -0.200325394065  * km_per_au, 1.0e-4, "km");
-	    report("Z", vrc.rc.z * km_per_au, -0.0868565820014 * km_per_au, 1.0e-4, "km");
-	  }
+		report("X", vrc.rc.x * km_per_au,
+		       -0.975673220683 * km_per_au, 1.0e-4, "km");
+		report("Y", vrc.rc.y * km_per_au,
+		       -0.200325394065 * km_per_au, 1.0e-4, "km");
+		report("Z", vrc.rc.z * km_per_au,
+		       -0.0868565820014 * km_per_au, 1.0e-4, "km");
+	    }
 	}
     }
 /* 	{ */
@@ -1315,13 +1381,13 @@
 
 int main(int argc, char *argv[])
 {
-  vsop_data_init();
-  _main();
-  vsop_data_cleanup();
+    vsop_data_init();
+    _main();
+    vsop_data_cleanup();
 
-  printf
-    ("\nWarning: Former exception throws (now error return values)"
-     " have not been checked for.\n");
+    printf
+	("\nWarning: Former exception throws (now error return values)"
+	 " have not been checked for.\n");
     /*
        try {
        _main();
@@ -1330,5 +1396,5 @@
        cout << e.what() << endl;
        }
      */
-  return 0;
+    return 0;
 }

Modified: branches/new-vsop-prepare/src/c/utils/build_vsop_data.c
===================================================================
--- branches/new-vsop-prepare/src/c/utils/build_vsop_data.c	2006-01-28 02:10:20 UTC (rev 227)
+++ branches/new-vsop-prepare/src/c/utils/build_vsop_data.c	2006-01-28 02:12:11 UTC (rev 228)
@@ -42,13 +42,14 @@
 #define BUF_SIZE 1000
 
 
-static char *substr(char *target, char *src, const int start, const int end)
+static char *substr(char *target, char *src, const int start,
+		    const int end)
 {
-  char *t = target, *p;
-  for(p = src + start; p != src+end; p++)
-    *(t++) = *p;
-  *(t++) = '\0';
-  return target;
+    char *t = target, *p;
+    for (p = src + start; p != src + end; p++)
+	*(t++) = *p;
+    *(t++) = '\0';
+    return target;
 }
 
 
@@ -58,29 +59,30 @@
  */
 static char *strtrim(char *target, char *src)
 {
-  char *s = src, *t = target;
-  while(' ' == *s) s++;
-  do {
-    *t++ = *s;
-  } while('\0' != *s++);
-  int p;
-  for(p=strlen(target)-1; p>=0 && ' '==target[p]; p--) {
-    target[p] = '\0';
-  }
-  return target;
+    char *s = src, *t = target;
+    while (' ' == *s)
+	s++;
+    do {
+	*t++ = *s;
+    } while ('\0' != *s++);
+    int p;
+    for (p = strlen(target) - 1; p >= 0 && ' ' == target[p]; p--) {
+	target[p] = '\0';
+    }
+    return target;
 }
 
 
-static void fill_term(term_bin *t, char *incoming)
+static void fill_term(term_bin * t, char *incoming)
 {
-  char ch_A[32], ch_B[32], ch_C[32];
-  substr(ch_A, incoming,  79,  97);
-  substr(ch_B, incoming,  97, 111);
-  substr(ch_C, incoming, 111, 131);
+    char ch_A[32], ch_B[32], ch_C[32];
+    substr(ch_A, incoming, 79, 97);
+    substr(ch_B, incoming, 97, 111);
+    substr(ch_C, incoming, 111, 131);
 
-  t->A = atof(ch_A);
-  t->B = atof(ch_B);
-  t->C = atof(ch_C);
+    t->A = atof(ch_A);
+    t->B = atof(ch_B);
+    t->C = atof(ch_C);
 }
 
 
@@ -89,69 +91,82 @@
 /*! @brief Allocates space for and builds a body_elements structure in
  *  memory, given an opened file to read from.
  */
-static body_elements *build_body_elements(FILE *infile)
+static body_elements *build_body_elements(FILE * infile)
 {
-  /* Write the header at the start to force space.  It'll need
-   * overwriting at the end, as the data isn't available yet.
-   */
-  body_elements *body_el = (body_elements *)malloc(sizeof(body_elements));
-  memset(body_el, '\0', sizeof(*body_el));
-  sprintf(body_el->meta.eph_header_text, EPHEMERITIS_BIN_HEADER_TEXT_FORMAT, VERSION);
-  body_el->meta.num_variables = 0;
+    /* Write the header at the start to force space.  It'll need
+     * overwriting at the end, as the data isn't available yet.
+     */
+    body_elements *body_el =
+	(body_elements *) malloc(sizeof(body_elements));
+    memset(body_el, '\0', sizeof(*body_el));
+    sprintf(body_el->meta.eph_header_text,
+	    EPHEMERITIS_BIN_HEADER_TEXT_FORMAT, VERSION);
+    body_el->meta.num_variables = 0;
 
-  /* Allocate a reasonably sized buffer for reading lines into. */
-  char buf[BUF_SIZE];
+    /* Allocate a reasonably sized buffer for reading lines into. */
+    char buf[BUF_SIZE];
 
-  char *incoming;
-  char ch_body_name[8];
-  char ch_variable_num[2];
-  char ch_alpha[2];
-  char ch_num_terms[8];
+    char *incoming;
+    char ch_body_name[8];
+    char ch_variable_num[2];
+    char ch_alpha[2];
+    char ch_num_terms[8];
 
 
-  incoming = fgets(buf, BUF_SIZE, infile);
-  while(NULL != incoming) {
-    /* Extract some data. */
-    substr(ch_body_name, incoming, 22, 29);
-    substr(ch_variable_num, incoming, 41, 42);
-    substr(ch_alpha, incoming, 59, 60);
-    substr(ch_num_terms, incoming, 60, 67);
+    incoming = fgets(buf, BUF_SIZE, infile);
+    while (NULL != incoming) {
+	/* Extract some data. */
+	substr(ch_body_name, incoming, 22, 29);
+	substr(ch_variable_num, incoming, 41, 42);
+	substr(ch_alpha, incoming, 59, 60);
+	substr(ch_num_terms, incoming, 60, 67);
 
-    int variable_index = atoi(ch_variable_num) - 1;
-    int alpha = atoi(ch_alpha);
-    int num_terms = atoi(ch_num_terms);
+	int variable_index = atoi(ch_variable_num) - 1;
+	int alpha = atoi(ch_alpha);
+	int num_terms = atoi(ch_num_terms);
 
-    /* Copy in the name of the body (redundant all times except the first). */
-    strncpy(body_el->meta.body_name, strtrim(ch_body_name, ch_body_name), sizeof(body_el->meta.body_name));
+	/* Copy in the name of the body (redundant all times except the first). */
+	strncpy(body_el->meta.body_name,
+		strtrim(ch_body_name, ch_body_name),
+		sizeof(body_el->meta.body_name));
 
 
-    if(variable_index+1 > body_el->meta.num_variables) {
-      body_el->meta.num_variables = variable_index+1;
-    }
+	if (variable_index + 1 > body_el->meta.num_variables) {
+	    body_el->meta.num_variables = variable_index + 1;
+	}
 
 
-    /* This is a series header, so add a new series to the variable. */
-    body_el->variable_list[variable_index].meta.series_count++;
+	/* This is a series header, so add a new series to the variable. */
+	body_el->variable_list[variable_index].meta.series_count++;
 
 
-    body_el->variable_list[variable_index].series_list = (series *)realloc(body_el->variable_list[variable_index].series_list, sizeof(series) * body_el->variable_list[variable_index].meta.series_count);
+	body_el->variable_list[variable_index].series_list =
+	    (series *) realloc(body_el->variable_list[variable_index].
+			       series_list,
+			       sizeof(series) *
+			       body_el->variable_list[variable_index].meta.
+			       series_count);
 
-    series *this_series = &(body_el->variable_list[variable_index].series_list[body_el->variable_list[variable_index].meta.series_count-1]);
-    this_series->meta.alpha = alpha;
-    this_series->meta.num_terms = num_terms;
-    this_series->terms = (term_bin *)calloc(num_terms, sizeof(term_bin));
+	series *this_series =
+	    &(body_el->variable_list[variable_index].
+	      series_list[body_el->variable_list[variable_index].meta.
+			  series_count - 1]);
+	this_series->meta.alpha = alpha;
+	this_series->meta.num_terms = num_terms;
+	this_series->terms =
+	    (term_bin *) calloc(num_terms, sizeof(term_bin));
 
-    int n;
-    for(n = 0; n < num_terms; n++) {
-      incoming = fgets(buf, BUF_SIZE, infile);
-      fill_term(&(this_series->terms[n]), incoming);
+	int n;
+	for (n = 0; n < num_terms; n++) {
+	    incoming = fgets(buf, BUF_SIZE, infile);
+	    fill_term(&(this_series->terms[n]), incoming);
+	}
+
+	/* Read the next line. */
+	incoming = fgets(buf, BUF_SIZE, infile);
     }
 
-    /* Read the next line. */
-    incoming = fgets(buf, BUF_SIZE, infile);
-  }
-
-  return body_el;
+    return body_el;
 }
 
 /*! @brief Takes a source file and generate a binary file.
@@ -159,44 +174,45 @@
  *  @warning Any existing output files on the file system may be
  *  overwritten without warning.
  */
-static int process_streams(const char input_file[], const char output_file[])
+static int process_streams(const char input_file[],
+			   const char output_file[])
 {
-  FILE *infile, *outfile;
+    FILE *infile, *outfile;
 
-  /* Open files. */
-  if(!strcmp(input_file, "-")) {
-    infile = stdin;
-  } else if(NULL == (infile = fopen(input_file, "r"))) {
-    fprintf(stderr, "%s: %s\n", input_file, strerror(errno));
-    return 2;
-  }
+    /* Open files. */
+    if (!strcmp(input_file, "-")) {
+	infile = stdin;
+    } else if (NULL == (infile = fopen(input_file, "r"))) {
+	fprintf(stderr, "%s: %s\n", input_file, strerror(errno));
+	return 2;
+    }
 
-  if(!strcmp(output_file, "-")) {
-    outfile = stdout;
-  } else if(NULL == (outfile = fopen(output_file, "wb"))) {
-    fclose(infile);
-    fprintf(stderr, "%s: %s\n", output_file, strerror(errno));
-    return 3;
-  }
+    if (!strcmp(output_file, "-")) {
+	outfile = stdout;
+    } else if (NULL == (outfile = fopen(output_file, "wb"))) {
+	fclose(infile);
+	fprintf(stderr, "%s: %s\n", output_file, strerror(errno));
+	return 3;
+    }
 
-  body_elements *body_el = build_body_elements(infile);
+    body_elements *body_el = build_body_elements(infile);
 
-  /*
-  print_body_elements(stdout, body_el);
-  */
-  ephint_write_body_elements(outfile, body_el);
+    /*
+       print_body_elements(stdout, body_el);
+     */
+    ephint_write_body_elements(outfile, body_el);
 
-  ephint_free_body_elements(body_el);
+    ephint_free_body_elements(body_el);
 
-  /* Close files. */
-  if(infile != stdin) {
-    fclose(infile);
-  }
-  if((outfile != stdout) && (outfile != stderr)) {
-    fclose(outfile);
-  }
+    /* Close files. */
+    if (infile != stdin) {
+	fclose(infile);
+    }
+    if ((outfile != stdout) && (outfile != stderr)) {
+	fclose(outfile);
+    }
 
-  return 0;
+    return 0;
 }
 
 /*
@@ -217,17 +233,17 @@
 */
 int main(int argc, char *argv[])
 {
-  if(3 != argc) {
-    fprintf(stderr,
-	    "Usage: build_vsop_data <input_file> <output_file>\n"
-	    "Specifying - for either file will respectively represent stdin and stdout.\n");
-    return 1;
-  }
-  char* input_file = argv[1];
-  char* output_file = argv[2];
-  int result = process_streams(input_file, output_file);
-  /*
-  check_data(output_file);
-  */
-  return result;
+    if (3 != argc) {
+	fprintf(stderr,
+		"Usage: build_vsop_data <input_file> <output_file>\n"
+		"Specifying - for either file will respectively represent stdin and stdout.\n");
+	return 1;
+    }
+    char *input_file = argv[1];
+    char *output_file = argv[2];
+    int result = process_streams(input_file, output_file);
+    /*
+       check_data(output_file);
+     */
+    return result;
 }



From izogi at berlios.de  Sat Jan 28 03:10:42 2006
From: izogi at berlios.de (izogi at BerliOS)
Date: Sat, 28 Jan 2006 03:10:42 +0100
Subject: [Ephemeritis-svn] r227 - branches/new-vsop-prepare/src/c/libephemeritis
Message-ID: <200601280210.k0S2AgUq029016@sheep.berlios.de>

Author: izogi
Date: 2006-01-28 03:10:20 +0100 (Sat, 28 Jan 2006)
New Revision: 227

Modified:
   branches/new-vsop-prepare/src/c/libephemeritis/aberration.c
   branches/new-vsop-prepare/src/c/libephemeritis/conversions.c
   branches/new-vsop-prepare/src/c/libephemeritis/elliptical.c
   branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis.h
   branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_internal.h
   branches/new-vsop-prepare/src/c/libephemeritis/equationoftime.c
   branches/new-vsop-prepare/src/c/libephemeritis/nutation.c
   branches/new-vsop-prepare/src/c/libephemeritis/precession.c
   branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c
   branches/new-vsop-prepare/src/c/libephemeritis/vsop_data_handling.c
Log:
Ran 'indent -kr' on libephemeritis/ files.


Modified: branches/new-vsop-prepare/src/c/libephemeritis/aberration.c
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/aberration.c	2006-01-28 02:04:08 UTC (rev 226)
+++ branches/new-vsop-prepare/src/c/libephemeritis/aberration.c	2006-01-28 02:10:20 UTC (rev 227)
@@ -43,8 +43,8 @@
 {
     double T = jd_to_jcent(jd);
     /*
-(jd - 2451545.0) / 36525.0;
-*/
+       (jd - 2451545.0) / 36525.0;
+     */
     double e_terms[] = { 0.016708634, -0.000042037, -0.0000001267 };
     double p_terms[] =
 	{ d_to_r(102.93735), d_to_r(1.71946), d_to_r(0.00046) };

Modified: branches/new-vsop-prepare/src/c/libephemeritis/conversions.c
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/conversions.c	2006-01-28 02:04:08 UTC (rev 226)
+++ branches/new-vsop-prepare/src/c/libephemeritis/conversions.c	2006-01-28 02:10:20 UTC (rev 227)
@@ -239,14 +239,14 @@
  */
 void fday_to_hms(double day, int *hour, int *min, double *sec)
 {
-  /*
-    const long tsec = (long) (day * seconds_per_day);
-    const int tmin = tsec / 60;
-    const int thour = tmin / 60;
-    *hour = thour % 24;
-    *min = tmin % 60;
-    *sec = tsec % 60;
-    */
+    /*
+       const long tsec = (long) (day * seconds_per_day);
+       const int tmin = tsec / 60;
+       const int thour = tmin / 60;
+       *hour = thour % 24;
+       *min = tmin % 60;
+       *sec = tsec % 60;
+     */
 
     double tsec = day * seconds_per_day;
     *hour = (int) (tsec / 3600.0);
@@ -356,8 +356,8 @@
  */
 double circumpi(double x)
 {
-  x = modpi2(x);
-  return x > pi ? x - 2*pi : x;
+    x = modpi2(x);
+    return x > pi ? x - 2 * pi : x;
 }
 
 /*! @brief Converts radians to degrees.

Modified: branches/new-vsop-prepare/src/c/libephemeritis/elliptical.c
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/elliptical.c	2006-01-28 02:04:08 UTC (rev 226)
+++ branches/new-vsop-prepare/src/c/libephemeritis/elliptical.c	2006-01-28 02:10:20 UTC (rev 227)
@@ -431,7 +431,7 @@
  */
 double get_r_sun(const element_constants ec)
 {
-  return radius_vector(ec.a, ec.e, ec.E);
+    return radius_vector(ec.a, ec.e, ec.E);
 }
 
 /*! @brief Helper function to calculate magnitude using an absolute
@@ -596,10 +596,10 @@
     dest.i = i;
     dest.w = w;
     dest.L = L;
-    if(n != 0.0) {
-      dest.n = n;
+    if (n != 0.0) {
+	dest.n = n;
     } else {
-      dest.n = 0.9856076686 / (a * sqrt(a));
+	dest.n = 0.9856076686 / (a * sqrt(a));
     }
     dest.M = M_epoch + (n * (jd - epoch));
     if (abs_s == mdt) {

Modified: branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis.h
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis.h	2006-01-28 02:04:08 UTC (rev 226)
+++ branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis.h	2006-01-28 02:10:20 UTC (rev 227)
@@ -65,8 +65,8 @@
     vUranus,			/*!< @brief Uranus  */
     vNeptune,			/*!< @brief Neptune */
 
-    vSun,                       /*!< @brief Sun                   */
-    vEMB                        /*!< @brief Earth-Moon barycentre */
+    vSun,			/*!< @brief Sun                   */
+    vEMB			/*!< @brief Earth-Moon barycentre */
 };
 
 /*! @brief Contains a list of seasons.
@@ -192,7 +192,8 @@
 /* nutation.c */
 double nut_in_lon(double jd);
 double nut_in_obl(double jd);
-void nut_in_ra_dec(double ra, double dec, double obl, double n_in_l, double n_in_o, double *n_in_ra, double *n_in_dec);
+void nut_in_ra_dec(double ra, double dec, double obl, double n_in_l,
+		   double n_in_o, double *n_in_ra, double *n_in_dec);
 double obliquity_low(double jd);
 double obliquity_hi(double jd);
 
@@ -218,7 +219,7 @@
 		   double *raFinal, double *decFinal);
 
 precession_elements_ecl precession_get_elements_ecl(const double JDinitial,
-						     const double JDfinal);
+						    const double JDfinal);
 
 void precession_ecl(const precession_elements_ecl pcecl,
 		    const double longInitial,
@@ -443,17 +444,17 @@
 /*! @brief A list of bodies recognised by the VSOP model.
  */
 typedef enum {
-  vsop_mercury,			/*!< @brief Mercury */
-  vsop_venus,			/*!< @brief Venus   */
-  vsop_earth,			/*!< @brief Earth   */
-  vsop_mars,			/*!< @brief Mars    */
-  vsop_jupiter,			/*!< @brief Jupiter */
-  vsop_saturn,			/*!< @brief Saturn  */
-  vsop_uranus,			/*!< @brief Uranus  */
-  vsop_neptune,			/*!< @brief Neptune */
-  
-  vsop_sun,                     /*!< @brief Sun                   */
-  vsop_EMB                      /*!< @brief Earth-Moon barycentre */
+    vsop_mercury,		/*!< @brief Mercury */
+    vsop_venus,			/*!< @brief Venus   */
+    vsop_earth,			/*!< @brief Earth   */
+    vsop_mars,			/*!< @brief Mars    */
+    vsop_jupiter,		/*!< @brief Jupiter */
+    vsop_saturn,		/*!< @brief Saturn  */
+    vsop_uranus,		/*!< @brief Uranus  */
+    vsop_neptune,		/*!< @brief Neptune */
+
+    vsop_sun,			/*!< @brief Sun                   */
+    vsop_EMB			/*!< @brief Earth-Moon barycentre */
 } vsop_body;
 
 /*! @brief A list of versions available for the VSOP model.
@@ -464,76 +465,78 @@
     hel_sph_j2,			/*!< @brief Heliocentric Spherical Variables J2000     */
     hel_rec_date,		/*!< @brief Heliocentric Rectangular Variables of date */
     hel_sph_date,		/*!< @brief Heliocentric Spherical Variables of date   */
-    bar_rec_j2                  /*!< @brief Barycentric Rectangular Variables J2000    */
+    bar_rec_j2			/*!< @brief Barycentric Rectangular Variables J2000    */
 } vsop_version;
 
 
 /*! @brief A user-available structure to refer to VSOP data.
  */
 typedef struct {
-  vsop_body planet;     /*!< @brief The planet to which this data relates.  */
-  vsop_version version; /*!< @brief The series which this data is for.      */
+    vsop_body planet;		/*!< @brief The planet to which this data relates.  */
+    vsop_version version;	/*!< @brief The series which this data is for.      */
 
-  int data_id;          /*!< @brief An internally recognised data identifier to identify where the data is held. */
+    int data_id;		/*!< @brief An internally recognised data identifier to identify where the data is held. */
 } vsop_handle;
 
 /*! @brief A struct to hold rectangular coordinates from a particular
  *  calculation, including meta information about their calculation.
  */
 typedef struct {
-  vsop_handle vh;       /*!< @brief The VSOP handle representing the data these coordinates were calculated from. */
-  double jd;            /*!< @brief The Julian Date of these coordinates, in dynamical time.                      */
-  rec_coords rc;        /*!< @brief The XYZ coordinates.                                                          */
-  int is_inverted;      /*!< @brief Set to 1 if these coordinates are inverted (eg. for Solar coordinates), 0 otherwise. */
-  int error_state;      /*!< @brief The state of these coordinates,
-                                    indicating if they're okay to use.
-                                    Note that this field is only valid
-                                    once the struct values have been
-                                    calculated at least once.
+    vsop_handle vh;		/*!< @brief The VSOP handle representing the data these coordinates were calculated from. */
+    double jd;			/*!< @brief The Julian Date of these coordinates, in dynamical time.                      */
+    rec_coords rc;		/*!< @brief The XYZ coordinates.                                                          */
+    int is_inverted;		/*!< @brief Set to 1 if these coordinates are inverted (eg. for Solar coordinates), 0 otherwise. */
+    int error_state;		/*!< @brief The state of these coordinates,
+				   indicating if they're okay to use.
+				   Note that this field is only valid
+				   once the struct values have been
+				   calculated at least once.
 
-				    0 indicates no error.
-				    -1 (vsop_get_rectangular) indicates a vsop_handle error.  (Data referenced by this handle wasn't found - perhaps it was unloaded.)
-				    -2 (vsop_get_rectangular) indicates that a vsop_handle referenced data that wasn't rectangular, or otherwise not suitable for providing rectangular coordinates.
-				    -3 (vsop_rec_vsop_to_fk5) indicates that supplied coordinates were unsuitable for converting to FK5.
-			*/
+				   0 indicates no error.
+				   -1 (vsop_get_rectangular) indicates a vsop_handle error.  (Data referenced by this handle wasn't found - perhaps it was unloaded.)
+				   -2 (vsop_get_rectangular) indicates that a vsop_handle referenced data that wasn't rectangular, or otherwise not suitable for providing rectangular coordinates.
+				   -3 (vsop_rec_vsop_to_fk5) indicates that supplied coordinates were unsuitable for converting to FK5.
+				 */
 } vsop_rec_coords;
 
 /*! @brief Struct for holding spherical coordinates.
  */
 typedef struct {
-  double L;             /*!< @brief Heliocentric ecliptical longitude. */
-  double B;             /*!< @brief Heliocentric ecliptical latitude.  */
-  double R;             /*!< @brief The radius vector (distance to the Sun). */
+    double L;			/*!< @brief Heliocentric ecliptical longitude. */
+    double B;			/*!< @brief Heliocentric ecliptical latitude.  */
+    double R;			/*!< @brief The radius vector (distance to the Sun). */
 } sph_coords;
 
 /*! @brief A struct to hold spherical coordinates from a particular
  *  calculation, including meta information about their calculation.
  */
 typedef struct {
-  vsop_handle vh;       /*!< @brief The VSOP handle representing the data these coordinates were calculated from. */
-  double jd;            /*!< @brief The Julian Date of these coordinates, in dynamical time.                      */
-  sph_coords sc;        /*!< @brief The spherical coordinates.                                                   */
-  int is_inverted;      /*!< @brief Set to 1 if these coordinates are inverted (eg. for Solar coordinates), 0 otherwise. */
-  int error_state;      /*!< @brief The state of these coordinates,
-                                    indicating if they're okay to use.
-                                    Note that this field is only valid
-                                    once the struct values have been
-                                    calculated at least once.
+    vsop_handle vh;		/*!< @brief The VSOP handle representing the data these coordinates were calculated from. */
+    double jd;			/*!< @brief The Julian Date of these coordinates, in dynamical time.                      */
+    sph_coords sc;		/*!< @brief The spherical coordinates.                                                   */
+    int is_inverted;		/*!< @brief Set to 1 if these coordinates are inverted (eg. for Solar coordinates), 0 otherwise. */
+    int error_state;		/*!< @brief The state of these coordinates,
+				   indicating if they're okay to use.
+				   Note that this field is only valid
+				   once the struct values have been
+				   calculated at least once.
 
-				    0 indicates no error.
-				    -1 (vsop_get_spherical) indicates a vsop_handle error.  (Data referenced by this handle wasn't found - perhaps it was unloaded.)
-				    -2 (vsop_get_spherical) indicates that a vsop_handle referenced data that wasn't spherical, or otherwise not suitable for providing spherical coordinates.  (This should really only happen if the data in the struct has been corrupted somehow.)
-				    -3 (vsop_rec_vsop_to_fk5) indicates that supplied coordinates were unsuitable for converting to FK5.
-			*/
+				   0 indicates no error.
+				   -1 (vsop_get_spherical) indicates a vsop_handle error.  (Data referenced by this handle wasn't found - perhaps it was unloaded.)
+				   -2 (vsop_get_spherical) indicates that a vsop_handle referenced data that wasn't spherical, or otherwise not suitable for providing spherical coordinates.  (This should really only happen if the data in the struct has been corrupted somehow.)
+				   -3 (vsop_rec_vsop_to_fk5) indicates that supplied coordinates were unsuitable for converting to FK5.
+				 */
 } vsop_sph_coords;
 
 /* vsop_data_handling.c */
 void vsop_data_init();
 void vsop_data_cleanup();
-int get_vsop_data_handle(const vsop_body planet, const vsop_version version, vsop_handle *vh);
+int get_vsop_data_handle(const vsop_body planet,
+			 const vsop_version version, vsop_handle * vh);
 
 /* vsop_calculate.c */
-vsop_rec_coords vsop_get_rectangular(const vsop_handle vh, const double jd);
+vsop_rec_coords vsop_get_rectangular(const vsop_handle vh,
+				     const double jd);
 vsop_rec_coords vsop_rec_vsop_to_fk5(const vsop_rec_coords vrc);
 vsop_rec_coords vsop_rec_invert(const vsop_rec_coords vrc);
 vsop_sph_coords vsop_get_spherical(const vsop_handle vh, const double jd);

Modified: branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_internal.h
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_internal.h	2006-01-28 02:04:08 UTC (rev 226)
+++ branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_internal.h	2006-01-28 02:10:20 UTC (rev 227)
@@ -41,9 +41,9 @@
 
 /* Define data path -- this should be updated to something more elegantly configurable. */
 #ifdef VSOP_DATA_PATH
-  #define EPH_VSOP_DATA_PATH VSOP_DATA_PATH "/"
+#define EPH_VSOP_DATA_PATH VSOP_DATA_PATH "/"
 #else
-  #define EPH_VSOP_DATA_PATH ""
+#define EPH_VSOP_DATA_PATH ""
 #endif
 
 
@@ -77,17 +77,17 @@
 /*! @brief Represents a VSOP87 term.
  */
 typedef struct {
-  double A, B, C;
+    double A, B, C;
 } term_bin;
 
 
 typedef struct {
-  struct {
-    char alpha;          /*!< @brief The degree alpha of time variable for this series. */
-    short int num_terms; /*!< @brief The number of terms listed for this series. */
-  } meta;
+    struct {
+	char alpha;		/*!< @brief The degree alpha of time variable for this series. */
+	short int num_terms;	/*!< @brief The number of terms listed for this series. */
+    } meta;
 
-  term_bin *terms;     /*!< @brief The terms. */
+    term_bin *terms;		/*!< @brief The terms. */
 } series;
 
 
@@ -96,26 +96,26 @@
  *  particular body.
  */
 typedef struct {
-  struct{
-    char eph_header_text[23]; /*!< @brief Ephemeritis header text.                            */
-    char body_name[8];        /*!< @brief The name of the body represented by these elements. */
-    char num_variables;       /*!< @brief The number of variables included in these elements. */
-  } meta;
+    struct {
+	char eph_header_text[23];	/*!< @brief Ephemeritis header text.                            */
+	char body_name[8];	/*!< @brief The name of the body represented by these elements. */
+	char num_variables;	/*!< @brief The number of variables included in these elements. */
+    } meta;
 
-  struct {
     struct {
-      char series_count;   /*!< @brief The number of series' listed in the series_list field. */
-    } meta;                /*!< @brief Binary meta data about the VSOP variable.              */
+	struct {
+	    char series_count;	/*!< @brief The number of series' listed in the series_list field. */
+	} meta;			/*!< @brief Binary meta data about the VSOP variable.              */
 
-    series *series_list;   /*!< @brief The series list.                   */
-  } variable_list[6];      /*!< @brief The variables.                     */
+	series *series_list;	/*!< @brief The series list.                   */
+    } variable_list[6];		/*!< @brief The variables.                     */
 
 } body_elements;
 
 
 body_elements *ephint_get_body_elements_for_handle(const vsop_handle vh);
-void ephint_free_body_elements(body_elements *b);
-void ephint_write_body_elements(FILE *outfile, body_elements *b);
+void ephint_free_body_elements(body_elements * b);
+void ephint_write_body_elements(FILE * outfile, body_elements * b);
 /*
 void ephint_print_body_statistics(FILE *ostream, body_elements *b);
 body_elements *ephint_read_body_elements(FILE *infile);

Modified: branches/new-vsop-prepare/src/c/libephemeritis/equationoftime.c
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/equationoftime.c	2006-01-28 02:04:08 UTC (rev 226)
+++ branches/new-vsop-prepare/src/c/libephemeritis/equationoftime.c	2006-01-28 02:10:20 UTC (rev 227)
@@ -46,13 +46,12 @@
  */
 double equation_of_time(const double jd)
 {
-  double T = jd_to_jcent(jd) / 10.0;
-  /* (jd - 2451545.0) / 365250.0; */
-    double _terms[] =
-      {
+    double T = jd_to_jcent(jd) / 10.0;
+    /* (jd - 2451545.0) / 365250.0; */
+    double _terms[] = {
 	280.4664567, 360007.6982779, 0.03032028, 1.0 / 49931.0,
 	-1.0 / 15300.0, -1.0 / 2000000.0
-      };
+    };
     double L0 = modpi2(d_to_r(polynomial(_terms, 6, T)));
 
     /* Solar longitude, latitude and radius. */

Modified: branches/new-vsop-prepare/src/c/libephemeritis/nutation.c
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/nutation.c	2006-01-28 02:04:08 UTC (rev 226)
+++ branches/new-vsop-prepare/src/c/libephemeritis/nutation.c	2006-01-28 02:10:20 UTC (rev 227)
@@ -324,10 +324,13 @@
  *
  *  @author Mike McGavin.
  */
-void nut_in_ra_dec(double ra, double dec, double obl, double n_in_l, double n_in_o, double *n_in_ra, double *n_in_dec)
+void nut_in_ra_dec(double ra, double dec, double obl, double n_in_l,
+		   double n_in_o, double *n_in_ra, double *n_in_dec)
 {
-  *n_in_ra = (cos(obl) + (sin(obl) * sin(ra) * tan(dec))) * n_in_l - (cos(ra) * tan(dec) * n_in_o);
-  *n_in_dec = (sin(obl) * cos(ra) * n_in_l) + (sin(ra) * n_in_o);
+    *n_in_ra =
+	(cos(obl) + (sin(obl) * sin(ra) * tan(dec))) * n_in_l -
+	(cos(ra) * tan(dec) * n_in_o);
+    *n_in_dec = (sin(obl) * cos(ra) * n_in_l) + (sin(ra) * n_in_o);
 }
 
 

Modified: branches/new-vsop-prepare/src/c/libephemeritis/precession.c
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/precession.c	2006-01-28 02:04:08 UTC (rev 226)
+++ branches/new-vsop-prepare/src/c/libephemeritis/precession.c	2006-01-28 02:10:20 UTC (rev 227)
@@ -135,7 +135,7 @@
 	sin(pceq.theta_rad) * sin(decInitial);
     double C =
 	sin(pceq.theta_rad) * cos(decInitial) * cos(raInitial +
-						     pceq.zeta_rad) +
+						    pceq.zeta_rad) +
 	cos(pceq.theta_rad) * sin(decInitial);
 
     *raFinal = modpi2(atan2(A, B) + pceq.z_rad);

Modified: branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c	2006-01-28 02:04:08 UTC (rev 226)
+++ branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c	2006-01-28 02:10:20 UTC (rev 227)
@@ -57,45 +57,47 @@
  *
  *  @author Mike McGavin.
  */
-static double internal_vsop_dimension_calc(const body_elements *be, const int var_num, const double jd)
+static double internal_vsop_dimension_calc(const body_elements * be,
+					   const int var_num,
+					   const double jd)
 {
-  if(var_num < 0 || var_num > be->meta.num_variables-1) {
-    /* Oops, this variable doesn't exist. */
-    return 0;
-  }
+    if (var_num < 0 || var_num > be->meta.num_variables - 1) {
+	/* Oops, this variable doesn't exist. */
+	return 0;
+    }
 
-  /* Get a reference to the series's of this variable. */
-  int series_count = be->variable_list[var_num].meta.series_count;
-  series *series_list = be->variable_list[var_num].series_list;
+    /* Get a reference to the series's of this variable. */
+    int series_count = be->variable_list[var_num].meta.series_count;
+    series *series_list = be->variable_list[var_num].series_list;
 
-  /* Set tau to the Julian millenia. */
-  const double T = jd_to_jcent(jd) / 10.0;
+    /* Set tau to the Julian millenia. */
+    const double T = jd_to_jcent(jd) / 10.0;
 
-  double val = 0.0;
+    double val = 0.0;
 
-  int sn;
-  for(sn = 0; sn < series_count; sn++) {
-    double s_val = 0.0;
+    int sn;
+    for (sn = 0; sn < series_count; sn++) {
+	double s_val = 0.0;
 
-    /* Even though alphaoftime is always an integer, it's set it to a
-       double here to save having to re-convert it every time. */
-    double alphaoftime = (double)(series_list[sn].meta.alpha);
+	/* Even though alphaoftime is always an integer, it's set it to a
+	   double here to save having to re-convert it every time. */
+	double alphaoftime = (double) (series_list[sn].meta.alpha);
 
-    /* Loop through every term in the series. */
-    term_bin *t, *first_term, *last_term;
-    first_term = series_list[sn].terms;
-    last_term = first_term + (series_list[sn].meta.num_terms - 1);
+	/* Loop through every term in the series. */
+	term_bin *t, *first_term, *last_term;
+	first_term = series_list[sn].terms;
+	last_term = first_term + (series_list[sn].meta.num_terms - 1);
 
-    for(t = first_term; t <= last_term; t++) {
-      s_val += t->A * (cos(t->B + (t->C * T)));
+	for (t = first_term; t <= last_term; t++) {
+	    s_val += t->A * (cos(t->B + (t->C * T)));
+	}
+
+	/* Now add the result of the set of terms to the overall value for
+	   the variable, multiplying by T^alpha for the series. */
+	val += s_val * pow(T, alphaoftime);
     }
 
-    /* Now add the result of the set of terms to the overall value for
-       the variable, multiplying by T^alpha for the series. */
-    val += s_val * pow(T, alphaoftime);
-  }
-
-  return val;
+    return val;
 }
 
 
@@ -119,36 +121,38 @@
  */
 vsop_rec_coords vsop_get_rectangular(const vsop_handle vh, const double jd)
 {
-  vsop_rec_coords vrc;
+    vsop_rec_coords vrc;
 
-  /* Init the struct properties. */
-  memset(&vrc, '\0', sizeof(vrc));
-  vrc.vh = vh;
-  vrc.jd = jd;
-  vrc.is_inverted = 0;
+    /* Init the struct properties. */
+    memset(&vrc, '\0', sizeof(vrc));
+    vrc.vh = vh;
+    vrc.jd = jd;
+    vrc.is_inverted = 0;
 
-  /* Get a reference to the body_elements structure for this handle. */
-  body_elements *be;
-  if(NULL == (be = ephint_get_body_elements_for_handle(vh))) {
-    vrc.error_state = -1;
-    return vrc;
-  }
+    /* Get a reference to the body_elements structure for this handle. */
+    body_elements *be;
+    if (NULL == (be = ephint_get_body_elements_for_handle(vh))) {
+	vrc.error_state = -1;
+	return vrc;
+    }
 
-  /* Confirm that the body elements for the handle contain data with rectangular coordinates. */
-  if( ! (vh.version == hel_rec_j2 || vh.version == hel_rec_date || vh.version == bar_rec_j2) ) {
-    vrc.error_state = -2;
-    return vrc;
-  }
+    /* Confirm that the body elements for the handle contain data with rectangular coordinates. */
+    if (!
+	(vh.version == hel_rec_j2 || vh.version == hel_rec_date
+	 || vh.version == bar_rec_j2)) {
+	vrc.error_state = -2;
+	return vrc;
+    }
 
-  /* Now return X, Y and Z.                                 */
-  /* X, Y and Z come from varibles 0, 1 and 2 respectively. */
-  vrc.rc.x = internal_vsop_dimension_calc(be, 0, jd);
-  vrc.rc.y = internal_vsop_dimension_calc(be, 1, jd);
-  vrc.rc.z = internal_vsop_dimension_calc(be, 2, jd);
-  vrc.error_state = 0;
+    /* Now return X, Y and Z.                                 */
+    /* X, Y and Z come from varibles 0, 1 and 2 respectively. */
+    vrc.rc.x = internal_vsop_dimension_calc(be, 0, jd);
+    vrc.rc.y = internal_vsop_dimension_calc(be, 1, jd);
+    vrc.rc.z = internal_vsop_dimension_calc(be, 2, jd);
+    vrc.error_state = 0;
 
-  /* Return 0 for success. */
-  return vrc;
+    /* Return 0 for success. */
+    return vrc;
 }
 
 /*! @brief Rotate rectangular VSOP coordinates from the dynamical
@@ -173,26 +177,34 @@
  */
 vsop_rec_coords vsop_rec_vsop_to_fk5(const vsop_rec_coords vrc)
 {
-  /* Make a variable to return, and inialise it to the existing incoming values. */
-  vsop_rec_coords output = vrc;
+    /* Make a variable to return, and inialise it to the existing incoming values. */
+    vsop_rec_coords output = vrc;
 
-  /* Stop right here if the incoming coordinates are in an error state. */
-  if(output.error_state != 0) {
-    return output;
-  }
+    /* Stop right here if the incoming coordinates are in an error state. */
+    if (output.error_state != 0) {
+	return output;
+    }
 
-  /* Check that the incoming coordinates are of a version designed to be rotated. */
-  if(! (output.vh.version == hel_rec_j2 || output.vh.version == bar_rec_j2)) {
-    output.error_state = -3;
-    return output;
-  }
+    /* Check that the incoming coordinates are of a version designed to be rotated. */
+    if (!
+	(output.vh.version == hel_rec_j2
+	 || output.vh.version == bar_rec_j2)) {
+	output.error_state = -3;
+	return output;
+    }
 
-  output.rc.x = vrc.rc.x*1.000000000000  + vrc.rc.y*0.000000440360 + vrc.rc.z*-0.000000190919;
-  output.rc.y = vrc.rc.x*-0.000000479966 + vrc.rc.y*0.917482137087 + vrc.rc.z*-0.397776982902;
-  output.rc.z = vrc.rc.x*0.000000000000  + vrc.rc.y*0.397776982902 + vrc.rc.z*+0.917482137087;
-  output.error_state = 0;
+    output.rc.x =
+	vrc.rc.x * 1.000000000000 + vrc.rc.y * 0.000000440360 +
+	vrc.rc.z * -0.000000190919;
+    output.rc.y =
+	vrc.rc.x * -0.000000479966 + vrc.rc.y * 0.917482137087 +
+	vrc.rc.z * -0.397776982902;
+    output.rc.z =
+	vrc.rc.x * 0.000000000000 + vrc.rc.y * 0.397776982902 +
+	vrc.rc.z * +0.917482137087;
+    output.error_state = 0;
 
-  return output;
+    return output;
 }
 
 /*! @brief Given a set of rectangular VSOP coordinates, invert them.
@@ -211,18 +223,18 @@
  */
 vsop_rec_coords vsop_rec_invert(const vsop_rec_coords vrc)
 {
-  vsop_rec_coords output = vrc;
+    vsop_rec_coords output = vrc;
 
-  /* Stop right here if the incoming coordinates are in an error state. */
-  if(output.error_state != 0) {
+    /* Stop right here if the incoming coordinates are in an error state. */
+    if (output.error_state != 0) {
+	return output;
+    }
+
+    output.rc.x = -output.rc.x;
+    output.rc.y = -output.rc.y;
+    output.rc.z = -output.rc.z;
+    output.is_inverted = output.is_inverted ^ 0x01;
     return output;
-  }
-
-  output.rc.x = -output.rc.x;
-  output.rc.y = -output.rc.y;
-  output.rc.z = -output.rc.z;
-  output.is_inverted = output.is_inverted ^ 0x01;
-  return output;
 }
 
 
@@ -245,36 +257,36 @@
  */
 vsop_sph_coords vsop_get_spherical(const vsop_handle vh, const double jd)
 {
-  vsop_sph_coords vsc;
+    vsop_sph_coords vsc;
 
-  /* Init the struct properties. */
-  memset(&vsc, '\0', sizeof(vsc));
-  vsc.vh = vh;
-  vsc.jd = jd;
-  vsc.is_inverted = 0;
+    /* Init the struct properties. */
+    memset(&vsc, '\0', sizeof(vsc));
+    vsc.vh = vh;
+    vsc.jd = jd;
+    vsc.is_inverted = 0;
 
-  /* Get a reference to the body_elements structure for this handle. */
-  body_elements *be;
-  if(NULL == (be = ephint_get_body_elements_for_handle(vh))) {
-    vsc.error_state = -1;
-    return vsc;
-  }
+    /* Get a reference to the body_elements structure for this handle. */
+    body_elements *be;
+    if (NULL == (be = ephint_get_body_elements_for_handle(vh))) {
+	vsc.error_state = -1;
+	return vsc;
+    }
 
-  /* Confirm that the body elements for the handle contain data with spherical coordinates. */
-  if( ! (vh.version == hel_sph_j2 || vh.version == hel_sph_date) ) {
-    vsc.error_state = -2;
-    return vsc;
-  }
+    /* Confirm that the body elements for the handle contain data with spherical coordinates. */
+    if (!(vh.version == hel_sph_j2 || vh.version == hel_sph_date)) {
+	vsc.error_state = -2;
+	return vsc;
+    }
 
-  /* Now return L, B and R.                                 */
-  /* L, B and R come from varibles 0, 1 and 2 respectively. */
-  vsc.sc.L = modpi2(internal_vsop_dimension_calc(be, 0, jd));
-  vsc.sc.B = internal_vsop_dimension_calc(be, 1, jd);
-  vsc.sc.R = internal_vsop_dimension_calc(be, 2, jd);
+    /* Now return L, B and R.                                 */
+    /* L, B and R come from varibles 0, 1 and 2 respectively. */
+    vsc.sc.L = modpi2(internal_vsop_dimension_calc(be, 0, jd));
+    vsc.sc.B = internal_vsop_dimension_calc(be, 1, jd);
+    vsc.sc.R = internal_vsop_dimension_calc(be, 2, jd);
 
-  /* Return 0 for success. */
-  vsc.error_state = 0;
-  return vsc;
+    /* Return 0 for success. */
+    vsc.error_state = 0;
+    return vsc;
 }
 
 
@@ -304,44 +316,47 @@
  *
  *  @author Mike McGavin.
  */
-vsop_sph_coords vsop_sph_vsop_to_fk5(const vsop_sph_coords vsc) {
-  /* Make a variable to return, and inialise it to the existing incoming values. */
-  vsop_sph_coords output = vsc;
+vsop_sph_coords vsop_sph_vsop_to_fk5(const vsop_sph_coords vsc)
+{
+    /* Make a variable to return, and inialise it to the existing incoming values. */
+    vsop_sph_coords output = vsc;
 
-  /* Stop right here if the incoming coordinates are in an error state. */
-  if(output.error_state != 0) {
-    return output;
-  }
+    /* Stop right here if the incoming coordinates are in an error state. */
+    if (output.error_state != 0) {
+	return output;
+    }
 
-  /* Check that the incoming coordinates are spherical. */
-  if(! (output.vh.version == hel_sph_j2 || output.vh.version == hel_sph_date)) {
-    output.error_state = -3;
-    return output;
-  }
+    /* Check that the incoming coordinates are spherical. */
+    if (!
+	(output.vh.version == hel_sph_j2
+	 || output.vh.version == hel_sph_date)) {
+	output.error_state = -3;
+	return output;
+    }
 
-  static double l1, l2;
-  static double terms[3];
-  static bool static_set = false;
-  if(!static_set) {
-    static_set = true;
-    l1 = -d_to_r(dms_to_d(0,0,0.09033));
-    l2 =  d_to_r(dms_to_d(0,0,0.03916));
-    terms[0] = 0.0;
-    terms[1] = d_to_r(1.397);
-    terms[2] = d_to_r(0.00031);
-  }
+    static double l1, l2;
+    static double terms[3];
+    static bool static_set = false;
+    if (!static_set) {
+	static_set = true;
+	l1 = -d_to_r(dms_to_d(0, 0, 0.09033));
+	l2 = d_to_r(dms_to_d(0, 0, 0.03916));
+	terms[0] = 0.0;
+	terms[1] = d_to_r(1.397);
+	terms[2] = d_to_r(0.00031);
+    }
 
-  double T = jd_to_jcent(vsc.jd) / 10.0;
-  double L1 = vsc.sc.L - polynomial(terms, 3, T);
-  double cosL1 = cos(L1);
-  double sinL1 = sin(L1);
+    double T = jd_to_jcent(vsc.jd) / 10.0;
+    double L1 = vsc.sc.L - polynomial(terms, 3, T);
+    double cosL1 = cos(L1);
+    double sinL1 = sin(L1);
 
-  double deltaL = l1 + (l2 * (cosL1 + sinL1) * tan(vsc.sc.B));
-  double deltaB = l2 * (cosL1 - sinL1);
+    double deltaL = l1 + (l2 * (cosL1 + sinL1) * tan(vsc.sc.B));
+    double deltaB = l2 * (cosL1 - sinL1);
 
-  output.sc.L += deltaL;
-  output.sc.B += deltaB;
-  return output;
+    output.sc.L += deltaL;
+    output.sc.B += deltaB;
+    return output;
 }
 
 /*! @brief Given a set of spherical VSOP coordinates, invert them.
@@ -360,15 +375,15 @@
  */
 vsop_sph_coords vsop_sph_invert(const vsop_sph_coords vsc)
 {
-  vsop_sph_coords output = vsc;
+    vsop_sph_coords output = vsc;
 
-  /* Stop right here if the incoming coordinates are in an error state. */
-  if(output.error_state != 0) {
+    /* Stop right here if the incoming coordinates are in an error state. */
+    if (output.error_state != 0) {
+	return output;
+    }
+
+    output.sc.L = modpi2(output.sc.L + pi);
+    output.sc.B = -output.sc.B;
+    output.is_inverted = output.is_inverted ^ 0x01;
     return output;
-  }
-
-  output.sc.L = modpi2(output.sc.L + pi);
-  output.sc.B = -output.sc.B;
-  output.is_inverted = output.is_inverted ^ 0x01;
-  return output;
 }

Modified: branches/new-vsop-prepare/src/c/libephemeritis/vsop_data_handling.c
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/vsop_data_handling.c	2006-01-28 02:04:08 UTC (rev 226)
+++ branches/new-vsop-prepare/src/c/libephemeritis/vsop_data_handling.c	2006-01-28 02:10:20 UTC (rev 227)
@@ -39,9 +39,9 @@
  */
 static void destroy_series(series s)
 {
-  if(NULL != s.terms) {
-    free(s.terms);
-  }
+    if (NULL != s.terms) {
+	free(s.terms);
+    }
 }
 
 /*! @brief De-allocates the space that was allocated for a
@@ -57,30 +57,30 @@
  *  if the various allocated structures were zero'd before assigning
  *  data and other pointers to them.
  */
-void ephint_free_body_elements(body_elements *b)
+void ephint_free_body_elements(body_elements * b)
 {
-  if(NULL == b) {
-    /* Ignore, because it's null. */
-    return;
-  }
+    if (NULL == b) {
+	/* Ignore, because it's null. */
+	return;
+    }
 
-  int n;
-  for(n = 0; n < b->meta.num_variables; n++) {
-    /* Make sure the series_list was successfully allocated before
-       trying to dig into each of its series' collections. */
-    if(NULL != b->variable_list[n].series_list) {
-      int o;
-      for(o = 0; o < b->variable_list[n].meta.series_count; o++) {
-	/* Destroy each series. */
- 	destroy_series(b->variable_list[n].series_list[o]);
-      }
+    int n;
+    for (n = 0; n < b->meta.num_variables; n++) {
+	/* Make sure the series_list was successfully allocated before
+	   trying to dig into each of its series' collections. */
+	if (NULL != b->variable_list[n].series_list) {
+	    int o;
+	    for (o = 0; o < b->variable_list[n].meta.series_count; o++) {
+		/* Destroy each series. */
+		destroy_series(b->variable_list[n].series_list[o]);
+	    }
+	}
+
+	/* Free the list of series for the variable. */
+	free(b->variable_list[n].series_list);
     }
 
-    /* Free the list of series for the variable. */
-    free(b->variable_list[n].series_list);
-  }
-  
-  free(b);
+    free(b);
 }
 
 /*! @brief Prints details about the body elements in a human readable
@@ -89,22 +89,26 @@
  *  @param[in] ostream A stream pointer to which the text should be printed.  (eg. stdin, stderr, or an open file.)
  *  @param[in] b       Pointer to the body elements.
  */
-void ephint_print_body_statistics(FILE *ostream, body_elements *b)
+void ephint_print_body_statistics(FILE * ostream, body_elements * b)
 {
-  fprintf(ostream, "Ephemeritis Version String: %s.\n", b->meta.eph_header_text);
-  fprintf(ostream, "Data for \"%s\".\n", b->meta.body_name);
-  fprintf(ostream, "%d variables overall.\n", b->meta.num_variables);
+    fprintf(ostream, "Ephemeritis Version String: %s.\n",
+	    b->meta.eph_header_text);
+    fprintf(ostream, "Data for \"%s\".\n", b->meta.body_name);
+    fprintf(ostream, "%d variables overall.\n", b->meta.num_variables);
 
-  int v;
-  for(v=0; v<b->meta.num_variables; v++) {
-    fprintf(ostream, "\nVariable %d contains %d series':\n\n", v, b->variable_list[v].meta.series_count);
+    int v;
+    for (v = 0; v < b->meta.num_variables; v++) {
+	fprintf(ostream, "\nVariable %d contains %d series':\n\n", v,
+		b->variable_list[v].meta.series_count);
 
-    int s;
-    for(s=0; s<b->variable_list[v].meta.series_count; s++) {
-      series *ser = &(b->variable_list[v].series_list[s]);
-      fprintf(ostream, "  Series %d has alpha %d and contains %d terms.\n", s, ser->meta.alpha, (ser->meta.num_terms));
+	int s;
+	for (s = 0; s < b->variable_list[v].meta.series_count; s++) {
+	    series *ser = &(b->variable_list[v].series_list[s]);
+	    fprintf(ostream,
+		    "  Series %d has alpha %d and contains %d terms.\n", s,
+		    ser->meta.alpha, (ser->meta.num_terms));
+	}
     }
-  }
 }
 
 /*! @brief Given an open output file and a body_elements structure,
@@ -113,26 +117,28 @@
  *  @param[in] outfile An open file to which the data should be written. The file is not closed after the operation.
  *  @param[in] b       Pointer to the body elements.
  */
-void ephint_write_body_elements(FILE *outfile, body_elements *b)
+void ephint_write_body_elements(FILE * outfile, body_elements * b)
 {
-  /* Write the header data. */
-  fwrite(&b->meta, sizeof(b->meta), 1, outfile);
+    /* Write the header data. */
+    fwrite(&b->meta, sizeof(b->meta), 1, outfile);
 
-  /* Loop through the variables, writing data of each one. */
-  int v;
-  for(v = 0; v < b->meta.num_variables; v++) {
-    fwrite(&b->variable_list[v].meta, sizeof(b->variable_list[v].meta), 1, outfile);
+    /* Loop through the variables, writing data of each one. */
+    int v;
+    for (v = 0; v < b->meta.num_variables; v++) {
+	fwrite(&b->variable_list[v].meta, sizeof(b->variable_list[v].meta),
+	       1, outfile);
 
-    /* Loop through the series variables, writing data of each one. */
-    int s;
-    for(s = 0; s < b->variable_list[v].meta.series_count; s++) {
-      series *ser = &b->variable_list[v].series_list[s];
-      fwrite(&ser->meta, sizeof(ser->meta), 1, outfile);
+	/* Loop through the series variables, writing data of each one. */
+	int s;
+	for (s = 0; s < b->variable_list[v].meta.series_count; s++) {
+	    series *ser = &b->variable_list[v].series_list[s];
+	    fwrite(&ser->meta, sizeof(ser->meta), 1, outfile);
 
-      /* Write the list of terms. */
-      fwrite(ser->terms, sizeof(*(ser->terms)), ser->meta.num_terms, outfile);
+	    /* Write the list of terms. */
+	    fwrite(ser->terms, sizeof(*(ser->terms)), ser->meta.num_terms,
+		   outfile);
+	}
     }
-  }
 }
 
 
@@ -158,93 +164,103 @@
  *          as corrupted data), all the bits and pieces allocated up
  *          to that point will be released, an NULL is returned.
  */
-static body_elements *ephint_read_body_elements(FILE *infile, int *error_ret)
+static body_elements *ephint_read_body_elements(FILE * infile,
+						int *error_ret)
 {
-  /* Note -- there's a goto label at the end of the function to
-     collect any memory allocation problems.  (Traditionally yucky,
-     but I think it's slightly clearer in this case.)  It'll
-     deallocate whatever's been created so far, and return NULL. */
+    /* Note -- there's a goto label at the end of the function to
+       collect any memory allocation problems.  (Traditionally yucky,
+       but I think it's slightly clearer in this case.)  It'll
+       deallocate whatever's been created so far, and return NULL. */
 
-  body_elements *b = NULL;
-  size_t numread = 0;
-  *error_ret = 0;
+    body_elements *b = NULL;
+    size_t numread = 0;
+    *error_ret = 0;
 
-  /* Allocate memory for the body_elements. */
-  b = (body_elements *)malloc(sizeof(body_elements));
-  if(NULL == b) {
-    /* Oops, there wasn't enough memory. */
-    goto mem_screwup;
-  }
-  /* Fill it with 0's, to make it safer to clean up if things fail later. */
-  memset(b, '\0', sizeof(*b));
+    /* Allocate memory for the body_elements. */
+    b = (body_elements *) malloc(sizeof(body_elements));
+    if (NULL == b) {
+	/* Oops, there wasn't enough memory. */
+	goto mem_screwup;
+    }
+    /* Fill it with 0's, to make it safer to clean up if things fail later. */
+    memset(b, '\0', sizeof(*b));
 
 
-  /* Read the header data. */
-  numread = fread(&b->meta, sizeof(b->meta), 1, infile);
-  if(1 != numread) {
-    goto file_screwup;
-  }
-
-  /* Loop through the variables, reading data for each one. */
-  int v;
-  for(v = 0; v < b->meta.num_variables; v++) {
-    numread = fread(&b->variable_list[v].meta, sizeof(b->variable_list[v].meta), 1, infile);
-    if(1 != numread) {
-      goto file_screwup;
+    /* Read the header data. */
+    numread = fread(&b->meta, sizeof(b->meta), 1, infile);
+    if (1 != numread) {
+	goto file_screwup;
     }
 
-    /* Allocate memory to hold the list of series' for this variable. */
-    b->variable_list[v].series_list = (series *)calloc(b->variable_list[v].meta.series_count, sizeof(series));
-    if(NULL == b->variable_list[v].series_list) {
-      /* Oops, there wasn't enough memory. */
-      goto mem_screwup;
-    }
-    /* Fill it with 0's, to make it safer to clean up if things fail later. */
-    /* Note that calloc() sets memory to 0 anyway (but malloc()
-       doesn't!), so the following line is more of a safety thing. */
-    memset(b->variable_list[v].series_list, '\0', b->variable_list[v].meta.series_count * sizeof(series));
- 
-    /* Loop through the series variables, reading data from each one. */
-    int s;
-    for(s = 0; s < b->variable_list[v].meta.series_count; s++) {
-      /* Read meta data for this series. */
-      series *ser = &b->variable_list[v].series_list[s];
-      numread = fread(&ser->meta, sizeof(ser->meta), 1, infile);
-      if(1 != numread) {
-	goto file_screwup;
-      }
+    /* Loop through the variables, reading data for each one. */
+    int v;
+    for (v = 0; v < b->meta.num_variables; v++) {
+	numread =
+	    fread(&b->variable_list[v].meta,
+		  sizeof(b->variable_list[v].meta), 1, infile);
+	if (1 != numread) {
+	    goto file_screwup;
+	}
 
-      /* Allocate memory for the terms. */
-      ser->terms = (term_bin *)calloc(ser->meta.num_terms, sizeof(term_bin));
-      if(NULL == ser->terms) {
-	/* Oops, there wasn't enough memory. */
-	goto mem_screwup;
-      }
-      /* Set the memory to 0's.  (Safety thing again, as above.) */
-      memset(ser->terms, '\0', ser->meta.num_terms * sizeof(term_bin));
+	/* Allocate memory to hold the list of series' for this variable. */
+	b->variable_list[v].series_list =
+	    (series *) calloc(b->variable_list[v].meta.series_count,
+			      sizeof(series));
+	if (NULL == b->variable_list[v].series_list) {
+	    /* Oops, there wasn't enough memory. */
+	    goto mem_screwup;
+	}
+	/* Fill it with 0's, to make it safer to clean up if things fail later. */
+	/* Note that calloc() sets memory to 0 anyway (but malloc()
+	   doesn't!), so the following line is more of a safety thing. */
+	memset(b->variable_list[v].series_list, '\0',
+	       b->variable_list[v].meta.series_count * sizeof(series));
 
-      /* Read the list of terms. */
-      numread = fread(ser->terms, sizeof(*(ser->terms)), ser->meta.num_terms, infile);
-      if(ser->meta.num_terms != numread) {
-	goto file_screwup;
-      }
+	/* Loop through the series variables, reading data from each one. */
+	int s;
+	for (s = 0; s < b->variable_list[v].meta.series_count; s++) {
+	    /* Read meta data for this series. */
+	    series *ser = &b->variable_list[v].series_list[s];
+	    numread = fread(&ser->meta, sizeof(ser->meta), 1, infile);
+	    if (1 != numread) {
+		goto file_screwup;
+	    }
+
+	    /* Allocate memory for the terms. */
+	    ser->terms =
+		(term_bin *) calloc(ser->meta.num_terms, sizeof(term_bin));
+	    if (NULL == ser->terms) {
+		/* Oops, there wasn't enough memory. */
+		goto mem_screwup;
+	    }
+	    /* Set the memory to 0's.  (Safety thing again, as above.) */
+	    memset(ser->terms, '\0',
+		   ser->meta.num_terms * sizeof(term_bin));
+
+	    /* Read the list of terms. */
+	    numread =
+		fread(ser->terms, sizeof(*(ser->terms)),
+		      ser->meta.num_terms, infile);
+	    if (ser->meta.num_terms != numread) {
+		goto file_screwup;
+	    }
+	}
     }
-  }
 
-  return b;
+    return b;
 
-  /* If things fail, we'll end up somewhere near here. */
- mem_screwup:
-  *error_ret = errno;
-  goto mem_cleanup;
+    /* If things fail, we'll end up somewhere near here. */
+  mem_screwup:
+    *error_ret = errno;
+    goto mem_cleanup;
 
- file_screwup:
-  *error_ret = EIO;
-  goto mem_cleanup;
+  file_screwup:
+    *error_ret = EIO;
+    goto mem_cleanup;
 
- mem_cleanup:
-  ephint_free_body_elements(b);
-  return NULL;
+  mem_cleanup:
+    ephint_free_body_elements(b);
+    return NULL;
 }
 
 
@@ -254,8 +270,8 @@
 /*! @brief Internal struct to hold id data about a vsop_handle.
  */
 typedef struct {
-  vsop_handle h;
-  body_elements *be;
+    vsop_handle h;
+    body_elements *be;
 } vsop_handle_wrapper;
 
 static vsop_handle_wrapper *vhw_list = NULL;
@@ -270,8 +286,8 @@
  */
 void vsop_data_init()
 {
-  vhw_list = NULL;
-  vhw_list_size = 0;
+    vhw_list = NULL;
+    vhw_list_size = 0;
 }
 
 /*! @brief Cleans up the VSOP data handling functionality.  This
@@ -282,12 +298,12 @@
  */
 void vsop_data_cleanup()
 {
-  /* Loop through every loaded data set, and release it. */
+    /* Loop through every loaded data set, and release it. */
 
-  /* Release the list, and re-initialise the meta variables. */
-  free(vhw_list);
-  vhw_list = NULL;
-  vhw_list_size = 0;
+    /* Release the list, and re-initialise the meta variables. */
+    free(vhw_list);
+    vhw_list = NULL;
+    vhw_list_size = 0;
 }
 
 
@@ -301,137 +317,144 @@
  *
  *  @return true if the data was loaded and returned, otherwise false.
  */
-static bool get_vsop_handle(const vsop_body planet, const vsop_version version, vsop_handle *h)
+static bool get_vsop_handle(const vsop_body planet,
+			    const vsop_version version, vsop_handle * h)
 {
-  int n;
-  for(n = 0; n < vhw_list_size; n++) {
-    if(planet == vhw_list[n].h.planet && version == vhw_list[n].h.version) {
-      *h = vhw_list[n].h;
-      return true;
+    int n;
+    for (n = 0; n < vhw_list_size; n++) {
+	if (planet == vhw_list[n].h.planet
+	    && version == vhw_list[n].h.version) {
+	    *h = vhw_list[n].h;
+	    return true;
+	}
     }
-  }
-  return false;
+    return false;
 }
 
 
 typedef struct {
-  vsop_version v;
-  char *str;
+    vsop_version v;
+    char *str;
 } version_str_map_type;
 
 
 typedef struct {
-  vsop_body p;
-  char *str;
+    vsop_body p;
+    char *str;
 } body_str_map_type;
 
 static version_str_map_type version_str_map[] = {
-  {hel_ell_j2,   EPH_VSOP_HEJ2},
-  {hel_rec_j2,   EPH_VSOP_HRJ2},
-  {hel_sph_j2,   EPH_VSOP_HSJ2},
-  {hel_rec_date, EPH_VSOP_HRD },
-  {hel_sph_date, EPH_VSOP_HSD },
-  {bar_rec_j2,   EPH_VSOP_BRJ2}
+    {hel_ell_j2, EPH_VSOP_HEJ2},
+    {hel_rec_j2, EPH_VSOP_HRJ2},
+    {hel_sph_j2, EPH_VSOP_HSJ2},
+    {hel_rec_date, EPH_VSOP_HRD},
+    {hel_sph_date, EPH_VSOP_HSD},
+    {bar_rec_j2, EPH_VSOP_BRJ2}
 };
 
 static char *version_map_lookup(vsop_version v)
 {
-  int n;
-  for(n = 0; n < sizeof(version_str_map) / sizeof(*version_str_map); n++) {
-    if(v == version_str_map[n].v) {
-      return version_str_map[n].str;
+    int n;
+    for (n = 0; n < sizeof(version_str_map) / sizeof(*version_str_map);
+	 n++) {
+	if (v == version_str_map[n].v) {
+	    return version_str_map[n].str;
+	}
     }
-  }
-  return NULL;
+    return NULL;
 }
 
 static body_str_map_type body_str_map[] = {
-  {vsop_mercury, EPH_MER},
-  {vsop_venus,   EPH_VEN},
-  {vsop_earth,   EPH_EAR},
-  {vsop_mars,    EPH_MAR},
-  {vsop_jupiter, EPH_JUP},
-  {vsop_saturn,  EPH_SAT},
-  {vsop_uranus,  EPH_URA},
-  {vsop_neptune, EPH_NEP},
-  {vsop_sun,     EPH_SOL},
-  {vsop_EMB,     EPH_EMB}
+    {vsop_mercury, EPH_MER},
+    {vsop_venus, EPH_VEN},
+    {vsop_earth, EPH_EAR},
+    {vsop_mars, EPH_MAR},
+    {vsop_jupiter, EPH_JUP},
+    {vsop_saturn, EPH_SAT},
+    {vsop_uranus, EPH_URA},
+    {vsop_neptune, EPH_NEP},
+    {vsop_sun, EPH_SOL},
+    {vsop_EMB, EPH_EMB}
 };
 
 static char *planet_map_lookup(vsop_body p)
 {
-  int n;
-  for(n = 0; n < sizeof(body_str_map) / sizeof(*body_str_map); n++) {
-    if(p == body_str_map[n].p) {
-      return body_str_map[n].str;
+    int n;
+    for (n = 0; n < sizeof(body_str_map) / sizeof(*body_str_map); n++) {
+	if (p == body_str_map[n].p) {
+	    return body_str_map[n].str;
+	}
     }
-  }
-  return NULL;
+    return NULL;
 }
 
 /* Assumes that the handle isn't already loaded, and that the data in
    the file isn't corrupt, so use with care. */
-static int load_vsop_handle(const vsop_body planet, const vsop_version version, vsop_handle *vh)
+static int load_vsop_handle(const vsop_body planet,
+			    const vsop_version version, vsop_handle * vh)
 {
-  /* Construct the filename. */
-  char filename[512];
-  strncpy(filename, EPH_VSOP_DATA_PATH, 512);
-  strncat(filename, EPH_VSOP_PREFIX, 512);
-  strncat(filename, version_map_lookup(version), 512);
-  strncat(filename, ".", 512);
-  strncat(filename, planet_map_lookup(planet), 512);
-  strncat(filename, EPH_VSOP_SUFFIX, 512);
-  filename[511] = '\0';
+    /* Construct the filename. */
+    char filename[512];
+    strncpy(filename, EPH_VSOP_DATA_PATH, 512);
+    strncat(filename, EPH_VSOP_PREFIX, 512);
+    strncat(filename, version_map_lookup(version), 512);
+    strncat(filename, ".", 512);
+    strncat(filename, planet_map_lookup(planet), 512);
+    strncat(filename, EPH_VSOP_SUFFIX, 512);
+    filename[511] = '\0';
 
-  /* Try to open the file. */
-  FILE *f;
-  errno = 0;
-  if(NULL == (f = fopen(filename, "rb"))) {
-    /* File didn't open for some reason.  Probably not there. */
-    return errno;
-  }
+    /* Try to open the file. */
+    FILE *f;
+    errno = 0;
+    if (NULL == (f = fopen(filename, "rb"))) {
+	/* File didn't open for some reason.  Probably not there. */
+	return errno;
+    }
 
-  /* Attempt to read data from the file. */
-  int error_ret;
-  body_elements *be = ephint_read_body_elements(f, &error_ret);
-  if(NULL == be) {
-    /* Oops, there was some problem loading data from the file.
-       error_ret should have been set to either a malloc or calloc
-       error, or to EIO. */
-    return error_ret;
-  }
+    /* Attempt to read data from the file. */
+    int error_ret;
+    body_elements *be = ephint_read_body_elements(f, &error_ret);
+    if (NULL == be) {
+	/* Oops, there was some problem loading data from the file.
+	   error_ret should have been set to either a malloc or calloc
+	   error, or to EIO. */
+	return error_ret;
+    }
 
-  /* Close the file. */
-  errno = 0;
-  if(0 != fclose(f)) {
-    return errno;
-  }
-  
-  /* Allocate more space in the list of vsop handle wrappers. */
-  vsop_handle_wrapper *realloc_result;
-  realloc_result = (vsop_handle_wrapper *)realloc(vhw_list, ++vhw_list_size * sizeof(vsop_handle_wrapper));
+    /* Close the file. */
+    errno = 0;
+    if (0 != fclose(f)) {
+	return errno;
+    }
 
-  /* Check to make sure that realloc() found more memory successfully. */
-  if(NULL == realloc_result) {
-    /* Oops, not enough memory, or some other error. */
+    /* Allocate more space in the list of vsop handle wrappers. */
+    vsop_handle_wrapper *realloc_result;
+    realloc_result =
+	(vsop_handle_wrapper *) realloc(vhw_list,
+					++vhw_list_size *
+					sizeof(vsop_handle_wrapper));
 
-    /* Free up those elements that were just read, since there's nowhere to put them. */
-    ephint_free_body_elements(be);
+    /* Check to make sure that realloc() found more memory successfully. */
+    if (NULL == realloc_result) {
+	/* Oops, not enough memory, or some other error. */
 
-    /* Return the error value. */
-    return errno;
-  } else {
-    /* Memory was re-allocated fine, so assign the list's address to wherever it's been placed. */
-    vhw_list = realloc_result;
-  }
+	/* Free up those elements that were just read, since there's nowhere to put them. */
+	ephint_free_body_elements(be);
 
-  vhw_list[vhw_list_size-1].be = be;
-  vhw_list[vhw_list_size-1].h.data_id = next_data_id++;
-  vhw_list[vhw_list_size-1].h.planet = planet;
-  vhw_list[vhw_list_size-1].h.version = version;
+	/* Return the error value. */
+	return errno;
+    } else {
+	/* Memory was re-allocated fine, so assign the list's address to wherever it's been placed. */
+	vhw_list = realloc_result;
+    }
 
-  *vh = vhw_list[vhw_list_size-1].h;
-  return 0;
+    vhw_list[vhw_list_size - 1].be = be;
+    vhw_list[vhw_list_size - 1].h.data_id = next_data_id++;
+    vhw_list[vhw_list_size - 1].h.planet = planet;
+    vhw_list[vhw_list_size - 1].h.version = version;
+
+    *vh = vhw_list[vhw_list_size - 1].h;
+    return 0;
 }
 
 /*! @brief Returns a handle for accessing available VSOP data.
@@ -457,16 +480,17 @@
  *  fclose(), realloc(), malloc() or calloc() is usually returned.
  *  EIO is returned if there was a problem loading some file data.
  */
-int get_vsop_data_handle(const vsop_body planet, const vsop_version version, vsop_handle *vh)
+int get_vsop_data_handle(const vsop_body planet,
+			 const vsop_version version, vsop_handle * vh)
 {
-  /* Check to see if the data for this planet/series is already loaded. */
-  if(get_vsop_handle(planet, version, vh)) {
-    /* If so, return the handle.       */
-    return 0;
-  } else {
-    /* If not, load it, then return it. */
-    return load_vsop_handle(planet, version, vh);
-  }
+    /* Check to see if the data for this planet/series is already loaded. */
+    if (get_vsop_handle(planet, version, vh)) {
+	/* If so, return the handle.       */
+	return 0;
+    } else {
+	/* If not, load it, then return it. */
+	return load_vsop_handle(planet, version, vh);
+    }
 }
 
 /*! @brief Maps a specified vsop_handle to the loaded body elements that it represents.
@@ -484,14 +508,14 @@
  */
 body_elements *ephint_get_body_elements_for_handle(const vsop_handle vh)
 {
-  int n;
-  for(n = 0; n < vhw_list_size; n++) {
-    if(vh.data_id == vhw_list[n].h.data_id) {
-      /* Found the handle, so return its associated body_elements structure. */
-      return vhw_list[n].be;
+    int n;
+    for (n = 0; n < vhw_list_size; n++) {
+	if (vh.data_id == vhw_list[n].h.data_id) {
+	    /* Found the handle, so return its associated body_elements structure. */
+	    return vhw_list[n].be;
+	}
     }
-  }
 
-  /* The handle wasn't found in the list of loaded data, so return NULL. */
-  return NULL;
+    /* The handle wasn't found in the list of loaded data, so return NULL. */
+    return NULL;
 }



From izogi at berlios.de  Sat Jan 28 05:06:35 2006
From: izogi at berlios.de (izogi at BerliOS)
Date: Sat, 28 Jan 2006 05:06:35 +0100
Subject: [Ephemeritis-svn] r229 - branches/new-vsop-prepare/src/c/libephemeritis
Message-ID: <200601280406.k0S46Zn5026470@sheep.berlios.de>

Author: izogi
Date: 2006-01-28 05:06:31 +0100 (Sat, 28 Jan 2006)
New Revision: 229

Modified:
   branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis.h
   branches/new-vsop-prepare/src/c/libephemeritis/solar.c
   branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c
Log:
Began experimenting with an API for calculation of solar coordinates using the new vsop system.
Added a doc note about the difference between J2000 and equinox of the date.


Modified: branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis.h
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis.h	2006-01-28 02:12:11 UTC (rev 228)
+++ branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis.h	2006-01-28 04:06:31 UTC (rev 229)
@@ -458,6 +458,12 @@
 } vsop_body;
 
 /*! @brief A list of versions available for the VSOP model.
+ *
+ *  @note Variables of date take into account precession since J2000,
+ *  but do not take into account other periodic effects such as
+ *  nutation.  Therefore, if using variables of the date to calculate
+ *  planetary positions and what-not, take care not to apply a
+ *  correction for precession twice.
  */
 typedef enum {
     hel_ell_j2,			/*!< @brief Heliocentric Elliptic Elements J2000       */

Modified: branches/new-vsop-prepare/src/c/libephemeritis/solar.c
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/solar.c	2006-01-28 02:12:11 UTC (rev 228)
+++ branches/new-vsop-prepare/src/c/libephemeritis/solar.c	2006-01-28 04:06:31 UTC (rev 229)
@@ -38,79 +38,7 @@
 
 #include <math.h>
 
-/*! @brief Returns one of geocentric ecliptic longitude,
- *  latitude and radius as VSOP coordinates.
- *
- *  @param[in]  jd        Julian Day in dynamical time.
- *  @param[in] dim        A value to indicate whether longitude,
- *                        latitude or radius should be returned.
- *
- *  @return               Either longitude or latitude (in radians), or
- *                        radius (in astronomical units).
- *
- *  @sa dynamical::deltaT_seconds for calculating %dynamical time offset.
- *
- *  @warning This function returns the coordinates in the vsop frame
- *  of reference, which is very slightly different from fk5.  To
- *  convert the longitude and latitude to fk5 coordinates, use
- *  vsop_to_fk5.  Alternatively, call sol_dimension3_fk5.
- */
-double sol_dimension_vsop(double jd, enum Coords dim)
-{
-    double X = vsop_dimension_vsop(jd, vEarth, dim);
-    if (dim == vL) {
-	X = modpi2(X + pi);
-    } else if (dim == vB) {
-	X = -X;
-    }
-    return X;
-}
 
-/*! @brief Returns geocentric ecliptic longitude, latitude and radius
- *  as VSOP coordinates.
- *
- *  The code in this function very simply calls sol_dimension for each
- *  value, so it is no more efficient to call this.  It's provided for
- *  convenience only.
- *
- *  @param[in]  jd  Julian Day in dynamical time.
- *  @param[out] L   Longitude, in radians.
- *  @param[out] B   Latitude, in radians.
- *  @param[out] R   Radius, in astronomical units.
- *
- *  @sa dynamical::deltaT_seconds for calculating %dynamical time offset.
- *
- *  @warning This function returns the coordinates in the vsop frame
- *  of reference, which is very slightly different from fk5.  To
- *  convert the longitude and latitude to fk5 coordinates, use
- *  vsop_to_fk5.  Alternatively, call sol_dimension3_fk5.
- */
-void sol_dimension3_vsop(double jd, double *L, double *B, double *R)
-{
-    *L = sol_dimension_vsop(jd, vL);
-    *B = sol_dimension_vsop(jd, vB);
-    *R = sol_dimension_vsop(jd, vR);
-}
-
-/*! @brief Returns geocentric ecliptic longitude, latitude and radius
- *  as fk5 coordinates.
- *
- *  @param[in]  jd  Julian Day in dynamical time.
- *  @param[out] L   Longitude, in radians.
- *  @param[out] B   Latitude, in radians.
- *  @param[out] R   Radius, in astronomical units.
- *
- *  @sa dynamical::deltaT_seconds for calculating %dynamical time offset.
- */
-void sol_dimension3_fk5(double jd, double *L, double *B, double *R)
-{
-    sol_dimension3_vsop(jd, L, B, R);
-
-    /* Transform to FK5 ecliptic and equinox. */
-    vsop_to_fk5(jd, L, B);
-}
-
-
 /*! @brief Returns geometric longitude and radius vector, low
  *  precision.
  *
@@ -195,6 +123,8 @@
     return -_lk4 / R;
 }
 
+
+
 /*! @brief Calculates the rectangular geocentric coordinates of the Sun.
  *
  *  [Meeus-1998: equation 26.1.]
@@ -233,3 +163,76 @@
     rc.z = R * ((cosB * sinL * sinobl) + (sinB * cosobl));
     return rc;
 }
+
+/*! @brief Returns one of geocentric ecliptic longitude,
+ *  latitude and radius as VSOP coordinates.
+ *
+ *  @param[in]  jd        Julian Day in dynamical time.
+ *  @param[in] dim        A value to indicate whether longitude,
+ *                        latitude or radius should be returned.
+ *
+ *  @return               Either longitude or latitude (in radians), or
+ *                        radius (in astronomical units).
+ *
+ *  @sa dynamical::deltaT_seconds for calculating %dynamical time offset.
+ *
+ *  @warning This function returns the coordinates in the vsop frame
+ *  of reference, which is very slightly different from fk5.  To
+ *  convert the longitude and latitude to fk5 coordinates, use
+ *  vsop_to_fk5.  Alternatively, call sol_dimension3_fk5.
+ */
+double sol_dimension_vsop(double jd, enum Coords dim)
+{
+    double X = vsop_dimension_vsop(jd, vEarth, dim);
+    if (dim == vL) {
+	X = modpi2(X + pi);
+    } else if (dim == vB) {
+	X = -X;
+    }
+    return X;
+}
+
+/*! @brief Returns geocentric ecliptic longitude, latitude and radius
+ *  as VSOP coordinates.
+ *
+ *  The code in this function very simply calls sol_dimension for each
+ *  value, so it is no more efficient to call this.  It's provided for
+ *  convenience only.
+ *
+ *  @param[in]  jd  Julian Day in dynamical time.
+ *  @param[out] L   Longitude, in radians.
+ *  @param[out] B   Latitude, in radians.
+ *  @param[out] R   Radius, in astronomical units.
+ *
+ *  @sa dynamical::deltaT_seconds for calculating %dynamical time offset.
+ *
+ *  @warning This function returns the coordinates in the vsop frame
+ *  of reference, which is very slightly different from fk5.  To
+ *  convert the longitude and latitude to fk5 coordinates, use
+ *  vsop_to_fk5.  Alternatively, call sol_dimension3_fk5.
+ */
+void sol_dimension3_vsop(double jd, double *L, double *B, double *R)
+{
+    *L = sol_dimension_vsop(jd, vL);
+    *B = sol_dimension_vsop(jd, vB);
+    *R = sol_dimension_vsop(jd, vR);
+}
+
+/*! @brief Returns geocentric ecliptic longitude, latitude and radius
+ *  as fk5 coordinates.
+ *
+ *  @param[in]  jd  Julian Day in dynamical time.
+ *  @param[out] L   Longitude, in radians.
+ *  @param[out] B   Latitude, in radians.
+ *  @param[out] R   Radius, in astronomical units.
+ *
+ *  @sa dynamical::deltaT_seconds for calculating %dynamical time offset.
+ */
+void sol_dimension3_fk5(double jd, double *L, double *B, double *R)
+{
+    sol_dimension3_vsop(jd, L, B, R);
+
+    /* Transform to FK5 ecliptic and equinox. */
+    vsop_to_fk5(jd, L, B);
+}
+

Modified: branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c	2006-01-28 02:12:11 UTC (rev 228)
+++ branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c	2006-01-28 04:06:31 UTC (rev 229)
@@ -238,6 +238,20 @@
 }
 
 
+/* vsop_rec_coords vsop_rec_sol(const vsop_rec_coords earth_vrc) { */
+/*     vsop_rec_coords output = earth_vrc; */
+
+/*     /\* Stop right here if the incoming coordinates are in an error state. *\/ */
+/*     if (output.error_state != 0) { */
+/* 	return output; */
+/*     } */
+
+/*     /\* Make sure that these coordinates actually are for Earth. *\/ */
+
+/*     return vsop_rec_invert(earth_vrc); */
+/* } */
+
+
 /*! @brief Given a VSOP handle referencing data, and a Julian Date,
  *  calculates spherical variables.
  *



From izogi at berlios.de  Sat Jan 28 05:16:13 2006
From: izogi at berlios.de (izogi at BerliOS)
Date: Sat, 28 Jan 2006 05:16:13 +0100
Subject: [Ephemeritis-svn] r230 - branches/new-vsop-prepare/src/c/libephemeritis
Message-ID: <200601280416.k0S4GDbB030626@sheep.berlios.de>

Author: izogi
Date: 2006-01-28 05:15:58 +0100 (Sat, 28 Jan 2006)
New Revision: 230

Modified:
   branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis.h
Log:
Minor formatting of comments.


Modified: branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis.h
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis.h	2006-01-28 04:06:31 UTC (rev 229)
+++ branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis.h	2006-01-28 04:15:58 UTC (rev 230)
@@ -492,16 +492,18 @@
     double jd;			/*!< @brief The Julian Date of these coordinates, in dynamical time.                      */
     rec_coords rc;		/*!< @brief The XYZ coordinates.                                                          */
     int is_inverted;		/*!< @brief Set to 1 if these coordinates are inverted (eg. for Solar coordinates), 0 otherwise. */
-    int error_state;		/*!< @brief The state of these coordinates,
-				   indicating if they're okay to use.
-				   Note that this field is only valid
-				   once the struct values have been
-				   calculated at least once.
+    int error_state;		/*!< @brief The state of these
+				            coordinates, indicating if
+				            they're okay to use.  Note
+				            that this field is only
+				            valid once the struct
+				            values have been
+				            calculated at least once.
 
-				   0 indicates no error.
-				   -1 (vsop_get_rectangular) indicates a vsop_handle error.  (Data referenced by this handle wasn't found - perhaps it was unloaded.)
-				   -2 (vsop_get_rectangular) indicates that a vsop_handle referenced data that wasn't rectangular, or otherwise not suitable for providing rectangular coordinates.
-				   -3 (vsop_rec_vsop_to_fk5) indicates that supplied coordinates were unsuitable for converting to FK5.
+				            0 indicates no error.
+				            -1 (vsop_get_rectangular) indicates a vsop_handle error.  (Data referenced by this handle wasn't found - perhaps it was unloaded.)
+				            -2 (vsop_get_rectangular) indicates that a vsop_handle referenced data that wasn't rectangular, or otherwise not suitable for providing rectangular coordinates.
+				            -3 (vsop_rec_vsop_to_fk5) indicates that supplied coordinates were unsuitable for converting to FK5.
 				 */
 } vsop_rec_coords;
 



From izogi at berlios.de  Sat Jan 28 11:03:36 2006
From: izogi at berlios.de (izogi at BerliOS)
Date: Sat, 28 Jan 2006 11:03:36 +0100
Subject: [Ephemeritis-svn] r231 - in branches/new-vsop-prepare/src/c: libephemeritis utils
Message-ID: <200601281003.k0SA3amF019896@sheep.berlios.de>

Author: izogi
Date: 2006-01-28 11:03:35 +0100 (Sat, 28 Jan 2006)
New Revision: 231

Added:
   branches/new-vsop-prepare/src/c/libephemeritis/vsop_internal.h
Removed:
   branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_internal.h
Modified:
   branches/new-vsop-prepare/src/c/libephemeritis/Makefile.am
   branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c
   branches/new-vsop-prepare/src/c/libephemeritis/vsop_data_handling.c
   branches/new-vsop-prepare/src/c/utils/build_vsop_data.c
Log:
Renamed ephemeritis_vsop_internal.h to vsop_internal.h.



Modified: branches/new-vsop-prepare/src/c/libephemeritis/Makefile.am
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/Makefile.am	2006-01-28 04:15:58 UTC (rev 230)
+++ branches/new-vsop-prepare/src/c/libephemeritis/Makefile.am	2006-01-28 10:03:35 UTC (rev 231)
@@ -28,6 +28,6 @@
 	util.c
 
 include_HEADERS = ephemeritis.h ephemeritis_constid.h
-noinst_HEADERS = vsop_structures.h ephemeritis_vsop_internal.h
+noinst_HEADERS = vsop_structures.h vsop_internal.h
 
 libephemeritis_la_ldflags = --version-info 0:0:0

Deleted: branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_internal.h
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_internal.h	2006-01-28 04:15:58 UTC (rev 230)
+++ branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_internal.h	2006-01-28 10:03:35 UTC (rev 231)
@@ -1,124 +0,0 @@
-/* Copyright 2000, 2001, 2005 William McClain, Mike McGavin
-
-This file is part of Ephemeritis.
-
-Ephemeritis is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2 of the License, or
-(at your option) any later version.
-
-Ephemeritis is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with Ephemeritis; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-*/
-
-#ifndef _ephemeritis_vsop_internal_h_
-#define _ephemeritis_vsop_internal_h_
-
-#include "ephemeritis.h"
-
-/*! @file ephemeritis_vsop_internal.h
- *
- * Definitions for VSOP data and related functions.  This list is
- * included by various parts of the code and utilities to allow them
- * to share commonly understood data structures.
- *
- * @todo Document the defines.
- * @todo Update EPHEMERITIS_VSOP_DATA_PATH to make it configurable by the user at installation time.
- *
- * @author Mike McGavin.
- */
-
-
-#include <stdio.h>
-
-#define EPHEMERITIS_BIN_HEADER_TEXT_FORMAT "EphB v=%s"
-
-/* Define data path -- this should be updated to something more elegantly configurable. */
-#ifdef VSOP_DATA_PATH
-#define EPH_VSOP_DATA_PATH VSOP_DATA_PATH "/"
-#else
-#define EPH_VSOP_DATA_PATH ""
-#endif
-
-
-/* Start with... */
-#define EPH_VSOP_PREFIX    "VSOP87"
-
-/* Add one of... */
-#define EPH_VSOP_HEJ2      ""
-#define EPH_VSOP_HRJ2      "A"
-#define EPH_VSOP_HSJ2      "B"
-#define EPH_VSOP_HRD       "C"
-#define EPH_VSOP_HSD       "D"
-#define EPH_VSOP_BRJ2      "E"
-
-/* Followed by... */
-#define EPH_MER  "mer"
-#define EPH_VEN  "ven"
-#define EPH_EAR  "ear"
-#define EPH_MAR  "mar"
-#define EPH_JUP  "jup"
-#define EPH_SAT  "sat"
-#define EPH_URA  "ura"
-#define EPH_NEP  "nep"
-
-#define EPH_SOL  "sun"
-#define EPH_EMB  "emb"
-
-/* The suffix for binary files. */
-#define EPH_VSOP_SUFFIX    ".eph.bin"
-
-/*! @brief Represents a VSOP87 term.
- */
-typedef struct {
-    double A, B, C;
-} term_bin;
-
-
-typedef struct {
-    struct {
-	char alpha;		/*!< @brief The degree alpha of time variable for this series. */
-	short int num_terms;	/*!< @brief The number of terms listed for this series. */
-    } meta;
-
-    term_bin *terms;		/*!< @brief The terms. */
-} series;
-
-
-
-/*! @brief Collects together a particular set of elements for a
- *  particular body.
- */
-typedef struct {
-    struct {
-	char eph_header_text[23];	/*!< @brief Ephemeritis header text.                            */
-	char body_name[8];	/*!< @brief The name of the body represented by these elements. */
-	char num_variables;	/*!< @brief The number of variables included in these elements. */
-    } meta;
-
-    struct {
-	struct {
-	    char series_count;	/*!< @brief The number of series' listed in the series_list field. */
-	} meta;			/*!< @brief Binary meta data about the VSOP variable.              */
-
-	series *series_list;	/*!< @brief The series list.                   */
-    } variable_list[6];		/*!< @brief The variables.                     */
-
-} body_elements;
-
-
-body_elements *ephint_get_body_elements_for_handle(const vsop_handle vh);
-void ephint_free_body_elements(body_elements * b);
-void ephint_write_body_elements(FILE * outfile, body_elements * b);
-/*
-void ephint_print_body_statistics(FILE *ostream, body_elements *b);
-body_elements *ephint_read_body_elements(FILE *infile);
-*/
-
-#endif

Modified: branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c	2006-01-28 04:15:58 UTC (rev 230)
+++ branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c	2006-01-28 10:03:35 UTC (rev 231)
@@ -27,7 +27,7 @@
  */
 
 #include "ephemeritis.h"
-#include "ephemeritis_vsop_internal.h"
+#include "vsop_internal.h"
 #include "config.h"
 
 #include <math.h>

Modified: branches/new-vsop-prepare/src/c/libephemeritis/vsop_data_handling.c
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/vsop_data_handling.c	2006-01-28 04:15:58 UTC (rev 230)
+++ branches/new-vsop-prepare/src/c/libephemeritis/vsop_data_handling.c	2006-01-28 10:03:35 UTC (rev 231)
@@ -24,7 +24,7 @@
  * @author Mike McGavin.
  */
 
-#include "ephemeritis_vsop_internal.h"
+#include "vsop_internal.h"
 #include "ephemeritis.h"
 
 #include <errno.h>

Copied: branches/new-vsop-prepare/src/c/libephemeritis/vsop_internal.h (from rev 227, branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis_vsop_internal.h)

Modified: branches/new-vsop-prepare/src/c/utils/build_vsop_data.c
===================================================================
--- branches/new-vsop-prepare/src/c/utils/build_vsop_data.c	2006-01-28 04:15:58 UTC (rev 230)
+++ branches/new-vsop-prepare/src/c/utils/build_vsop_data.c	2006-01-28 10:03:35 UTC (rev 231)
@@ -32,7 +32,7 @@
 
 #include "config.h"
 #include <ephemeritis.h>
-#include <ephemeritis_vsop_internal.h>
+#include <vsop_internal.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <errno.h>



From izogi at berlios.de  Sun Jan 29 04:14:00 2006
From: izogi at berlios.de (izogi at BerliOS)
Date: Sun, 29 Jan 2006 04:14:00 +0100
Subject: [Ephemeritis-svn] r232 - in branches/new-vsop-prepare/src/c: libephemeritis tests
Message-ID: <200601290314.k0T3E0FP007464@sheep.berlios.de>

Author: izogi
Date: 2006-01-29 04:13:27 +0100 (Sun, 29 Jan 2006)
New Revision: 232

Modified:
   branches/new-vsop-prepare/src/c/libephemeritis/elliptical.c
   branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis.h
   branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c
   branches/new-vsop-prepare/src/c/tests/validate_meeus.c
Log:
Cleaned up routine for converting Earth VSOP coordinates to Solar VSOP coordinates.  (Rectangular only -- spherical is coming.)


Modified: branches/new-vsop-prepare/src/c/libephemeritis/elliptical.c
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/elliptical.c	2006-01-28 10:03:35 UTC (rev 231)
+++ branches/new-vsop-prepare/src/c/libephemeritis/elliptical.c	2006-01-29 03:13:27 UTC (rev 232)
@@ -86,6 +86,8 @@
  *
  *  @todo Adjust parameters so that r_earth gets passed back too.
  *
+ *  @bug Doesn't work cleanly with new VSOP routines.
+ *
  *  @author Bill McClain, Mike McGavin.
  */
 int geocentric_planet(double jd,

Modified: branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis.h
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis.h	2006-01-28 10:03:35 UTC (rev 231)
+++ branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis.h	2006-01-29 03:13:27 UTC (rev 232)
@@ -486,6 +486,8 @@
 
 /*! @brief A struct to hold rectangular coordinates from a particular
  *  calculation, including meta information about their calculation.
+ *
+ *  @todo Make error responses an enumeration rather than constant values.
  */
 typedef struct {
     vsop_handle vh;		/*!< @brief The VSOP handle representing the data these coordinates were calculated from. */
@@ -504,6 +506,8 @@
 				            -1 (vsop_get_rectangular) indicates a vsop_handle error.  (Data referenced by this handle wasn't found - perhaps it was unloaded.)
 				            -2 (vsop_get_rectangular) indicates that a vsop_handle referenced data that wasn't rectangular, or otherwise not suitable for providing rectangular coordinates.
 				            -3 (vsop_rec_vsop_to_fk5) indicates that supplied coordinates were unsuitable for converting to FK5.
+					    -4 (vsop_rec_sol) indicates that supplied coordinates were not Earth coordinates, and therefore unsuitable for converting to solar coordinates.  Note that even if the input planet is vsop_earth, is_inverted must be set to 0 or this error will be returned.
+					    -5 (vsop_rec_sol) indicates that supplied coordinates were not rectangular J2000 or date coordinates.
 				 */
 } vsop_rec_coords;
 
@@ -517,11 +521,13 @@
 
 /*! @brief A struct to hold spherical coordinates from a particular
  *  calculation, including meta information about their calculation.
+ *
+ *  @todo Make error responses an enumeration rather than constant values.
  */
 typedef struct {
     vsop_handle vh;		/*!< @brief The VSOP handle representing the data these coordinates were calculated from. */
     double jd;			/*!< @brief The Julian Date of these coordinates, in dynamical time.                      */
-    sph_coords sc;		/*!< @brief The spherical coordinates.                                                   */
+    sph_coords sc;		/*!< @brief The spherical coordinates.                                                    */
     int is_inverted;		/*!< @brief Set to 1 if these coordinates are inverted (eg. for Solar coordinates), 0 otherwise. */
     int error_state;		/*!< @brief The state of these coordinates,
 				   indicating if they're okay to use.
@@ -546,10 +552,12 @@
 vsop_rec_coords vsop_get_rectangular(const vsop_handle vh,
 				     const double jd);
 vsop_rec_coords vsop_rec_vsop_to_fk5(const vsop_rec_coords vrc);
-vsop_rec_coords vsop_rec_invert(const vsop_rec_coords vrc);
+/* vsop_rec_coords vsop_rec_invert(const vsop_rec_coords vrc); */
+vsop_rec_coords vsop_rec_sol(const vsop_rec_coords earth_vrc);
+
 vsop_sph_coords vsop_get_spherical(const vsop_handle vh, const double jd);
 vsop_sph_coords vsop_sph_vsop_to_fk5(const vsop_sph_coords vsc);
-vsop_sph_coords vsop_sph_invert(const vsop_sph_coords vsc);
+/* vsop_sph_coords vsop_sph_invert(const vsop_sph_coords vsc); */
 
 
 #endif

Modified: branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c	2006-01-28 10:03:35 UTC (rev 231)
+++ branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c	2006-01-29 03:13:27 UTC (rev 232)
@@ -221,7 +221,7 @@
  *  @return A set of rectangular coordinates identical to those
  *  provided, but inverted.
  */
-vsop_rec_coords vsop_rec_invert(const vsop_rec_coords vrc)
+static vsop_rec_coords vsop_rec_invert(const vsop_rec_coords vrc)
 {
     vsop_rec_coords output = vrc;
 
@@ -238,18 +238,37 @@
 }
 
 
-/* vsop_rec_coords vsop_rec_sol(const vsop_rec_coords earth_vrc) { */
-/*     vsop_rec_coords output = earth_vrc; */
+/*! @brief Converts rectangular Earth coordinates to rectangular Sun
+ *  coordinates.
+ *
+ *  Given a set of rectangular Earth coordinates, converts them to
+ *  rectangular Sun coordinates.  The is_inverted member variable of
+ *  the result will be set to 1 rather than 0, indicating that the
+ *  struct contains solar coordinates.
+ */
+vsop_rec_coords vsop_rec_sol(const vsop_rec_coords earth_vrc) {
+    vsop_rec_coords output = earth_vrc;
 
-/*     /\* Stop right here if the incoming coordinates are in an error state. *\/ */
-/*     if (output.error_state != 0) { */
-/* 	return output; */
-/*     } */
+    /* Stop right here if the incoming coordinates are in an error state. */
+    if (output.error_state != 0) {
+	return output;
+    }
 
-/*     /\* Make sure that these coordinates actually are for Earth. *\/ */
+    /* Make sure that these coordinates actually are for Earth, and
+       that they're rectangular date or j2000 variables. */
+    if(output.vh.planet != vsop_earth && !output.is_inverted) {
+      output.error_state = -4;
+      return output;
+    }
+    if(output.vh.version != hel_rec_j2 && output.vh.version != hel_rec_date) {
+      output.error_state = -5;
+      return output;
+    }
 
-/*     return vsop_rec_invert(earth_vrc); */
-/* } */
+    /* Now invert the coordinates, and return the results. */
+    output = vsop_rec_invert(output);
+    return output;
+}
 
 
 /*! @brief Given a VSOP handle referencing data, and a Julian Date,

Modified: branches/new-vsop-prepare/src/c/tests/validate_meeus.c
===================================================================
--- branches/new-vsop-prepare/src/c/tests/validate_meeus.c	2006-01-28 10:03:35 UTC (rev 231)
+++ branches/new-vsop-prepare/src/c/tests/validate_meeus.c	2006-01-29 03:13:27 UTC (rev 232)
@@ -1306,30 +1306,6 @@
 	}
     }
 
-
-/*     printf("\n\nPlaying with new VSOP methods:\n"); */
-/*     { */
-
-/*       vsop_handle vh; */
-/*       bool result; */
-/*       result = get_vsop_data_handle(vsop_mercury, hel_rec_date, &vh); */
-/*       printf("%d\n", vh.data_id); */
-
-/*       result = get_vsop_data_handle(vsop_venus, hel_rec_date, &vh); */
-/*       printf("%d\n", vh.data_id); */
-
-/*       result = get_vsop_data_handle(vsop_earth, hel_rec_date, &vh); */
-/*       printf("%d\n", vh.data_id); */
-
-/*       result = get_vsop_data_handle(vsop_mercury, hel_rec_date, &vh); */
-/*       printf("%d\n", vh.data_id); */
-
-/*       if(result) { */
-/* 	printf("Loaded okay\n"); */
-/*       } else { */
-/* 	printf("File didn't load for some reason\n"); */
-/*       } */
-/*     } */
     {
 	printf("Checking new VSOP routines\n");
 	{
@@ -1339,8 +1315,7 @@
 		printf("\t\tError loading Earth handle.\n");
 	    } else {
 		double jd = 2448170.5;
-		vsop_rec_coords vrc = vsop_get_rectangular(vh, jd);
-		vrc = vsop_rec_invert(vsop_rec_vsop_to_fk5(vrc));
+		vsop_rec_coords vrc = vsop_rec_sol(vsop_rec_vsop_to_fk5(vsop_get_rectangular(vh, jd)));
 
 		report("X", vrc.rc.x * km_per_au,
 		       -0.975673220683 * km_per_au, 1.0e-4, "km");



From izogi at berlios.de  Sun Jan 29 10:51:52 2006
From: izogi at berlios.de (izogi at BerliOS)
Date: Sun, 29 Jan 2006 10:51:52 +0100
Subject: [Ephemeritis-svn] r233 - in branches/new-vsop-prepare/src/c: libephemeritis tests
Message-ID: <200601290951.k0T9pqm5013441@sheep.berlios.de>

Author: izogi
Date: 2006-01-29 10:51:48 +0100 (Sun, 29 Jan 2006)
New Revision: 233

Modified:
   branches/new-vsop-prepare/src/c/libephemeritis/aberration.c
   branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis.h
   branches/new-vsop-prepare/src/c/libephemeritis/solar.c
   branches/new-vsop-prepare/src/c/libephemeritis/vsop87d.c
   branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c
   branches/new-vsop-prepare/src/c/tests/validate_meeus.c
Log:
More meddling with the conversion between VSOP and FK5 coordinates.  I think I'm coming to understand where the different routines are appropriate, and realising that I really need some additional algorithms for further rotations.


Modified: branches/new-vsop-prepare/src/c/libephemeritis/aberration.c
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/aberration.c	2006-01-29 03:13:27 UTC (rev 232)
+++ branches/new-vsop-prepare/src/c/libephemeritis/aberration.c	2006-01-29 09:51:48 UTC (rev 233)
@@ -141,7 +141,8 @@
 		   (cosra_sindec * sinp));
 }
 
-
+/*
 void aberration_in_ra_dec()
 {
 }
+*/

Modified: branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis.h
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis.h	2006-01-29 03:13:27 UTC (rev 232)
+++ branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis.h	2006-01-29 09:51:48 UTC (rev 233)
@@ -538,7 +538,9 @@
 				   0 indicates no error.
 				   -1 (vsop_get_spherical) indicates a vsop_handle error.  (Data referenced by this handle wasn't found - perhaps it was unloaded.)
 				   -2 (vsop_get_spherical) indicates that a vsop_handle referenced data that wasn't spherical, or otherwise not suitable for providing spherical coordinates.  (This should really only happen if the data in the struct has been corrupted somehow.)
-				   -3 (vsop_rec_vsop_to_fk5) indicates that supplied coordinates were unsuitable for converting to FK5.
+				   -3 (vsop_sph_vsop_to_fk5) indicates that supplied coordinates were unsuitable for converting to FK5.
+				   -4 (vsop_sph_sol) indicates that supplied coordinates were not Earth coordinates, and therefore unsuitable for converting to solar coordinates.  Note that even if the input planet is vsop_earth, is_inverted must be set to 0 or this error will be returned.
+				   -5 (vsop_sph_sol) indicates that supplied coordinates were not rectangular J2000 or date coordinates.
 				 */
 } vsop_sph_coords;
 
@@ -552,12 +554,11 @@
 vsop_rec_coords vsop_get_rectangular(const vsop_handle vh,
 				     const double jd);
 vsop_rec_coords vsop_rec_vsop_to_fk5(const vsop_rec_coords vrc);
-/* vsop_rec_coords vsop_rec_invert(const vsop_rec_coords vrc); */
 vsop_rec_coords vsop_rec_sol(const vsop_rec_coords earth_vrc);
 
 vsop_sph_coords vsop_get_spherical(const vsop_handle vh, const double jd);
 vsop_sph_coords vsop_sph_vsop_to_fk5(const vsop_sph_coords vsc);
-/* vsop_sph_coords vsop_sph_invert(const vsop_sph_coords vsc); */
+vsop_sph_coords vsop_sph_sol(const vsop_sph_coords earth_vsc);
 
 
 #endif

Modified: branches/new-vsop-prepare/src/c/libephemeritis/solar.c
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/solar.c	2006-01-29 03:13:27 UTC (rev 232)
+++ branches/new-vsop-prepare/src/c/libephemeritis/solar.c	2006-01-29 09:51:48 UTC (rev 233)
@@ -152,13 +152,14 @@
  */
 rec_coords sol_rectangular(double L, double B, double R, double obl)
 {
+    double cosL = cos(L);
     double cosB = cos(B);
     double sinL = sin(L);
     double sinB = sin(B);
     double sinobl = sin(obl);
     double cosobl = cos(obl);
     rec_coords rc;
-    rc.x = R * (cosB * cos(L));
+    rc.x = R * (cosB * cosL);
     rc.y = R * ((cosB * sinL * cosobl) - (sinB * sinobl));
     rc.z = R * ((cosB * sinL * sinobl) + (sinB * cosobl));
     return rc;

Modified: branches/new-vsop-prepare/src/c/libephemeritis/vsop87d.c
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/vsop87d.c	2006-01-29 03:13:27 UTC (rev 232)
+++ branches/new-vsop-prepare/src/c/libephemeritis/vsop87d.c	2006-01-29 09:51:48 UTC (rev 233)
@@ -169,7 +169,8 @@
 }
 
 
-/*! @brief Converts VSOP to FK5 coordinates. 
+/*! @brief Converts VSOP coordinates that accordto the dynamical
+ *  ecliptic and equinox of the date to FK5 coordinates.
  *
  *  This is required only when using the full precision of the
  *  VSOP model. [Meeus-1998: pg 219]
@@ -181,10 +182,6 @@
  *
  *  @sa dynamical::deltaT_seconds for calculating %dynamical time offset.
  *
- *  @todo Figure out where this function belongs... it's presently in
- *  elliptical.c, but may belong in vsop87d.c.  If the latter, however,
- *  there could be problems with how the geocentric_planet_f() function
- *  knows to call it without it being properly independent.
  */
 void vsop_to_fk5(double jd, double *L, double *B)
 {

Modified: branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c	2006-01-29 03:13:27 UTC (rev 232)
+++ branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c	2006-01-29 09:51:48 UTC (rev 233)
@@ -173,6 +173,8 @@
  *
  *  @return The rotated coordinates.
  *
+ *  @todo Confirm if heliocentric rectangular coordinates of date can be rotated with this algorithm.  (Assuming they can.)
+ *
  *  @author Mike McGavin.
  */
 vsop_rec_coords vsop_rec_vsop_to_fk5(const vsop_rec_coords vrc)
@@ -238,13 +240,18 @@
 }
 
 
-/*! @brief Converts rectangular Earth coordinates to rectangular Sun
- *  coordinates.
+/*! @brief Converts heliocentric rectangular Earth coordinates to
+ *  geocentric rectangular Sun coordinates.
  *
- *  Given a set of rectangular Earth coordinates, converts them to
- *  rectangular Sun coordinates.  The is_inverted member variable of
- *  the result will be set to 1 rather than 0, indicating that the
- *  struct contains solar coordinates.
+ *  Given a set of heliocentric rectangular Earth coordinates,
+ *  converts them to geocentric rectangular Sun coordinates.  The
+ *  is_inverted member variable of the result will be set to 1 rather
+ *  than 0, indicating that the struct contains solar coordinates.
+ *
+ *  @param[in] earth_vrc A set of heliocentric rectangular Earth
+ *                       coordinates.
+ *
+ *  @return    A set of geocentric rectangular Sun coordinates.
  */
 vsop_rec_coords vsop_rec_sol(const vsop_rec_coords earth_vrc) {
     vsop_rec_coords output = earth_vrc;
@@ -324,11 +331,12 @@
 
 
 /*! @brief Rotate spherical VSOP coordinates from the dynamical
- *  ecliptic frame to the equatorial frame FK5.
+ *  ecliptic frame of the date to the equatorial frame FK5.
  *
- *  The incoming coordinates must be spherical.  ie. They must have
- *  been generated from hel_sph_j2 or hel_sph_date.  If it isn't, the
- *  error_state property of the returned struct will be set to a
+ *  The incoming coordinates must be spherical, and must be defined
+ *  for the dynamical ecliptic and equinox of the date.  ie. They must
+ *  have been generated from hel_sph_j2 or hel_sph_date.  If it isn't,
+ *  the error_state property of the returned struct will be set to a
  *  non-zero value.  If it is already a non-zero value for the
  *  incoming data, the data will be immediately returned with no
  *  change.
@@ -359,10 +367,9 @@
 	return output;
     }
 
-    /* Check that the incoming coordinates are spherical. */
+    /* Check that the incoming coordinates are spherical and of the date. */
     if (!
-	(output.vh.version == hel_sph_j2
-	 || output.vh.version == hel_sph_date)) {
+	(output.vh.version == hel_sph_date)) {
 	output.error_state = -3;
 	return output;
     }
@@ -406,7 +413,7 @@
  *  @return A set of spherical coordinates identical to those
  *  provided, but inverted.
  */
-vsop_sph_coords vsop_sph_invert(const vsop_sph_coords vsc)
+static vsop_sph_coords vsop_sph_invert(const vsop_sph_coords vsc)
 {
     vsop_sph_coords output = vsc;
 
@@ -420,3 +427,40 @@
     output.is_inverted = output.is_inverted ^ 0x01;
     return output;
 }
+
+/*! @brief Converts heliocentric spherical Earth coordinates to
+ *  geocentric spherical Sun coordinates.
+ *
+ *  Given a set of heliocentric spherical Earth coordinates, converts
+ *  them to geocentric spherical Sun coordinates.  The is_inverted
+ *  member variable of the result will be set to 1 rather than 0,
+ *  indicating that the struct contains solar coordinates.
+ *
+ *  @param[in] earth_vrc A set of heliocentric spherical Earth
+ *                       coordinates.
+ *
+ *  @return    A set of geocentric spherical Sun coordinates.
+ */
+vsop_sph_coords vsop_sph_sol(const vsop_sph_coords earth_vsc)
+{
+    vsop_sph_coords output = earth_vsc;
+
+    /* Stop right here if the incoming coordinates are in an error state. */
+    if (output.error_state != 0) {
+	return output;
+    }
+
+    /* Make sure that these coordinates actually are for Earth, and
+       that they're spherical date or j2000 variables. */
+    if(output.vh.planet != vsop_earth && !output.is_inverted) {
+      output.error_state = -4;
+      return output;
+    }
+    if(output.vh.version != hel_sph_j2 && output.vh.version != hel_sph_date) {
+      output.error_state = -5;
+      return output;
+    }
+
+    output = vsop_sph_invert(output);
+    return output;
+}

Modified: branches/new-vsop-prepare/src/c/tests/validate_meeus.c
===================================================================
--- branches/new-vsop-prepare/src/c/tests/validate_meeus.c	2006-01-29 03:13:27 UTC (rev 232)
+++ branches/new-vsop-prepare/src/c/tests/validate_meeus.c	2006-01-29 09:51:48 UTC (rev 233)
@@ -743,89 +743,97 @@
     printf("25.b Sun position, high precision\n");
     {
 	double jd = 2448908.5;
-	double L, B, R;
-	sol_dimension3_vsop(jd, &L, &B, &R);
-	/*
-	   report_diff("longitude", r_to_d(L) * 3600, 199.907372 * 3600,
-	   "arc-seconds");
-	   report_diff("latitude", r_to_d(B) * 3600, 0.644, "arc-seconds");
-	   report_diff("radius", R * km_per_au, 0.99760775 * km_per_au, "km");
-	 */
 
-	report("longitude", r_to_d(L) * 3600, 199.907372 * 3600, 1.0,
-	       "arc-seconds");
-	report("latitude", r_to_d(B) * 3600, 0.644, 1.0, "arc-seconds");
-	report("radius", R * km_per_au, 0.99760775 * km_per_au, 200.0,
-	       "km");
+	vsop_handle vh;
+	vsop_sph_coords vsc;
+	if(0 == get_vsop_data_handle(vsop_earth, hel_sph_date, &vh)) {
+	  vsc = vsop_sph_sol(vsop_get_spherical(vh, jd));
+	  report("longitude", r_to_d(vsc.sc.L) * 3600, 199.907372 * 3600, 1.0,
+		 "arc-seconds");
+	  report("latitude", r_to_d(vsc.sc.B) * 3600, 0.644, 1.0, "arc-seconds");
+	  report("radius", vsc.sc.R * km_per_au, 0.99760775 * km_per_au, 150.0,
+		 "km");
 
-	vsop_to_fk5(2448908.5, &L, &B);
+	  vsc = vsop_sph_vsop_to_fk5(vsc);
 
-	/*
-	   report_diff("corrected longitude", r_to_d(L) * 3600,
-	   199.907347 * 3600, "arc-seconds");
-	   report_diff("corrected latitude", r_to_d(B) * 3600, 0.62,
-	   "arc-seconds");
-	 */
-	report("corrected fk5 longitude", r_to_d(L) * 3600,
-	       199.907347 * 3600, 1.0, "arc-seconds");
-	report("corrected fk5 latitude", r_to_d(B) * 3600, 0.644 - 0.023,
-	       0.1, "arc-seconds");
-	/*
-	   report("corrected fk5 latitude", r_to_d(B) * 3600, 0.62, 0.1, "arc-seconds");
-	 */
+	  report("corrected fk5 longitude", r_to_d(vsc.sc.L) * 3600,
+		 199.907347 * 3600, 1.0, "arc-seconds");
+	  report("corrected fk5 latitude", r_to_d(vsc.sc.B) * 3600, 0.644 - 0.023,
+		 0.1, "arc-seconds");
 
-	printf
+
+	  printf
 	    ("25.b Sun position, high precision (complete theory pg 165)\n");
 
-	const double n_in_l = nut_in_lon(jd);
-	const double n_in_o = nut_in_obl(jd);
-	const double obl = obliquity_hi(jd) + n_in_o;
-	const double aberration = aberration_low(R);
+	  const double n_in_l = nut_in_lon(jd);
+	  const double n_in_o = nut_in_obl(jd);
+	  const double obl = obliquity_hi(jd) + n_in_o;
+	  const double aberration = aberration_low(vsc.sc.R);
 
-	report("nutation in lon", r_to_d(n_in_l) * 3600, 15.908, 0.001,
-	       "arc-seconds");
-	report("nutation in obliquity", r_to_d(n_in_o) * 3600, -0.308,
-	       0.001, "arc-seconds");
-	report("obliquity", r_to_d(obl), 23.4401443, 0.0000001, "degrees");
-	report("aberration", r_to_d(aberration) * 3600, -20.539, 0.001,
-	       "arc-seconds");
+	  report("nutation in lon", r_to_d(n_in_l) * 3600, 15.908, 0.001,
+		 "arc-seconds");
+	  report("nutation in obliquity", r_to_d(n_in_o) * 3600, -0.308,
+		 0.001, "arc-seconds");
+	  report("obliquity", r_to_d(obl), 23.4401443, 0.0000001, "degrees");
+	  report("aberration", r_to_d(aberration) * 3600, -20.539, 0.001,
+		 "arc-seconds");
 
-	double app_lon = L + n_in_l + aberration;
-	report("apparent longitude", r_to_d(app_lon) * 3600.0,
-	       dms_to_d(199, 54, 21.818) * 3600.0, 1, "arc-seconds");
+	  double app_lon = vsc.sc.L + n_in_l + aberration;
+	  report("apparent longitude", r_to_d(app_lon) * 3600.0,
+		 dms_to_d(199, 54, 21.818) * 3600.0, 1, "arc-seconds");
 
-	report("longitude", r_to_d(L) * 3600 * 100,
-	       dms_to_d(199, 54, 26.18) * 3600 * 100, 1,
-	       "arc-seconds/100");
-	report("latitude", r_to_d(B) * 3600 * 100, 0.72 * 100, 1,
-	       "arc-seconds/100");
-	report("radius", R, 0.99760853, 1e-8, "au");
+	  report("longitude", r_to_d(vsc.sc.L) * 3600 * 100,
+		 dms_to_d(199, 54, 26.18) * 3600 * 100, 1,
+		 "arc-seconds/100");
+	  report("latitude", r_to_d(vsc.sc.B) * 3600 * 100, 0.72 * 100, 1,
+		 "arc-seconds/100");
+	  report("radius", vsc.sc.R, 0.99760853, 1e-8, "au");
 
+	} else {
+	  printf("Unable to allocate the VSOP handle.\n");
+	}
 
     }
 
     printf("26.a Rectangular coordinates of the Sun\n");
     {
+        printf("This code appears to have all sorts of problems matching Meeus exactly.  I think it's because Meeus uses non-complete VSOP data in the example, though he doesn't say.");
 	double jd = 2448908.5;
 
-/* 	double L, B, R; */
-/* 	sol_dimension3_fk5(jd, &L, &B, &R); */
+	printf("\t- Calculating rectangular coordinates directly:\n");
+	vsop_handle vh;
+	if(0 == get_vsop_data_handle(vsop_earth, hel_rec_date, &vh)) {
+	  vsop_rec_coords vrc = vsop_rec_sol(vsop_rec_vsop_to_fk5(vsop_get_rectangular(vh, jd)));
+	  printf("Error value of vrc is: %d", vrc.error_state);
+	  report("aX", vrc.rc.x * km_per_au, -0.9379952 * km_per_au, 1.0, "km");
+	  report("aY", vrc.rc.y * km_per_au, -0.3116544 * km_per_au, 1.0, "km");
+	  report("aZ", vrc.rc.z * km_per_au, -0.1351215 * km_per_au, 1.0, "km");
+	  
+	} else {
+	  printf("Problem getting a data handle.\n");
+	}
 
-/* 	/\* VSOP calculates slightly different values from the book, so */
-/* 	   L, B and R will, here, be overridden from those stated on */
-/* 	   p172. *\/ */
+
+
+	double L, B, R;
+	sol_dimension3_fk5(jd, &L, &B, &R);
+
+	/* VSOP calculates slightly different values from the book, so
+	   L, B and R will, here, be overridden from those stated on
+	   p172. */
 /* 	L = d_to_r(199.907347); */
 /* 	B = d_to_r(dms_to_d(0, 0, 0.62)); */
 /* 	R = 0.99760775; */
 
-/* 	double E = obliquity_hi(jd); */
-/* 	rec_coords rc = sol_rectangular(L, B, R, E); */
-/* 	report("X", rc.x * km_per_au, -0.9379952 * km_per_au, 5.0, "km"); */
-/* 	report("Y", rc.y * km_per_au, -0.3116544 * km_per_au, 5.0, "km"); */
-/* 	report("Z", rc.z * km_per_au, -0.1351215 * km_per_au, 5.0, "km"); */
+	double E = obliquity_hi(jd);
+	rec_coords rc = sol_rectangular(L, B, R, E);
+	report("aX", rc.x * km_per_au, -0.9379952 * km_per_au, 5.0, "km");
+	report("aY", rc.y * km_per_au, -0.3116544 * km_per_au, 5.0, "km");
+	report("aZ", rc.z * km_per_au, -0.1351215 * km_per_au, 5.0, "km");
 
 
-	vsop_handle vh;
+
+/* 	vsop_handle vh; */
 	int result;
 	if (0 !=
 	    (result =
@@ -836,6 +844,9 @@
 		vsop_sph_vsop_to_fk5(vsop_get_spherical(vh, jd));
 
 	    double E = obliquity_hi(jd);
+
+	    printf("L=%.12f B=%.12f R=%.12f E=%.12f\n", vsc.sc.L, vsc.sc.B, vsc.sc.R, E);
+
 	    rec_coords rc =
 		sol_rectangular(vsc.sc.L, vsc.sc.B, vsc.sc.R, E);
 	    report("X", -rc.x * km_per_au, -0.9379952 * km_per_au, 5.0,
@@ -845,21 +856,12 @@
 	    report("Z", -rc.z * km_per_au, -0.1351215 * km_per_au, 5.0,
 		   "km");
 
+	    report("X", -rc.x, -0.9379952, 1e-9, "au");
+	    report("Y", -rc.y, -0.3116544, 1e-9, "au");
+	    report("Z", -rc.z, -0.1351215, 1e-9, "au");
+
 	}
 
-/* 	printf("Using the more newly coded method:\n"); */
-/* 	if(0 != get_vsop_data_handle(vsop_earth, hel_rec_date, &vh)) { */
-/* 	  printf("\t\tError loading Earth handle.\n"); */
-/* 	} else { */
-/* 	  vsop_rec_coords vrc = vsop_get_rectangular(vh, jd); */
-/* 	  vrc = vsop_rec_vsop_to_fk5(vrc); */
-
-/* 	  report("X", -vrc.rc.x * km_per_au, -0.9379952 * km_per_au, 5.0, "km"); */
-/* 	  report("Y", -vrc.rc.y * km_per_au, -0.3116544 * km_per_au, 5.0, "km"); */
-/* 	  report("Z", -vrc.rc.z * km_per_au, -0.1351215 * km_per_au, 5.0, "km"); */
-
-/* 	} */
-
     }
 
     printf("27.a Approximate solstice\n");



From izogi at berlios.de  Sun Jan 29 20:00:44 2006
From: izogi at berlios.de (izogi at BerliOS)
Date: Sun, 29 Jan 2006 20:00:44 +0100
Subject: [Ephemeritis-svn] r234 - branches/new-vsop-prepare/src/c/libephemeritis
Message-ID: <200601291900.k0TJ0iNh024342@sheep.berlios.de>

Author: izogi
Date: 2006-01-29 20:00:41 +0100 (Sun, 29 Jan 2006)
New Revision: 234

Modified:
   branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c
Log:
Updated vsop_sph_vsop_to_fk5() to be able to convert J2000.0 coordinates (in theory, but untested.)


Modified: branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c	2006-01-29 09:51:48 UTC (rev 233)
+++ branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c	2006-01-29 19:00:41 UTC (rev 234)
@@ -173,8 +173,11 @@
  *
  *  @return The rotated coordinates.
  *
- *  @todo Confirm if heliocentric rectangular coordinates of date can be rotated with this algorithm.  (Assuming they can.)
+ *  @bug Can't rotate non-J2000 coordinates.
  *
+ *  @todo Figure out how Meeus' non-J2000 formula can be converted to
+ *  3D matrix rotation, and update.
+ *
  *  @author Mike McGavin.
  */
 vsop_rec_coords vsop_rec_vsop_to_fk5(const vsop_rec_coords vrc)
@@ -345,15 +348,11 @@
  *
  *  @return The rotated coordinates.
  *
- *  @todo It isn't clear which coordinates are rotatable (and I'm not
- *  really enough of an expert on this).  Basically Meeus seems to
- *  imply that VSOP87D, which is framed for the ecliptic of the date,
- *  can be rotated to FK5 with this formula.  This seems inconsistent
- *  with the VSOP vsop.doc.gz file, which implies that those ones
- *  framed for the ecliptic of the date can't (or possibly shouldn't)
- *  be rotated... at least with rectangular coordinates, which might
- *  work differently.  This needs to be checked with someone who has a
- *  clue about calculating ephermerides and frames of reference.
+ *  @note Meeus' formula was specifically stated as being for the
+ *  dynamical ecliptic and equinox of the date.  The same formula
+ *  should be fine to use for J2000, if it's assumed that the time is
+ *  2000.0.  (ie. The rotation for the date at 2000.0 is equivalent to
+ *  the rotation for all coordinates in J2000.0.)
  *
  *  @author Mike McGavin.
  */
@@ -369,7 +368,9 @@
 
     /* Check that the incoming coordinates are spherical and of the date. */
     if (!
-	(output.vh.version == hel_sph_date)) {
+	(output.vh.version == hel_sph_date
+	 || output.vh.version == hel_sph_j2)
+	) {
 	output.error_state = -3;
 	return output;
     }
@@ -386,7 +387,12 @@
 	terms[2] = d_to_r(0.00031);
     }
 
-    double T = jd_to_jcent(vsc.jd) / 10.0;
+    double T = 0;
+    if(output.vh.version == hel_sph_date) {
+      T = jd_to_jcent(vsc.jd) / 10.0;
+    } else {
+      T = 0.0;
+    }
     double L1 = vsc.sc.L - polynomial(terms, 3, T);
     double cosL1 = cos(L1);
     double sinL1 = sin(L1);



From izogi at berlios.de  Mon Jan 30 11:36:00 2006
From: izogi at berlios.de (izogi at BerliOS)
Date: Mon, 30 Jan 2006 11:36:00 +0100
Subject: [Ephemeritis-svn] r235 - in branches/new-vsop-prepare/src/c: libephemeritis tests
Message-ID: <200601301036.k0UAa0QK024228@sheep.berlios.de>

Author: izogi
Date: 2006-01-30 11:35:58 +0100 (Mon, 30 Jan 2006)
New Revision: 235

Modified:
   branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis.h
   branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c
   branches/new-vsop-prepare/src/c/tests/validate_meeus.c
Log:
More attempting to get Meeus' examples to work in 6.a.  I think the problems may simply be because Meeus isn't using the most accurate VSOP data.


Modified: branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis.h
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis.h	2006-01-29 19:00:41 UTC (rev 234)
+++ branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis.h	2006-01-30 10:35:58 UTC (rev 235)
@@ -553,11 +553,11 @@
 /* vsop_calculate.c */
 vsop_rec_coords vsop_get_rectangular(const vsop_handle vh,
 				     const double jd);
-vsop_rec_coords vsop_rec_vsop_to_fk5(const vsop_rec_coords vrc);
+vsop_rec_coords vsop_rec_to_fk5(const vsop_rec_coords vrc);
 vsop_rec_coords vsop_rec_sol(const vsop_rec_coords earth_vrc);
 
 vsop_sph_coords vsop_get_spherical(const vsop_handle vh, const double jd);
-vsop_sph_coords vsop_sph_vsop_to_fk5(const vsop_sph_coords vsc);
+vsop_sph_coords vsop_sph_to_fk5(const vsop_sph_coords vsc);
 vsop_sph_coords vsop_sph_sol(const vsop_sph_coords earth_vsc);
 
 

Modified: branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c	2006-01-29 19:00:41 UTC (rev 234)
+++ branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c	2006-01-30 10:35:58 UTC (rev 235)
@@ -115,7 +115,7 @@
  *  @param jd The Julian Date for which to
  *            calculate coordinates, in dynamical time.
  *
- *  @sa vsop_rec_vsop_to_fk5
+ *  @sa vsop_rec_to_fk5
  *
  *  @author Mike McGavin.
  */
@@ -180,7 +180,7 @@
  *
  *  @author Mike McGavin.
  */
-vsop_rec_coords vsop_rec_vsop_to_fk5(const vsop_rec_coords vrc)
+vsop_rec_coords vsop_rec_to_fk5(const vsop_rec_coords vrc)
 {
     /* Make a variable to return, and inialise it to the existing incoming values. */
     vsop_rec_coords output = vrc;
@@ -193,6 +193,7 @@
     /* Check that the incoming coordinates are of a version designed to be rotated. */
     if (!
 	(output.vh.version == hel_rec_j2
+	 || output.vh.version == hel_rec_date
 	 || output.vh.version == bar_rec_j2)) {
 	output.error_state = -3;
 	return output;
@@ -294,7 +295,7 @@
  *  @param jd The Julian Date for which to
  *            calculate coordinates, in dynamical time.
  *
- *  @sa vsop_sph_vsop_to_fk5
+ *  @sa vsop_sph_to_fk5
  *
  *  @author Mike McGavin.
  */
@@ -356,7 +357,7 @@
  *
  *  @author Mike McGavin.
  */
-vsop_sph_coords vsop_sph_vsop_to_fk5(const vsop_sph_coords vsc)
+vsop_sph_coords vsop_sph_to_fk5(const vsop_sph_coords vsc)
 {
     /* Make a variable to return, and inialise it to the existing incoming values. */
     vsop_sph_coords output = vsc;
@@ -382,26 +383,23 @@
 	static_set = true;
 	l1 = -d_to_r(dms_to_d(0, 0, 0.09033));
 	l2 = d_to_r(dms_to_d(0, 0, 0.03916));
+
 	terms[0] = 0.0;
 	terms[1] = d_to_r(1.397);
 	terms[2] = d_to_r(0.00031);
     }
 
-    double T = 0;
-    if(output.vh.version == hel_sph_date) {
-      T = jd_to_jcent(vsc.jd) / 10.0;
-    } else {
-      T = 0.0;
-    }
+    double T = (output.vh.version == hel_sph_date) ? (jd_to_jcent(output.jd) / 10.0) : 0.0;
     double L1 = vsc.sc.L - polynomial(terms, 3, T);
     double cosL1 = cos(L1);
     double sinL1 = sin(L1);
 
-    double deltaL = l1 + (l2 * (cosL1 + sinL1) * tan(vsc.sc.B));
+    double deltaL = l1 + (l2 * (cosL1 + sinL1) * tan(output.sc.B));
     double deltaB = l2 * (cosL1 - sinL1);
 
     output.sc.L += deltaL;
     output.sc.B += deltaB;
+
     return output;
 }
 

Modified: branches/new-vsop-prepare/src/c/tests/validate_meeus.c
===================================================================
--- branches/new-vsop-prepare/src/c/tests/validate_meeus.c	2006-01-29 19:00:41 UTC (rev 234)
+++ branches/new-vsop-prepare/src/c/tests/validate_meeus.c	2006-01-30 10:35:58 UTC (rev 235)
@@ -115,7 +115,7 @@
     vsop_handle vh;
     if (0 == get_vsop_data_handle(planet, hel_sph_date, &vh)) {
 	vsop_sph_coords vsc =
-	    vsop_sph_vsop_to_fk5(vsop_get_spherical(vh, jd));
+	    vsop_sph_to_fk5(vsop_get_spherical(vh, jd));
 	if (vsc.error_state != 0) {
 	    printf("Error calculating spherical coordinates: %d\n",
 		   vsc.error_state);
@@ -754,10 +754,10 @@
 	  report("radius", vsc.sc.R * km_per_au, 0.99760775 * km_per_au, 150.0,
 		 "km");
 
-	  vsc = vsop_sph_vsop_to_fk5(vsc);
+	  vsc = vsop_sph_to_fk5(vsc);
 
 	  report("corrected fk5 longitude", r_to_d(vsc.sc.L) * 3600,
-		 199.907347 * 3600, 1.0, "arc-seconds");
+		 199.907347 * 3600, 0.1, "arc-seconds");
 	  report("corrected fk5 latitude", r_to_d(vsc.sc.B) * 3600, 0.644 - 0.023,
 		 0.1, "arc-seconds");
 
@@ -797,58 +797,53 @@
 
     printf("26.a Rectangular coordinates of the Sun\n");
     {
-        printf("This code appears to have all sorts of problems matching Meeus exactly.  I think it's because Meeus uses non-complete VSOP data in the example, though he doesn't say.");
+        printf("This code appears to have all sorts of problems matching Meeus exactly.  I think it's because Meeus uses non-complete VSOP data in the example, though he doesn't say clearly.\n");
 	double jd = 2448908.5;
 
 	printf("\t- Calculating rectangular coordinates directly:\n");
 	vsop_handle vh;
 	if(0 == get_vsop_data_handle(vsop_earth, hel_rec_date, &vh)) {
-	  vsop_rec_coords vrc = vsop_rec_sol(vsop_rec_vsop_to_fk5(vsop_get_rectangular(vh, jd)));
-	  printf("Error value of vrc is: %d", vrc.error_state);
-	  report("aX", vrc.rc.x * km_per_au, -0.9379952 * km_per_au, 1.0, "km");
-	  report("aY", vrc.rc.y * km_per_au, -0.3116544 * km_per_au, 1.0, "km");
-	  report("aZ", vrc.rc.z * km_per_au, -0.1351215 * km_per_au, 1.0, "km");
+	  vsop_rec_coords vrc = vsop_rec_sol(vsop_rec_to_fk5(vsop_get_rectangular(vh, jd)));
+	  printf("Error value of vrc is: %d\n", vrc.error_state);
+	  report("rec-X", vrc.rc.x * km_per_au, -0.9379952 * km_per_au, 1.0, "km");
+	  report("rec-Y", vrc.rc.y * km_per_au, -0.3116544 * km_per_au, 1.0, "km");
+	  report("rec-Z", vrc.rc.z * km_per_au, -0.1351215 * km_per_au, 1.0, "km");
 	  
 	} else {
 	  printf("Problem getting a data handle.\n");
 	}
 
+/* 	double L, B, R; */
+/* 	sol_dimension3_fk5(jd, &L, &B, &R); */
 
+/* 	/\* VSOP calculates slightly different values from the book, so */
+/* 	   L, B and R will, here, be overridden from those stated on */
+/* 	   p172. *\/ */
+/* /\* 	L = d_to_r(199.907347); *\/ */
+/* /\* 	B = d_to_r(dms_to_d(0, 0, 0.62)); *\/ */
+/* /\* 	R = 0.99760775; *\/ */
 
-	double L, B, R;
-	sol_dimension3_fk5(jd, &L, &B, &R);
+/* 	double E = obliquity_hi(jd); */
+/* 	rec_coords rc = sol_rectangular(L, B, R, E); */
+/* 	report("aX", rc.x * km_per_au, -0.9379952 * km_per_au, 5.0, "km"); */
+/* 	report("aY", rc.y * km_per_au, -0.3116544 * km_per_au, 5.0, "km"); */
+/* 	report("aZ", rc.z * km_per_au, -0.1351215 * km_per_au, 5.0, "km"); */
 
-	/* VSOP calculates slightly different values from the book, so
-	   L, B and R will, here, be overridden from those stated on
-	   p172. */
-/* 	L = d_to_r(199.907347); */
-/* 	B = d_to_r(dms_to_d(0, 0, 0.62)); */
-/* 	R = 0.99760775; */
-
-	double E = obliquity_hi(jd);
-	rec_coords rc = sol_rectangular(L, B, R, E);
-	report("aX", rc.x * km_per_au, -0.9379952 * km_per_au, 5.0, "km");
-	report("aY", rc.y * km_per_au, -0.3116544 * km_per_au, 5.0, "km");
-	report("aZ", rc.z * km_per_au, -0.1351215 * km_per_au, 5.0, "km");
-
-
-
-/* 	vsop_handle vh; */
 	int result;
 	if (0 !=
 	    (result =
 	     get_vsop_data_handle(vsop_earth, hel_sph_date, &vh))) {
 	    printf("Problem opening file: %s", strerror(result));
 	} else {
-	    vsop_sph_coords vsc =
-		vsop_sph_vsop_to_fk5(vsop_get_spherical(vh, jd));
+	    vsop_sph_coords vsc = vsop_get_spherical(vh, jd);
 
-	    double E = obliquity_hi(jd);
+	    vsc = vsop_sph_to_fk5(vsc);
 
-	    printf("L=%.12f B=%.12f R=%.12f E=%.12f\n", vsc.sc.L, vsc.sc.B, vsc.sc.R, E);
+	    double obl = obliquity_hi(jd);
 
 	    rec_coords rc =
-		sol_rectangular(vsc.sc.L, vsc.sc.B, vsc.sc.R, E);
+		sol_rectangular(vsc.sc.L, vsc.sc.B, vsc.sc.R, obl);
+
 	    report("X", -rc.x * km_per_au, -0.9379952 * km_per_au, 5.0,
 		   "km");
 	    report("Y", -rc.y * km_per_au, -0.3116544 * km_per_au, 5.0,
@@ -856,9 +851,9 @@
 	    report("Z", -rc.z * km_per_au, -0.1351215 * km_per_au, 5.0,
 		   "km");
 
-	    report("X", -rc.x, -0.9379952, 1e-9, "au");
-	    report("Y", -rc.y, -0.3116544, 1e-9, "au");
-	    report("Z", -rc.z, -0.1351215, 1e-9, "au");
+	    report("lX", -rc.x, -0.9379952, 1e-9, "au");
+	    report("lY", -rc.y, -0.3116544, 1e-9, "au");
+	    report("lZ", -rc.z, -0.1351215, 1e-9, "au");
 
 	}
 
@@ -1037,7 +1032,7 @@
 	    printf("Problem opening file: %s", strerror(result));
 	} else {
 	    vsop_sph_coords vsc =
-		vsop_sph_vsop_to_fk5(vsop_get_spherical(vh, jd));
+		vsop_sph_to_fk5(vsop_get_spherical(vh, jd));
 
 	    double E = obliquity_hi(jd);
 	    rec_coords src =
@@ -1200,7 +1195,7 @@
 	    vsop_handle vh;
 	    get_vsop_data_handle(vsop_earth, hel_sph_j2, &vh);
 	    vsop_sph_coords vsc =
-		vsop_sph_vsop_to_fk5(vsop_get_spherical(vh, test->jd));
+		vsop_sph_to_fk5(vsop_get_spherical(vh, test->jd));
 
 	    double E = obliquity_hi(test->jd);
 	    vsc.sc.L = modpi2(vsc.sc.L + pi);
@@ -1317,7 +1312,7 @@
 		printf("\t\tError loading Earth handle.\n");
 	    } else {
 		double jd = 2448170.5;
-		vsop_rec_coords vrc = vsop_rec_sol(vsop_rec_vsop_to_fk5(vsop_get_rectangular(vh, jd)));
+		vsop_rec_coords vrc = vsop_rec_sol(vsop_rec_to_fk5(vsop_get_rectangular(vh, jd)));
 
 		report("X", vrc.rc.x * km_per_au,
 		       -0.975673220683 * km_per_au, 1.0e-4, "km");
@@ -1336,7 +1331,7 @@
 /* 	  } else { */
 /* 	    vsop_sph_coords vsc = vsop_get_spherical(vh, 2448976.5); */
 /* 	    /\* */
-/* 	    vsc = vsop_sph_vsop_to_fk5(vsc); */
+/* 	    vsc = vsop_sph_to_fk5(vsc); */
 /* 	    *\/ */
 /* 	    report("longitude", r_to_d(modpi2(vsc.sc.L)) * 3600, 26.11428 * 3600, 0.001, "arc-seconds"); */
 /* 	    report("latitude", r_to_d(vsc.sc.B) * 3600, -2.62070 * 3600, 0.001, "arc-seconds"); */



From izogi at berlios.de  Mon Jan 30 21:38:47 2006
From: izogi at berlios.de (izogi at BerliOS)
Date: Mon, 30 Jan 2006 21:38:47 +0100
Subject: [Ephemeritis-svn] r236 - branches/new-vsop-prepare/src/c/libephemeritis
Message-ID: <200601302038.k0UKcl3l002159@sheep.berlios.de>

Author: izogi
Date: 2006-01-30 21:38:46 +0100 (Mon, 30 Jan 2006)
New Revision: 236

Modified:
   branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c
Log:
Minor bug-removal -- by preventing vsop_rec_to_fk5() from rotating non-J2 coordinates.


Modified: branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c	2006-01-30 10:35:58 UTC (rev 235)
+++ branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c	2006-01-30 20:38:46 UTC (rev 236)
@@ -193,7 +193,9 @@
     /* Check that the incoming coordinates are of a version designed to be rotated. */
     if (!
 	(output.vh.version == hel_rec_j2
+	 /*
 	 || output.vh.version == hel_rec_date
+	 */
 	 || output.vh.version == bar_rec_j2)) {
 	output.error_state = -3;
 	return output;



From izogi at berlios.de  Mon Jan 30 22:13:17 2006
From: izogi at berlios.de (izogi at BerliOS)
Date: Mon, 30 Jan 2006 22:13:17 +0100
Subject: [Ephemeritis-svn] r237 - in branches/new-vsop-prepare/src/c: libephemeritis tests
Message-ID: <200601302113.k0ULDHGX005832@sheep.berlios.de>

Author: izogi
Date: 2006-01-30 22:13:16 +0100 (Mon, 30 Jan 2006)
New Revision: 237

Modified:
   branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis.h
   branches/new-vsop-prepare/src/c/libephemeritis/equinox.c
   branches/new-vsop-prepare/src/c/tests/validate_meeus.c
Log:
Tidied up test 26.a, having it report_diff() instead of report().
Added a couple of comments to equinox.c, noting that it wasn't yet compatible with the new VSOP routines.


Modified: branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis.h
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis.h	2006-01-30 20:38:46 UTC (rev 236)
+++ branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis.h	2006-01-30 21:13:16 UTC (rev 237)
@@ -288,7 +288,6 @@
 			 double *radius);
 void vsop_to_fk5(double jd, double *L, double *B);
 
-
 /* elliptical.c */
 
 /*! @brief The type of magnitude-calculation data provided for an orbital element.

Modified: branches/new-vsop-prepare/src/c/libephemeritis/equinox.c
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/equinox.c	2006-01-30 20:38:46 UTC (rev 236)
+++ branches/new-vsop-prepare/src/c/libephemeritis/equinox.c	2006-01-30 21:13:16 UTC (rev 237)
@@ -224,6 +224,12 @@
  *  @return           Julian Day of the event in dynamical time.
  *                    Returns -5 if too much accuracy was required.
  *
+ *  @todo Make it work with new VSOP routines.  (Note that it needs to
+ *  fit elegantly with vsop_data_init() and vsop_data_cleanup().
+ *
+ *  @bug -5 is a BAD way to return an error when it might be confused
+ *  with a Julian Date.
+ *
  *  @sa dynamical::deltaT_seconds for calculating %dynamical time offset.
  *  @sa dynamical::dt_to_ut
  */
@@ -256,6 +262,7 @@
     int i;
     for (i = 0; i < 20; i++) {
 	const double jd0 = jd;
+
 	double L, B, R;
 	sol_dimension3_vsop(jd, &L, &B, &R);
 	L += nut_in_lon(jd) + aberration_low(R);

Modified: branches/new-vsop-prepare/src/c/tests/validate_meeus.c
===================================================================
--- branches/new-vsop-prepare/src/c/tests/validate_meeus.c	2006-01-30 20:38:46 UTC (rev 236)
+++ branches/new-vsop-prepare/src/c/tests/validate_meeus.c	2006-01-30 21:13:16 UTC (rev 237)
@@ -79,7 +79,7 @@
 void report_diff(const char label[], double computed, double reference,
 		 const char units[])
 {
-    printf("%s%s\n", tab, label);
+  printf("%s%s:%s", tab, label, tab);
     printf("%s%sDifference: %f %s\n", tab, tab, computed - reference,
 	   units);
 }
@@ -757,9 +757,9 @@
 	  vsc = vsop_sph_to_fk5(vsc);
 
 	  report("corrected fk5 longitude", r_to_d(vsc.sc.L) * 3600,
-		 199.907347 * 3600, 0.1, "arc-seconds");
+		 199.907347 * 3600, 0.5, "arc-seconds");
 	  report("corrected fk5 latitude", r_to_d(vsc.sc.B) * 3600, 0.644 - 0.023,
-		 0.1, "arc-seconds");
+		 0.5, "arc-seconds");
 
 
 	  printf
@@ -800,19 +800,22 @@
         printf("This code appears to have all sorts of problems matching Meeus exactly.  I think it's because Meeus uses non-complete VSOP data in the example, though he doesn't say clearly.\n");
 	double jd = 2448908.5;
 
-	printf("\t- Calculating rectangular coordinates directly:\n");
-	vsop_handle vh;
-	if(0 == get_vsop_data_handle(vsop_earth, hel_rec_date, &vh)) {
-	  vsop_rec_coords vrc = vsop_rec_sol(vsop_rec_to_fk5(vsop_get_rectangular(vh, jd)));
-	  printf("Error value of vrc is: %d\n", vrc.error_state);
-	  report("rec-X", vrc.rc.x * km_per_au, -0.9379952 * km_per_au, 1.0, "km");
-	  report("rec-Y", vrc.rc.y * km_per_au, -0.3116544 * km_per_au, 1.0, "km");
-	  report("rec-Z", vrc.rc.z * km_per_au, -0.1351215 * km_per_au, 1.0, "km");
+/* 	printf("\t- Calculating rectangular coordinates directly:\n"); */
+/* 	vsop_handle vh; */
+/* 	if(0 == get_vsop_data_handle(vsop_earth, hel_rec_date, &vh)) { */
+/* 	  vsop_rec_coords vrc = vsop_rec_sol(vsop_rec_to_fk5(vsop_get_rectangular(vh, jd))); */
+/* 	  printf("Error value of vrc is: %d\n", vrc.error_state); */
+/* 	  report_diff("rec-X", vrc.rc.x * km_per_au, -0.9379952 * km_per_au, "km"); */
+/* 	  report_diff("rec-Y", vrc.rc.y * km_per_au, -0.3116544 * km_per_au, "km"); */
+/* 	  report_diff("rec-Z", vrc.rc.z * km_per_au, -0.1351215 * km_per_au, "km"); */
 	  
-	} else {
-	  printf("Problem getting a data handle.\n");
-	}
+/* 	} else { */
+/* 	  printf("Problem getting a data handle.\n"); */
+/* 	} */
 
+
+
+
 /* 	double L, B, R; */
 /* 	sol_dimension3_fk5(jd, &L, &B, &R); */
 
@@ -830,6 +833,7 @@
 /* 	report("aZ", rc.z * km_per_au, -0.1351215 * km_per_au, 5.0, "km"); */
 
 	int result;
+	vsop_handle vh;
 	if (0 !=
 	    (result =
 	     get_vsop_data_handle(vsop_earth, hel_sph_date, &vh))) {
@@ -844,16 +848,13 @@
 	    rec_coords rc =
 		sol_rectangular(vsc.sc.L, vsc.sc.B, vsc.sc.R, obl);
 
-	    report("X", -rc.x * km_per_au, -0.9379952 * km_per_au, 5.0,
-		   "km");
-	    report("Y", -rc.y * km_per_au, -0.3116544 * km_per_au, 5.0,
-		   "km");
-	    report("Z", -rc.z * km_per_au, -0.1351215 * km_per_au, 5.0,
-		   "km");
+	    report_diff("X", -rc.x * km_per_au, -0.9379952 * km_per_au, "km");
+	    report_diff("Y", -rc.y * km_per_au, -0.3116544 * km_per_au, "km");
+	    report_diff("Z", -rc.z * km_per_au, -0.1351215 * km_per_au, "km");
 
-	    report("lX", -rc.x, -0.9379952, 1e-9, "au");
-	    report("lY", -rc.y, -0.3116544, 1e-9, "au");
-	    report("lZ", -rc.z, -0.1351215, 1e-9, "au");
+/* 	    report("lX", -rc.x, -0.9379952, 1e-9, "au"); */
+/* 	    report("lY", -rc.y, -0.3116544, 1e-9, "au"); */
+/* 	    report("lZ", -rc.z, -0.1351215, 1e-9, "au"); */
 
 	}
 



From izogi at berlios.de  Tue Jan 31 02:43:14 2006
From: izogi at berlios.de (izogi at BerliOS)
Date: Tue, 31 Jan 2006 02:43:14 +0100
Subject: [Ephemeritis-svn] r238 - in branches/new-vsop-prepare/src/c: libephemeritis tests
Message-ID: <200601310143.k0V1hEVk012951@sheep.berlios.de>

Author: izogi
Date: 2006-01-31 02:43:01 +0100 (Tue, 31 Jan 2006)
New Revision: 238

Modified:
   branches/new-vsop-prepare/src/c/libephemeritis/elliptical.c
   branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis.h
   branches/new-vsop-prepare/src/c/libephemeritis/solar.c
   branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c
   branches/new-vsop-prepare/src/c/tests/validate_meeus.c
Log:
Replaced sol_rectangular() with sol_sph_to_rec(), which cnverts spherical to rectangular for j2000 and date.
More adjustments to tests in validate_meeus for correct use.


Modified: branches/new-vsop-prepare/src/c/libephemeritis/elliptical.c
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/elliptical.c	2006-01-30 21:13:16 UTC (rev 237)
+++ branches/new-vsop-prepare/src/c/libephemeritis/elliptical.c	2006-01-31 01:43:01 UTC (rev 238)
@@ -548,7 +548,7 @@
 
     double R = sqrt(sol.x * sol.x + sol.y * sol.y + sol.z * sol.z);
     *elongation =
-	acos((R * R + r_e * r_e - r_sun * r_sun) / (2 * R * r_e));
+      acos( ( (R*R) + (r_e*r_e) - (r_sun*r_sun)) / (2*R*r_e) );
     *phase_angle =
 	acos((r_sun * r_sun + r_e * r_e - R * R) / (2 * r_sun * r_e));
 }

Modified: branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis.h
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis.h	2006-01-30 21:13:16 UTC (rev 237)
+++ branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis.h	2006-01-31 01:43:01 UTC (rev 238)
@@ -422,7 +422,7 @@
 void longitude_radius_low(double jd, double *L, double *R);
 double apparent_longitude_low(double jd, double L);
 double aberration_low(double R);
-rec_coords sol_rectangular(double L, double B, double R, double obl);
+/* rec_coords sol_rectangular(double L, double B, double R, double obl); */
 
 
 /* constellations.c */
@@ -503,10 +503,11 @@
 
 				            0 indicates no error.
 				            -1 (vsop_get_rectangular) indicates a vsop_handle error.  (Data referenced by this handle wasn't found - perhaps it was unloaded.)
-				            -2 (vsop_get_rectangular) indicates that a vsop_handle referenced data that wasn't rectangular, or otherwise not suitable for providing rectangular coordinates.
+				            -2 (vsop_get_rectangular, sol_sph_to_rec) indicates that a vsop_handle referenced data that wasn't rectangular, or otherwise not suitable for providing rectangular coordinates.
 				            -3 (vsop_rec_vsop_to_fk5) indicates that supplied coordinates were unsuitable for converting to FK5.
 					    -4 (vsop_rec_sol) indicates that supplied coordinates were not Earth coordinates, and therefore unsuitable for converting to solar coordinates.  Note that even if the input planet is vsop_earth, is_inverted must be set to 0 or this error will be returned.
 					    -5 (vsop_rec_sol) indicates that supplied coordinates were not rectangular J2000 or date coordinates.
+					    -6 (sol_sph_to_rec) indicates that the incoming spherical coordinates were not solar coordinates.
 				 */
 } vsop_rec_coords;
 
@@ -536,10 +537,11 @@
 
 				   0 indicates no error.
 				   -1 (vsop_get_spherical) indicates a vsop_handle error.  (Data referenced by this handle wasn't found - perhaps it was unloaded.)
-				   -2 (vsop_get_spherical) indicates that a vsop_handle referenced data that wasn't spherical, or otherwise not suitable for providing spherical coordinates.  (This should really only happen if the data in the struct has been corrupted somehow.)
+				   -2 (vsop_get_spherical, sol_sph_to_rec) indicates that a vsop_handle referenced data that wasn't spherical, or otherwise not suitable for providing spherical coordinates.  (This should really only happen if the data in the struct has been corrupted somehow.)
 				   -3 (vsop_sph_vsop_to_fk5) indicates that supplied coordinates were unsuitable for converting to FK5.
 				   -4 (vsop_sph_sol) indicates that supplied coordinates were not Earth coordinates, and therefore unsuitable for converting to solar coordinates.  Note that even if the input planet is vsop_earth, is_inverted must be set to 0 or this error will be returned.
 				   -5 (vsop_sph_sol) indicates that supplied coordinates were not rectangular J2000 or date coordinates.
+				   -6 (sol_sph_to_rec) indicates that the incoming spherical coordinates were not solar coordinates.
 				 */
 } vsop_sph_coords;
 
@@ -559,5 +561,6 @@
 vsop_sph_coords vsop_sph_to_fk5(const vsop_sph_coords vsc);
 vsop_sph_coords vsop_sph_sol(const vsop_sph_coords earth_vsc);
 
+vsop_rec_coords sol_sph_to_rec(vsop_sph_coords vsc);
 
 #endif

Modified: branches/new-vsop-prepare/src/c/libephemeritis/solar.c
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/solar.c	2006-01-30 21:13:16 UTC (rev 237)
+++ branches/new-vsop-prepare/src/c/libephemeritis/solar.c	2006-01-31 01:43:01 UTC (rev 238)
@@ -39,8 +39,8 @@
 #include <math.h>
 
 
-/*! @brief Returns geometric longitude and radius vector, low
- *  precision.
+/*! @brief Returns geometric longitude and radius vector of the Sun,
+ *  low precision.
  *
  *  The longitude is accurate to 0.01 degree.  The latitude should be
  *  presumed to be 0.0. [Meeus-1998: equations 25.2 through 25.5.]
@@ -80,7 +80,8 @@
     *R = 1.000001018 * (1 - e * e) / (1 + e * cos(v));
 }
 
-/*! @brief Corrects the geometric longitude for nutation and aberration.
+/*! @brief Corrects the geometric longitude of the Sun for nutation
+ *  and aberration.
  *
  *  Low precision. [Meeus-1998: pg 164]
  *
@@ -150,20 +151,20 @@
  *
  *  @author Mike McGavin.
  */
-rec_coords sol_rectangular(double L, double B, double R, double obl)
-{
-    double cosL = cos(L);
-    double cosB = cos(B);
-    double sinL = sin(L);
-    double sinB = sin(B);
-    double sinobl = sin(obl);
-    double cosobl = cos(obl);
-    rec_coords rc;
-    rc.x = R * (cosB * cosL);
-    rc.y = R * ((cosB * sinL * cosobl) - (sinB * sinobl));
-    rc.z = R * ((cosB * sinL * sinobl) + (sinB * cosobl));
-    return rc;
-}
+/* rec_coords sol_rectangular(double L, double B, double R, double obl) */
+/* { */
+/*     double cosL = cos(L); */
+/*     double cosB = cos(B); */
+/*     double sinL = sin(L); */
+/*     double sinB = sin(B); */
+/*     double sinobl = sin(obl); */
+/*     double cosobl = cos(obl); */
+/*     rec_coords rc; */
+/*     rc.x = R * (cosB * cosL); */
+/*     rc.y = R * ((cosB * sinL * cosobl) - (sinB * sinobl)); */
+/*     rc.z = R * ((cosB * sinL * sinobl) + (sinB * cosobl)); */
+/*     return rc; */
+/* } */
 
 /*! @brief Returns one of geocentric ecliptic longitude,
  *  latitude and radius as VSOP coordinates.

Modified: branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c	2006-01-30 21:13:16 UTC (rev 237)
+++ branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c	2006-01-31 01:43:01 UTC (rev 238)
@@ -470,3 +470,76 @@
     output = vsop_sph_invert(output);
     return output;
 }
+
+
+
+/*! @brief Converts spherical geocentric coordinates of the Sun to
+ *  rectangular geocentric coordinates of the Sun.
+ *
+ *  [Meeus-1998: equation 26.1 and 26.2.]  (26.1 is a more general
+ *  form of 26.2.)
+ *
+ *  This function requires the spherical geometric coordinates of the
+ *  Sun.  These can be provided for either the ecliptic and equinox of
+ *  J2000, or for the ecliptic and equinox of the date.  When provided
+ *  for the date, the obliquity of the ecliptic for that date is
+ *  calculated using high precision (obliquity_hi).
+ *
+ *  @param[in]  vsc  Geometric spherical coordinates of the Sun.
+ *
+ *  @return The geometric rectangular coordinates of the Sun.
+ *
+ *  @note Meeus provides formula 26.2 for converting to rectangular
+ *  coordinates in J2000, which places obliquity of the ecliptic at 0.
+ *  This doesn't seem to work for the standard VSOP data provided in
+ *  J2000, though, possibly (but not definitely) because Meeus'
+ *  appendix data is engineered a little differently.  Instead, the
+ *  obliquity at epoch 2000.0 is used in Meeus' original 26.1 formula,
+ *  and this appears to work fine.
+ *
+ *  @todo Make more efficient -- in the current state, obliquity is
+ *  possibly being calculated for 2 dates instead of just the one
+ *  required.
+ *
+ *  @author Mike McGavin.
+ */
+vsop_rec_coords sol_sph_to_rec(vsop_sph_coords vsc)
+{
+  vsop_rec_coords vrc;
+  memset(&vrc, '\0', sizeof(vrc));
+  vrc.vh = vsc.vh;
+  vrc.jd = vsc.jd;
+  vrc.is_inverted = vsc.is_inverted;
+  vrc.error_state = vsc.error_state;
+
+  /* Bail out now if things are in an error state. */
+  if(0 != vrc.error_state) {
+    return vrc;
+  }
+
+  /* Make sure these are spherical coordinates for j2 or the date. */
+  if(!(hel_sph_j2 == vrc.vh.version || hel_sph_date == vrc.vh.version)) {
+    vrc.error_state = -2;
+    return vrc;
+  }
+
+  /* Make sure these are geometric solar coordinates.  (ie. Inverted Earth.) */
+  if(!(vsop_earth == vrc.vh.planet && vrc.is_inverted)) {
+    vrc.error_state = -6;
+    return vrc;
+  }
+
+  double obl = vrc.vh.version == hel_sph_j2 ? obliquity_hi(je_to_jd(2000.0)) : obliquity_hi(vrc.jd);
+
+  double cosL = cos(vsc.sc.L);
+  double cosB = cos(vsc.sc.B);
+  double sinL = sin(vsc.sc.L);
+  double sinB = sin(vsc.sc.B);
+  double sinobl = sin(obl);
+  double cosobl = cos(obl);
+  
+  vrc.rc.x = vsc.sc.R * (cosB * cosL);
+  vrc.rc.y = vsc.sc.R * ((cosB * sinL * cosobl) - (sinB * sinobl));
+  vrc.rc.z = vsc.sc.R * ((cosB * sinL * sinobl) + (sinB * cosobl));
+  return vrc;
+}

Modified: branches/new-vsop-prepare/src/c/tests/validate_meeus.c
===================================================================
--- branches/new-vsop-prepare/src/c/tests/validate_meeus.c	2006-01-30 21:13:16 UTC (rev 237)
+++ branches/new-vsop-prepare/src/c/tests/validate_meeus.c	2006-01-31 01:43:01 UTC (rev 238)
@@ -760,6 +760,7 @@
 		 199.907347 * 3600, 0.5, "arc-seconds");
 	  report("corrected fk5 latitude", r_to_d(vsc.sc.B) * 3600, 0.644 - 0.023,
 		 0.5, "arc-seconds");
+	    printf("%.10f %.10f %.10f\n", r_to_d(vsc.sc.L), r_to_d(vsc.sc.B) * 3600.0, vsc.sc.R);
 
 
 	  printf
@@ -797,41 +798,9 @@
 
     printf("26.a Rectangular coordinates of the Sun\n");
     {
-        printf("This code appears to have all sorts of problems matching Meeus exactly.  I think it's because Meeus uses non-complete VSOP data in the example, though he doesn't say clearly.\n");
+        printf("This code appears to have all sorts of problems matching Meeus exactly.\nI think it's because Meeus uses non-complete VSOP data in the example, though he doesn't say clearly.\n");
 	double jd = 2448908.5;
 
-/* 	printf("\t- Calculating rectangular coordinates directly:\n"); */
-/* 	vsop_handle vh; */
-/* 	if(0 == get_vsop_data_handle(vsop_earth, hel_rec_date, &vh)) { */
-/* 	  vsop_rec_coords vrc = vsop_rec_sol(vsop_rec_to_fk5(vsop_get_rectangular(vh, jd))); */
-/* 	  printf("Error value of vrc is: %d\n", vrc.error_state); */
-/* 	  report_diff("rec-X", vrc.rc.x * km_per_au, -0.9379952 * km_per_au, "km"); */
-/* 	  report_diff("rec-Y", vrc.rc.y * km_per_au, -0.3116544 * km_per_au, "km"); */
-/* 	  report_diff("rec-Z", vrc.rc.z * km_per_au, -0.1351215 * km_per_au, "km"); */
-	  
-/* 	} else { */
-/* 	  printf("Problem getting a data handle.\n"); */
-/* 	} */
-
-
-
-
-/* 	double L, B, R; */
-/* 	sol_dimension3_fk5(jd, &L, &B, &R); */
-
-/* 	/\* VSOP calculates slightly different values from the book, so */
-/* 	   L, B and R will, here, be overridden from those stated on */
-/* 	   p172. *\/ */
-/* /\* 	L = d_to_r(199.907347); *\/ */
-/* /\* 	B = d_to_r(dms_to_d(0, 0, 0.62)); *\/ */
-/* /\* 	R = 0.99760775; *\/ */
-
-/* 	double E = obliquity_hi(jd); */
-/* 	rec_coords rc = sol_rectangular(L, B, R, E); */
-/* 	report("aX", rc.x * km_per_au, -0.9379952 * km_per_au, 5.0, "km"); */
-/* 	report("aY", rc.y * km_per_au, -0.3116544 * km_per_au, 5.0, "km"); */
-/* 	report("aZ", rc.z * km_per_au, -0.1351215 * km_per_au, 5.0, "km"); */
-
 	int result;
 	vsop_handle vh;
 	if (0 !=
@@ -842,20 +811,18 @@
 	    vsop_sph_coords vsc = vsop_get_spherical(vh, jd);
 
 	    vsc = vsop_sph_to_fk5(vsc);
-
+	    vsc = vsop_sph_sol(vsc);
+	    /*
 	    double obl = obliquity_hi(jd);
+	    */
+	    report_diff("L", r_to_d(vsc.sc.L) * 3600.0, 199.907347 * 3600.0, "arc-seconds");
+	    report_diff("B", r_to_d(vsc.sc.B) * 3600.0, dms_to_d(0,0,0.62) * 3600.0, "arc-seconds");
+	    report_diff("R", vsc.sc.R * km_per_au, 0.99760775 * km_per_au, "km");
 
-	    rec_coords rc =
-		sol_rectangular(vsc.sc.L, vsc.sc.B, vsc.sc.R, obl);
-
-	    report_diff("X", -rc.x * km_per_au, -0.9379952 * km_per_au, "km");
-	    report_diff("Y", -rc.y * km_per_au, -0.3116544 * km_per_au, "km");
-	    report_diff("Z", -rc.z * km_per_au, -0.1351215 * km_per_au, "km");
-
-/* 	    report("lX", -rc.x, -0.9379952, 1e-9, "au"); */
-/* 	    report("lY", -rc.y, -0.3116544, 1e-9, "au"); */
-/* 	    report("lZ", -rc.z, -0.1351215, 1e-9, "au"); */
-
+	    vsop_rec_coords vrc = sol_sph_to_rec(vsc);
+	    report_diff("X", vrc.rc.x * km_per_au, -0.9379952 * km_per_au, "km");
+	    report_diff("Y", vrc.rc.y * km_per_au, -0.3116544 * km_per_au, "km");
+	    report_diff("Z", vrc.rc.z * km_per_au, -0.1351215 * km_per_au, "km");
 	}
 
     }
@@ -1032,31 +999,23 @@
 	    (result = get_vsop_data_handle(vsop_earth, hel_sph_j2, &vh))) {
 	    printf("Problem opening file: %s", strerror(result));
 	} else {
-	    vsop_sph_coords vsc =
-		vsop_sph_to_fk5(vsop_get_spherical(vh, jd));
+/* 	    vsop_rec_coords vrc = vsop_rec_to_fk5(vsop_rec_sol(vsop_get_rectangular(vh, jd))); */
+/* 	    /\* */
+/* 	    double E = obliquity_hi(jd); */
+/* 	    *\/ */
+/* 	    rec_coords src = vrc.rc; */
 
-	    double E = obliquity_hi(jd);
-	    rec_coords src =
-		sol_rectangular(vsc.sc.L, vsc.sc.B, vsc.sc.R, E);
-	    src.x = -src.x;
-	    src.y = -src.y;
-	    src.z = -src.z;
+	    vsop_sph_coords vsc = vsop_sph_to_fk5(vsop_sph_sol(vsop_get_spherical(vh, jd)));
+	    vsop_rec_coords vrc = sol_sph_to_rec(vsc);
+	    rec_coords src = vrc.rc;
 
-/* 	double L, B, R; */
-/* 	sol_dimension3_fk5(jd, &L, &B, &R); */
-/* 	rec_coords src = sol_rectangular(L, B, R, obl2000); */
-	    report("solar x", src.x * km_per_au, -0.9756732 * km_per_au,
-		   800, "km");
-	    report("solar y", src.y * km_per_au, -0.2003254 * km_per_au,
-		   800, "km");
-	    report("solar z", src.z * km_per_au, -0.0868566 * km_per_au,
-		   800, "km");
+	    report("solar x", src.x * km_per_au, -0.9756732 * km_per_au, 0.0000001 * km_per_au,
+		   "km");
+	    report("solar y", src.y * km_per_au, -0.2003254 * km_per_au, 0.0000001 * km_per_au,
+		   "km");
+	    report("solar z", src.z * km_per_au, -0.0868566 * km_per_au, 0.0000001 * km_per_au,
+		   "km");
 
-/* 	printf("Resetting sol values to those in example (because VSOP isn't calculating them properly as above)\n"); */
-/* 	src.x = -0.9756732; */
-/* 	src.y = -0.2003254; */
-/* 	src.z = -0.0868566; */
-
 	    double ra, dec, elongation, phase_angle, body_r_earth;
 	    elliptical_orbit_ecliptical(src, rc, r_sun, &ra, &dec,
 					&elongation, &phase_angle,
@@ -1081,10 +1040,10 @@
 
 	    report("recalc-delta-earth", body_r_earth, 0.8242811, 0.000001,
 		   "AU");
-	    report("ra", ra, d_to_r(158.558965), 0.00001, "radians");
-	    report("dec", dec, d_to_r(19.158496), 0.00001, "radians");
-	    report("elongation", elongation, d_to_r(40.51), 0.00001,
-		   "radians");
+	    report("ra", r_to_d(ra) * 3600.0, 158.558965 * 3600.0, 0.01, "arc-seconds");
+	    report("dec", r_to_d(dec) * 3600.0, 19.158496 * 3600.0, 0.01, "arc-seconds");
+	    report("elongation", r_to_d(elongation), 40.51, 0.01,
+		   "degrees");
 	}
 
     }
@@ -1192,25 +1151,20 @@
 	    orbit_s *or = test->orbit;
 	    printf("Testing %s, test %d\n", or->name, o);
 
-
 	    vsop_handle vh;
 	    get_vsop_data_handle(vsop_earth, hel_sph_j2, &vh);
 	    vsop_sph_coords vsc =
-		vsop_sph_to_fk5(vsop_get_spherical(vh, test->jd));
+	      vsop_sph_sol(vsop_sph_to_fk5(vsop_get_spherical(vh, test->jd)));
+	    vsop_rec_coords vrc = sol_sph_to_rec(vsc);
+	    rec_coords sun_rec = vrc.rc;
 
-	    double E = obliquity_hi(test->jd);
-	    vsc.sc.L = modpi2(vsc.sc.L + pi);
-	    vsc.sc.B = -vsc.sc.B;
-	    rec_coords sun_rec =
-		sol_rectangular(vsc.sc.L, vsc.sc.B, vsc.sc.R, E);
-
-
-
 	    /*
-	       double L, B, R;
-	       sol_dimension3_fk5(test->jd, &L, &B, &R);
-	       rec_coords sun_rec = sol_rectangular(L, B, R, obliquity_hi(je_to_jd(2000)));
-	     */
+	    vsop_handle vh2;
+	    get_vsop_data_handle(vsop_earth, hel_rec_j2, &vh2);
+	    vsop_rec_coords vrc =
+	      vsop_rec_to_fk5(vsop_rec_sol(vsop_get_rectangular(vh2, test->jd)));
+	    rec_coords sun_rec = vrc.rc;
+	    */
 
 	    double ra;
 	    double dec;
@@ -1261,8 +1215,7 @@
 	     *   correct for precession.
 	     *   correct for aberration.
 	     */
-
-	    /* Adjust for nutation. */
+	    /*
 	    double a_in_ra, a_in_dec;
 	    aberration_in_ra_dec_low(test->jd, ra, dec,
 				     obliquity_hi(test->jd), vsc.sc.L,
@@ -1280,50 +1233,54 @@
 			  &n_in_ra, &n_in_dec);
 	    ra += n_in_ra;
 	    dec += n_in_dec;
+	    */
 
-
-
+	    /*
 	    printf("$$$$ %f:%f $$$$\n",
 		   (n_in_ra * (360.0 * 60.0 * 60.0) / (2 * pi)),
 		   (n_in_dec * (360.0 * 60.0 * 60.0) / (2 * pi)));
 	    printf("$$$$ %f:%f $$$$\n",
 		   (a_in_ra * (360.0 * 60.0 * 60.0) / (2 * pi)),
 		   (a_in_dec * (360.0 * 60.0 * 60.0) / (2 * pi)));
+	    */
 
-	    report("RA", (ra * (360.0 * 60.0 * 60.0) / (2 * pi)),
-		   (test->ra * (360.0 * 60.0 * 60.0) / (2 * pi)), 0.00030,
+	    report_diff("RA              ", r_to_d(ra) * 3600,
+			r_to_d(test->ra) * 3600,
 		   "arc-sec");
-	    report("Declination", (dec * (360.0 * 60.0 * 60.0) / (2 * pi)),
-		   (test->dec * (360.0 * 60.0 * 60.0) / (2 * pi)), 0.00030,
+	    report_diff("Declination     ", (dec * (360.0 * 60.0 * 60.0) / (2 * pi)),
+		   (test->dec * (360.0 * 60.0 * 60.0) / (2 * pi)),
 		   "arc-sec");
-	    report("Distance (Earth)", body_r_earth, test->r_earth,
-		   0.000001, "AU");
-	    report("Distance (Sun)", body_r_sun, test->r_sun, 0.000001,
-		   "AU");
-	    report("Magnitude", mag, test->mag, 1.0, "");
+	    report_diff("Distance (Earth)", body_r_earth * km_per_au, test->r_earth * km_per_au,
+		   "km");
+	    report_diff("Distance (Sun)  ", body_r_sun * km_per_au, test->r_sun * km_per_au,
+		   "km");
+	    report_diff("Magnitude       ", mag, test->mag, "");
 	}
     }
 
-    {
-	printf("Checking new VSOP routines\n");
-	{
-	    vsop_handle vh;
+/*     { */
+/* 	printf("Checking new VSOP routines\n"); */
+/* 	{ */
+/* 	    vsop_handle vh; */
 
-	    if (0 != get_vsop_data_handle(vsop_earth, hel_rec_j2, &vh)) {
-		printf("\t\tError loading Earth handle.\n");
-	    } else {
-		double jd = 2448170.5;
-		vsop_rec_coords vrc = vsop_rec_sol(vsop_rec_to_fk5(vsop_get_rectangular(vh, jd)));
+/* 	    if (0 != get_vsop_data_handle(vsop_earth, hel_rec_j2, &vh)) { */
+/* 		printf("\t\tError loading Earth handle.\n"); */
+/* 	    } else { */
+/* 		double jd = 2448170.5; */
+/* 		vsop_rec_coords vrc = vsop_rec_sol(vsop_rec_to_fk5(vsop_get_rectangular(vh, jd))); */
 
-		report("X", vrc.rc.x * km_per_au,
-		       -0.975673220683 * km_per_au, 1.0e-4, "km");
-		report("Y", vrc.rc.y * km_per_au,
-		       -0.200325394065 * km_per_au, 1.0e-4, "km");
-		report("Z", vrc.rc.z * km_per_au,
-		       -0.0868565820014 * km_per_au, 1.0e-4, "km");
-	    }
-	}
-    }
+/* 		report("X", vrc.rc.x * km_per_au, */
+/* 		       -0.975673220683 * km_per_au, 1.0e-4, "km"); */
+/* 		report("Y", vrc.rc.y * km_per_au, */
+/* 		       -0.200325394065 * km_per_au, 1.0e-4, "km"); */
+/* 		report("Z", vrc.rc.z * km_per_au, */
+/* 		       -0.0868565820014 * km_per_au, 1.0e-4, "km"); */
+/* 	    } */
+/* 	} */
+/*     } */
+
+
+
 /* 	{ */
 /* 	  printf("Venus spherical\n"); */
 /* 	  vsop_handle vh; */



From izogi at berlios.de  Tue Jan 31 09:07:20 2006
From: izogi at berlios.de (izogi at BerliOS)
Date: Tue, 31 Jan 2006 09:07:20 +0100
Subject: [Ephemeritis-svn] r239 - in branches/new-vsop-prepare/src/c: libephemeritis tests
Message-ID: <200601310807.k0V87K7H013630@sheep.berlios.de>

Author: izogi
Date: 2006-01-31 09:06:59 +0100 (Tue, 31 Jan 2006)
New Revision: 239

Modified:
   branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis.h
   branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c
   branches/new-vsop-prepare/src/c/tests/validate_meeus.c
Log:
Switched vsop error states to an enumerated type.


Modified: branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis.h
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis.h	2006-01-31 01:43:01 UTC (rev 238)
+++ branches/new-vsop-prepare/src/c/libephemeritis/ephemeritis.h	2006-01-31 08:06:59 UTC (rev 239)
@@ -474,6 +474,39 @@
 } vsop_version;
 
 
+/*! @brief Various error states that a VSOP-related function might
+ *  encounter.
+ */
+typedef enum {
+  ok = 0,            /*!< @brief No error state -- everything's fine. */
+  vh_access_error,   /*!< @brief (vsop_get_rectangular,
+		        vsop_get_spherical) indicates a vsop_handle
+		        error.  (Data referenced by this handle wasn't
+		        available - perhaps it was unloaded.) */
+  bad_data,          /*!< @brief (vsop_get_rectangular,
+                        vsop_get_spherical, sol_sph_to_rec) indicates
+                        that a vsop_handle referenced data that wasn't
+                        rectangular or spherical, when the function
+                        required one of those two. */
+  bad_for_fk5,       /*!< @brief (vsop_rec_to_fk5, vsop_sph_to_fk5)
+                        indicates that supplied coordinates were
+                        unsuitable for converting to FK5 by this
+                        function. */
+  not_earth,         /*!< @brief (vsop_rec_sol, vsop_sph_sol)
+                        indicates that supplied coordinates were not
+                        Earth coordinates, and therefore unsuitable
+                        for converting to solar coordinates.  Note
+                        that even if the input planet is vsop_earth,
+                        is_inverted must be set to 0 or this error
+                        will be returned. */
+  wrong_source,      /*!< @brief (vsop_rec_sol, vsop_sph_sol)
+                        indicates that supplied coordinates were not
+                        rectangular J2000 or date coordinates. */
+  not_solar          /*!< @brief (sol_sph_to_rec) indicates that the
+                        incoming spherical coordinates were not solar
+                        coordinates. */
+} vsop_error_state;
+
 /*! @brief A user-available structure to refer to VSOP data.
  */
 typedef struct {
@@ -493,22 +526,14 @@
     double jd;			/*!< @brief The Julian Date of these coordinates, in dynamical time.                      */
     rec_coords rc;		/*!< @brief The XYZ coordinates.                                                          */
     int is_inverted;		/*!< @brief Set to 1 if these coordinates are inverted (eg. for Solar coordinates), 0 otherwise. */
-    int error_state;		/*!< @brief The state of these
+    vsop_error_state error_state; /*!< @brief The state of these
 				            coordinates, indicating if
 				            they're okay to use.  Note
 				            that this field is only
 				            valid once the struct
 				            values have been
 				            calculated at least once.
-
-				            0 indicates no error.
-				            -1 (vsop_get_rectangular) indicates a vsop_handle error.  (Data referenced by this handle wasn't found - perhaps it was unloaded.)
-				            -2 (vsop_get_rectangular, sol_sph_to_rec) indicates that a vsop_handle referenced data that wasn't rectangular, or otherwise not suitable for providing rectangular coordinates.
-				            -3 (vsop_rec_vsop_to_fk5) indicates that supplied coordinates were unsuitable for converting to FK5.
-					    -4 (vsop_rec_sol) indicates that supplied coordinates were not Earth coordinates, and therefore unsuitable for converting to solar coordinates.  Note that even if the input planet is vsop_earth, is_inverted must be set to 0 or this error will be returned.
-					    -5 (vsop_rec_sol) indicates that supplied coordinates were not rectangular J2000 or date coordinates.
-					    -6 (sol_sph_to_rec) indicates that the incoming spherical coordinates were not solar coordinates.
-				 */
+				  */
 } vsop_rec_coords;
 
 /*! @brief Struct for holding spherical coordinates.
@@ -529,20 +554,13 @@
     double jd;			/*!< @brief The Julian Date of these coordinates, in dynamical time.                      */
     sph_coords sc;		/*!< @brief The spherical coordinates.                                                    */
     int is_inverted;		/*!< @brief Set to 1 if these coordinates are inverted (eg. for Solar coordinates), 0 otherwise. */
-    int error_state;		/*!< @brief The state of these coordinates,
-				   indicating if they're okay to use.
-				   Note that this field is only valid
-				   once the struct values have been
-				   calculated at least once.
-
-				   0 indicates no error.
-				   -1 (vsop_get_spherical) indicates a vsop_handle error.  (Data referenced by this handle wasn't found - perhaps it was unloaded.)
-				   -2 (vsop_get_spherical, sol_sph_to_rec) indicates that a vsop_handle referenced data that wasn't spherical, or otherwise not suitable for providing spherical coordinates.  (This should really only happen if the data in the struct has been corrupted somehow.)
-				   -3 (vsop_sph_vsop_to_fk5) indicates that supplied coordinates were unsuitable for converting to FK5.
-				   -4 (vsop_sph_sol) indicates that supplied coordinates were not Earth coordinates, and therefore unsuitable for converting to solar coordinates.  Note that even if the input planet is vsop_earth, is_inverted must be set to 0 or this error will be returned.
-				   -5 (vsop_sph_sol) indicates that supplied coordinates were not rectangular J2000 or date coordinates.
-				   -6 (sol_sph_to_rec) indicates that the incoming spherical coordinates were not solar coordinates.
-				 */
+    vsop_error_state error_state;  /*!< @brief The state of these
+				        coordinates, indicating if
+				        they're okay to use.  Note
+				        that this field is only valid
+				        once the struct values have
+				        been calculated at least once.
+				   */
 } vsop_sph_coords;
 
 /* vsop_data_handling.c */

Modified: branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c
===================================================================
--- branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c	2006-01-31 01:43:01 UTC (rev 238)
+++ branches/new-vsop-prepare/src/c/libephemeritis/vsop_calculate.c	2006-01-31 08:06:59 UTC (rev 239)
@@ -108,7 +108,7 @@
  *  rectangular coordinates.  ie. vh.variable must be one of
  *  hel_rec_j2, hel_rec_date, or bar_rec_j2.  If it isn't, the
  *  error_state property of the returned struct will be set to a
- *  non-zero value.
+ *  non-ok value.
  *
  *  @param vh The VSOP handle referencing the data to use for the
  *            calculation.
@@ -132,7 +132,7 @@
     /* Get a reference to the body_elements structure for this handle. */
     body_elements *be;
     if (NULL == (be = ephint_get_body_elements_for_handle(vh))) {
-	vrc.error_state = -1;
+	vrc.error_state = vh_access_error;
 	return vrc;
     }
 
@@ -140,7 +140,7 @@
     if (!
 	(vh.version == hel_rec_j2 || vh.version == hel_rec_date
 	 || vh.version == bar_rec_j2)) {
-	vrc.error_state = -2;
+	vrc.error_state = bad_data;
 	return vrc;
     }
 
@@ -149,7 +149,7 @@
     vrc.rc.x = internal_vsop_dimension_calc(be, 0, jd);
     vrc.rc.y = internal_vsop_dimension_calc(be, 1, jd);
     vrc.rc.z = internal_vsop_dimension_calc(be, 2, jd);
-    vrc.error_state = 0;
+    vrc.error_state = ok;
 
     /* Return 0 for success. */
     return vrc;
@@ -186,7 +186,7 @@
     vsop_rec_coords output = vrc;
 
     /* Stop right here if the incoming coordinates are in an error state. */
-    if (output.error_state != 0) {
+    if (output.error_state != ok) {
 	return output;
     }
 
@@ -197,7 +197,7 @@
 	 || output.vh.version == hel_rec_date
 	 */
 	 || output.vh.version == bar_rec_j2)) {
-	output.error_state = -3;
+	output.error_state = bad_for_fk5;
 	return output;
     }
 
@@ -210,7 +210,7 @@
     output.rc.z =
 	vrc.rc.x * 0.000000000000 + vrc.rc.y * 0.397776982902 +
 	vrc.rc.z * +0.917482137087;
-    output.error_state = 0;
+    output.error_state = ok;
 
     return output;
 }
@@ -234,7 +234,7 @@
     vsop_rec_coords output = vrc;
 
     /* Stop right here if the incoming coordinates are in an error state. */
-    if (output.error_state != 0) {
+    if (output.error_state != ok) {
 	return output;
     }
 
@@ -263,18 +263,18 @@
     vsop_rec_coords output = earth_vrc;
 
     /* Stop right here if the incoming coordinates are in an error state. */
-    if (output.error_state != 0) {
+    if (output.error_state != ok) {
 	return output;
     }
 
     /* Make sure that these coordinates actually are for Earth, and
        that they're rectangular date or j2000 variables. */
     if(output.vh.planet != vsop_earth && !output.is_inverted) {
-      output.error_state = -4;
+      output.error_state = not_earth;
       return output;
     }
     if(output.vh.version != hel_rec_j2 && output.vh.version != hel_rec_date) {
-      output.error_state = -5;
+      output.error_state = wrong_source;
       return output;
     }
 
@@ -290,7 +290,7 @@
  *  The referenced VSOP data must be data designed for calculating
  *  spherical coordinates.  ie. vh.variable must be one of hel_sph_j2,
  *  or hel_sph_date.  If it isn't, the error_state property of the
- *  returned struct will be set to a non-zero value.
+ *  returned struct will be set to a non-ok value.
  *
  *  @param vh The VSOP handle referencing the data to use for the
  *            calculation.
@@ -314,13 +314,13 @@
     /* Get a reference to the body_elements structure for this handle. */
     body_elements *be;
     if (NULL == (be = ephint_get_body_elements_for_handle(vh))) {
-	vsc.error_state = -1;
+	vsc.error_state = vh_access_error;
 	return vsc;
     }
 
     /* Confirm that the body elements for the handle contain data with spherical coordinates. */
     if (!(vh.version == hel_sph_j2 || vh.version == hel_sph_date)) {
-	vsc.error_state = -2;
+	vsc.error_state = bad_data;
 	return vsc;
     }
 
@@ -331,7 +331,7 @@
     vsc.sc.R = internal_vsop_dimension_calc(be, 2, jd);
 
     /* Return 0 for success. */
-    vsc.error_state = 0;
+    vsc.error_state = ok;
     return vsc;
 }
 
@@ -343,7 +343,7 @@
  *  for the dynamical ecliptic and equinox of the date.  ie. They must
  *  have been generated from hel_sph_j2 or hel_sph_date.  If it isn't,
  *  the error_state property of the returned struct will be set to a
- *  non-zero value.  If it is already a non-zero value for the
+ *  non-ok value.  If it is already a non-zero value for the
  *  incoming data, the data will be immediately returned with no
  *  change.
  *
@@ -365,7 +365,7 @@
     vsop_sph_coords output = vsc;
 
     /* Stop right here if the incoming coordinates are in an error state. */
-    if (output.error_state != 0) {
+    if (output.error_state != ok) {
 	return output;
     }
 
@@ -374,7 +374,7 @@
 	(output.vh.version == hel_sph_date
 	 || output.vh.version == hel_sph_j2)
 	) {
-	output.error_state = -3;
+	output.error_state = bad_for_fk5;
 	return output;
     }
 
@@ -424,7 +424,7 @@
     vsop_sph_coords output = vsc;
 
     /* Stop right here if the incoming coordinates are in an error state. */
-    if (output.error_state != 0) {
+    if (output.error_state != ok) {
 	return output;
     }
 
@@ -452,18 +452,18 @@
     vsop_sph_coords output = earth_vsc;
 
     /* Stop right here if the incoming coordinates are in an error state. */
-    if (output.error_state != 0) {
+    if (output.error_state != ok) {
 	return output;
     }
 
     /* Make sure that these coordinates actually are for Earth, and
        that they're spherical date or j2000 variables. */
     if(output.vh.planet != vsop_earth && !output.is_inverted) {
-      output.error_state = -4;
+      output.error_state = not_earth;
       return output;
     }
     if(output.vh.version != hel_sph_j2 && output.vh.version != hel_sph_date) {
-      output.error_state = -5;
+      output.error_state = wrong_source;
       return output;
     }
 
@@ -513,19 +513,19 @@
   vrc.error_state = vsc.error_state;
 
   /* Bail out now if things are in an error state. */
-  if(0 != vrc.error_state) {
+  if(ok != vrc.error_state) {
     return vrc;
   }
 
   /* Make sure these are spherical coordinates for j2 or the date. */
   if(!(hel_sph_j2 == vrc.vh.version || hel_sph_date == vrc.vh.version)) {
-    vrc.error_state = -2;
+    vrc.error_state = bad_data;
     return vrc;
   }
 
   /* Make sure these are geometric solar coordinates.  (ie. Inverted Earth.) */
   if(!(vsop_earth == vrc.vh.planet && vrc.is_inverted)) {
-    vrc.error_state = -6;
+    vrc.error_state = not_solar;
     return vrc;
   }
 

Modified: branches/new-vsop-prepare/src/c/tests/validate_meeus.c
===================================================================
--- branches/new-vsop-prepare/src/c/tests/validate_meeus.c	2006-01-31 01:43:01 UTC (rev 238)
+++ branches/new-vsop-prepare/src/c/tests/validate_meeus.c	2006-01-31 08:06:59 UTC (rev 239)
@@ -92,7 +92,7 @@
     vsop_handle vh;
     if (0 == get_vsop_data_handle(planet, hel_sph_date, &vh)) {
 	vsop_sph_coords vsc = vsop_get_spherical(vh, jd);
-	if (vsc.error_state != 0) {
+	if (vsc.error_state != ok) {
 	    printf("Error calculating spherical coordinates: %d\n",
 		   vsc.error_state);
 	    return 0;
@@ -116,7 +116,7 @@
     if (0 == get_vsop_data_handle(planet, hel_sph_date, &vh)) {
 	vsop_sph_coords vsc =
 	    vsop_sph_to_fk5(vsop_get_spherical(vh, jd));
-	if (vsc.error_state != 0) {
+	if (vsc.error_state != ok) {
 	    printf("Error calculating spherical coordinates: %d\n",
 		   vsc.error_state);
 	    return 0;
@@ -1210,19 +1210,13 @@
 
 
 	    /* Things to do:
-	     *   correct for light time.
+	     *   correct for light time. (done above)
 	     *   correct for nutation.
 	     *   correct for precession.
 	     *   correct for aberration.
+	     *
 	     */
 	    /*
-	    double a_in_ra, a_in_dec;
-	    aberration_in_ra_dec_low(test->jd, ra, dec,
-				     obliquity_hi(test->jd), vsc.sc.L,
-				     &a_in_ra, &a_in_dec);
-	    ra += a_in_ra;
-	    dec += a_in_dec;
-
 	    precession_eq(precession_get_elements_eq
 			  (je_to_jd(2000.0), test->jd), ra, dec, &ra,
 			  &dec);
@@ -1233,17 +1227,15 @@
 			  &n_in_ra, &n_in_dec);
 	    ra += n_in_ra;
 	    dec += n_in_dec;
-	    */
 
-	    /*
-	    printf("$$$$ %f:%f $$$$\n",
-		   (n_in_ra * (360.0 * 60.0 * 60.0) / (2 * pi)),
-		   (n_in_dec * (360.0 * 60.0 * 60.0) / (2 * pi)));
-	    printf("$$$$ %f:%f $$$$\n",
-		   (a_in_ra * (360.0 * 60.0 * 60.0) / (2 * pi)),
-		   (a_in_dec * (360.0 * 60.0 * 60.0) / (2 * pi)));
+	    double a_in_ra, a_in_dec;
+	    aberration_in_ra_dec_low(test->jd, ra, dec,
+				     obliquity_hi(test->jd), vsc.sc.L,
+				     &a_in_ra, &a_in_dec);
+	    ra += a_in_ra;
+	    dec += a_in_dec;
 	    */
-
+	    
 	    report_diff("RA              ", r_to_d(ra) * 3600,
 			r_to_d(test->ra) * 3600,
 		   "arc-sec");



